import { assert as p } from "./Address.js";
import { BaseError as u } from "./Errors.js";
import { size as y, padLeft as f, fromString as x, fromBoolean as w, fromNumber as E, padRight as P, concat as g } from "./Hex.js";
import { integerRegex as A, bytesRegex as $, arrayRegex as L } from "./Solidity.js";
import { prepareParameters as z, encode as I } from "./internal/abiParameters.js";
function N(n, e, t) {
  const { checksumAddress: r = !1 } = {};
  if (n.length !== e.length)
    throw new b({
      expectedLength: n.length,
      givenLength: e.length
    });
  const a = z({
    checksumAddress: r,
    parameters: n,
    values: e
  }), s = I(a);
  return s.length === 0 ? "0x" : s;
}
function m(n, e) {
  if (n.length !== e.length)
    throw new b({
      expectedLength: n.length,
      givenLength: e.length
    });
  const t = [];
  for (let r = 0; r < n.length; r++) {
    const a = n[r], s = e[r];
    t.push(m.encode(a, s));
  }
  return g(...t);
}
(function(n) {
  function e(t, r, a = !1) {
    if (t === "address") {
      const i = r;
      return p(i), f(i.toLowerCase(), a ? 32 : 0);
    }
    if (t === "string")
      return x(r);
    if (t === "bytes")
      return r;
    if (t === "bool")
      return f(w(r), a ? 32 : 1);
    const s = t.match(A);
    if (s) {
      const [i, o, c = "256"] = s, h = Number.parseInt(c) / 8;
      return E(r, {
        size: a ? 32 : h,
        signed: o === "int"
      });
    }
    const d = t.match($);
    if (d) {
      const [i, o] = d;
      if (Number.parseInt(o) !== (r.length - 2) / 2)
        throw new M({
          expectedSize: Number.parseInt(o),
          value: r
        });
      return P(r, a ? 32 : 0);
    }
    const l = t.match(L);
    if (l && Array.isArray(r)) {
      const [i, o] = l, c = [];
      for (let h = 0; h < r.length; h++)
        c.push(e(o, r[h], !0));
      return c.length === 0 ? "0x" : g(...c);
    }
    throw new j(t);
  }
  n.encode = e;
})(m || (m = {}));
class R extends u {
  constructor({ expectedLength: e, givenLength: t, type: r }) {
    super(`Array length mismatch for type \`${r}\`. Expected: \`${e}\`. Given: \`${t}\`.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
}
class M extends u {
  constructor({ expectedSize: e, value: t }) {
    super(`Size of bytes "${t}" (bytes${y(t)}) does not match expected size (bytes${e}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
}
class b extends u {
  constructor({ expectedLength: e, givenLength: t }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${e}`,
      `Given length (values): ${t}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.LengthMismatchError"
    });
  }
}
class _ extends u {
  constructor(e) {
    super(`Value \`${e}\` is not a valid array.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidArrayError"
    });
  }
}
class j extends u {
  constructor(e) {
    super(`Type \`${e}\` is not a valid ABI Type.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiParameters.InvalidTypeError"
    });
  }
}
export {
  R as ArrayLengthMismatchError,
  M as BytesSizeMismatchError,
  _ as InvalidArrayError,
  j as InvalidTypeError,
  b as LengthMismatchError,
  N as encode,
  m as encodePacked
};
