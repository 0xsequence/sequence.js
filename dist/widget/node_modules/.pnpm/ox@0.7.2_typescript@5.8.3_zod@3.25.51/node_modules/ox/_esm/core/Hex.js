import { BaseError as o } from "./Errors.js";
import { stringify as b } from "./Json.js";
import { assertSize as d, pad as g, assertStartOffset as m, assertEndOffset as p } from "./internal/hex.js";
const $ = /* @__PURE__ */ new TextEncoder(), h = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function y(t, e = {}) {
  const { strict: r = !1 } = e;
  if (!t)
    throw new f(t);
  if (typeof t != "string")
    throw new f(t);
  if (r && !/^0x[0-9a-fA-F]*$/.test(t))
    throw new l(t);
  if (!t.startsWith("0x"))
    throw new l(t);
}
function B(...t) {
  return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
}
function P(t, e = {}) {
  const r = `0x${Number(t)}`;
  return typeof e.size == "number" ? (d(r, e.size), x(r, e.size)) : r;
}
function w(t, e = {}) {
  let r = "";
  for (let i = 0; i < t.length; i++)
    r += h[t[i]];
  const n = `0x${r}`;
  return typeof e.size == "number" ? (d(n, e.size), E(n, e.size)) : n;
}
function V(t, e = {}) {
  const { signed: r, size: n } = e, i = BigInt(t);
  let s;
  n ? r ? s = (1n << BigInt(n) * 8n - 1n) - 1n : s = 2n ** (BigInt(n) * 8n) - 1n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const u = typeof s == "bigint" && r ? -s - 1n : 0;
  if (s && i > s || i < u) {
    const a = typeof t == "bigint" ? "n" : "";
    throw new O({
      max: s ? `${s}${a}` : void 0,
      min: `${u}${a}`,
      signed: r,
      size: n,
      value: `${t}${a}`
    });
  }
  const c = `0x${(r && i < 0 ? (1n << BigInt(n * 8)) + BigInt(i) : i).toString(16)}`;
  return n ? x(c, n) : c;
}
function j(t, e = {}) {
  return w($.encode(t), e);
}
function x(t, e) {
  return g(t, { dir: "left", size: e });
}
function E(t, e) {
  return g(t, { dir: "right", size: e });
}
function v(t, e, r, n = {}) {
  const { strict: i } = n;
  m(t, e);
  const s = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (r ?? t.length) * 2)}`;
  return i && p(s, e, r), s;
}
function A(t) {
  return Math.ceil((t.length - 2) / 2);
}
function N(t, e = {}) {
  const { strict: r = !1 } = e;
  try {
    return y(t, { strict: r }), !0;
  } catch {
    return !1;
  }
}
class O extends o {
  constructor({ max: e, min: r, signed: n, size: i, value: s }) {
    super(`Number \`${s}\` is not in safe${i ? ` ${i * 8}-bit` : ""}${n ? " signed" : " unsigned"} integer range ${e ? `(\`${r}\` to \`${e}\`)` : `(above \`${r}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
}
class f extends o {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? b(e) : e}\` of type \`${typeof e}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexTypeError"
    });
  }
}
class l extends o {
  constructor(e) {
    super(`Value \`${e}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.InvalidHexValueError"
    });
  }
}
class _ extends o {
  constructor({ givenSize: e, maxSize: r }) {
    super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeOverflowError"
    });
  }
}
class M extends o {
  constructor({ offset: e, position: r, size: n }) {
    super(`Slice ${r === "start" ? "starting" : "ending"} at offset \`${e}\` is out-of-bounds (size: \`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
}
class R extends o {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
}
export {
  O as IntegerOutOfRangeError,
  f as InvalidHexTypeError,
  l as InvalidHexValueError,
  R as SizeExceedsPaddingSizeError,
  _ as SizeOverflowError,
  M as SliceOffsetOutOfBoundsError,
  y as assert,
  B as concat,
  P as fromBoolean,
  w as fromBytes,
  V as fromNumber,
  j as fromString,
  x as padLeft,
  E as padRight,
  A as size,
  v as slice,
  N as validate
};
