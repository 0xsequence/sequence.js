import { BaseError as y } from "./Errors.js";
import { keccak256 as v } from "./Hash.js";
import { fromString as $, validate as S, slice as b } from "./Hex.js";
import { isArgOfType as E, normalizeSignature as p, getAmbiguousTypes as B } from "./internal/abiItem.js";
import { parseAbiItem as g } from "../../../../../abitype@1.0.8_typescript@5.8.3_zod@3.25.51/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js";
import { formatAbiItem as h } from "../../../../../abitype@1.0.8_typescript@5.8.3_zod@3.25.51/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js";
function z(t, r = {}) {
  const { prepare: i = !0 } = r, n = Array.isArray(t) ? g(t) : g(t);
  return {
    ...n,
    ...i ? { hash: s(n) } : {}
  };
}
function H(t, r, i) {
  const { args: n = [], prepare: f = !0 } = i ?? {}, A = S(r, { strict: !1 }), u = t.filter((e) => A ? e.type === "function" || e.type === "error" ? T(e) === b(r, 0, 4) : e.type === "event" ? s(e) === r : !1 : "name" in e && e.name === r);
  if (u.length === 0)
    throw new d({ name: r });
  if (u.length === 1)
    return {
      ...u[0],
      ...f ? { hash: s(u[0]) } : {}
    };
  let o;
  for (const e of u) {
    if (!("inputs" in e))
      continue;
    if (!n || n.length === 0) {
      if (!e.inputs || e.inputs.length === 0)
        return {
          ...e,
          ...f ? { hash: s(e) } : {}
        };
      continue;
    }
    if (!e.inputs || e.inputs.length === 0 || e.inputs.length !== n.length)
      continue;
    if (n.every((a, w) => {
      const l = "inputs" in e && e.inputs[w];
      return l ? E(a, l) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const a = B(e.inputs, o.inputs, n);
        if (a)
          throw new O({
            abiItem: e,
            type: a[0]
          }, {
            abiItem: o,
            type: a[1]
          });
      }
      o = e;
    }
  }
  const c = (() => {
    if (o)
      return o;
    const [e, ...m] = u;
    return { ...e, overloads: m };
  })();
  if (!c)
    throw new d({ name: r });
  return {
    ...c,
    ...f ? { hash: s(c) } : {}
  };
}
function T(t) {
  return b(s(t), 0, 4);
}
function F(t) {
  const r = typeof t == "string" ? t : h(t);
  return p(r);
}
function s(t) {
  return typeof t != "string" && "hash" in t && t.hash ? t.hash : v($(F(t)));
}
class O extends y {
  constructor(r, i) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        // TODO: abitype to add support for signature-formatted ABI items.
        `\`${r.type}\` in \`${p(h(r.abiItem))}\`, and`,
        `\`${i.type}\` in \`${p(h(i.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.AmbiguityError"
    });
  }
}
class d extends y {
  constructor({ name: r, data: i, type: n = "item" }) {
    const f = r ? ` with name "${r}"` : i ? ` with data "${i}"` : "";
    super(`ABI ${n}${f} not found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItem.NotFoundError"
    });
  }
}
export {
  O as AmbiguityError,
  d as NotFoundError,
  z as from,
  H as fromAbi,
  T as getSelector,
  F as getSignature,
  s as getSignatureHash
};
