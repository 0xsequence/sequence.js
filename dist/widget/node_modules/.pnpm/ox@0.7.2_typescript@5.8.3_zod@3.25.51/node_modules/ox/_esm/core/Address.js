import { fromString as d } from "./Bytes.js";
import { checksum as c } from "./Caches.js";
import { BaseError as o } from "./Errors.js";
import { keccak256 as l } from "./Hash.js";
const m = /^0x[a-fA-F0-9]{40}$/;
function i(r, e = {}) {
  const { strict: t = !0 } = e;
  if (!m.test(r))
    throw new a({
      address: r,
      cause: new h()
    });
  if (t) {
    if (r.toLowerCase() === r)
      return;
    if (f(r) !== r)
      throw new a({
        address: r,
        cause: new p()
      });
  }
}
function f(r) {
  if (c.has(r))
    return c.get(r);
  i(r, { strict: !1 });
  const e = r.substring(2).toLowerCase(), t = l(d(e), { as: "Bytes" }), n = e.split("");
  for (let s = 0; s < 40; s += 2)
    t[s >> 1] >> 4 >= 8 && n[s] && (n[s] = n[s].toUpperCase()), (t[s >> 1] & 15) >= 8 && n[s + 1] && (n[s + 1] = n[s + 1].toUpperCase());
  const u = `0x${n.join("")}`;
  return c.set(r, u), u;
}
function A(r, e = {}) {
  const { checksum: t = !1 } = e;
  return i(r), t ? f(r) : r;
}
function I(r, e = {}) {
  const { strict: t = !0 } = e ?? {};
  try {
    return i(r, { strict: t }), !0;
  } catch {
    return !1;
  }
}
class a extends o {
  constructor({ address: e, cause: t }) {
    super(`Address "${e}" is invalid.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidAddressError"
    });
  }
}
class h extends o {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidInputError"
    });
  }
}
class p extends o {
  constructor() {
    super("Address does not match its checksum counterpart."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Address.InvalidChecksumError"
    });
  }
}
export {
  a as InvalidAddressError,
  p as InvalidChecksumError,
  h as InvalidInputError,
  i as assert,
  f as checksum,
  A as from,
  I as validate
};
