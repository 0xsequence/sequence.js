import { BaseError as f } from "./Errors.js";
import { fromBytes as b, padRight as m } from "./Hex.js";
import { stringify as g } from "./Json.js";
import { charCodeToBase16 as h, pad as p, assertSize as l } from "./internal/bytes.js";
import { assertSize as w } from "./internal/hex.js";
const E = /* @__PURE__ */ new TextEncoder();
function z(e) {
  if (!(e instanceof Uint8Array)) {
    if (!e)
      throw new c(e);
    if (typeof e != "object")
      throw new c(e);
    if (!("BYTES_PER_ELEMENT" in e))
      throw new c(e);
    if (e.BYTES_PER_ELEMENT !== 1 || e.constructor.name !== "Uint8Array")
      throw new c(e);
  }
}
function j(...e) {
  let t = 0;
  for (const r of e)
    t += r.length;
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, i), i += o.length;
  }
  return n;
}
function R(e) {
  return e instanceof Uint8Array ? e : typeof e == "string" ? S(e) : x(e);
}
function x(e) {
  return e instanceof Uint8Array ? e : new Uint8Array(e);
}
function S(e, t = {}) {
  const { size: n } = t;
  let r = e;
  n && (w(e, n), r = m(e, n));
  let i = r.slice(2);
  i.length % 2 && (i = `0${i}`);
  const o = i.length / 2, d = new Uint8Array(o);
  for (let a = 0, s = 0; a < o; a++) {
    const u = h(i.charCodeAt(s++)), y = h(i.charCodeAt(s++));
    if (u === void 0 || y === void 0)
      throw new f(`Invalid byte sequence ("${i[s - 2]}${i[s - 1]}" in "${i}").`);
    d[a] = u * 16 + y;
  }
  return d;
}
function C(e, t = {}) {
  const { size: n } = t, r = E.encode(e);
  return typeof n == "number" ? (l(r, n), $(r, n)) : r;
}
function L(e, t) {
  return p(e, { dir: "left", size: t });
}
function $(e, t) {
  return p(e, { dir: "right", size: t });
}
function O(e) {
  return e.length;
}
function _(e, t = {}) {
  return b(e, t);
}
function I(e) {
  try {
    return z(e), !0;
  } catch {
    return !1;
  }
}
class c extends f {
  constructor(t) {
    super(`Value \`${typeof t == "object" ? g(t) : t}\` of type \`${typeof t}\` is an invalid Bytes value.`, {
      metaMessages: ["Bytes values must be of type `Bytes`."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.InvalidBytesTypeError"
    });
  }
}
class M extends f {
  constructor({ givenSize: t, maxSize: n }) {
    super(`Size cannot exceed \`${n}\` bytes. Given size: \`${t}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeOverflowError"
    });
  }
}
class H extends f {
  constructor({ size: t, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${t}\`) exceeds padding size (\`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
}
export {
  c as InvalidBytesTypeError,
  H as SizeExceedsPaddingSizeError,
  M as SizeOverflowError,
  z as assert,
  j as concat,
  R as from,
  x as fromArray,
  S as fromHex,
  C as fromString,
  L as padLeft,
  $ as padRight,
  O as size,
  _ as toHex,
  I as validate
};
