import { validate as c } from "../Address.js";
import { BaseError as f } from "../Errors.js";
function y(r) {
  let i = !0, t = "", e = 0, n = "", o = !1;
  for (let s = 0; s < r.length; s++) {
    const u = r[s];
    if (["(", ")", ","].includes(u) && (i = !0), u === "(" && e++, u === ")" && e--, !!i) {
      if (e === 0) {
        if (u === " " && ["event", "function", "error", ""].includes(n))
          n = "";
        else if (n += u, u === ")") {
          o = !0;
          break;
        }
        continue;
      }
      if (u === " ") {
        r[s - 1] !== "," && t !== "," && t !== ",(" && (t = "", i = !1);
        continue;
      }
      n += u, t += u;
    }
  }
  if (!o)
    throw new f("Unable to normalize signature.");
  return n;
}
function l(r, i) {
  const t = typeof r, e = i.type;
  switch (e) {
    case "address":
      return c(r, { strict: !1 });
    case "bool":
      return t === "boolean";
    case "function":
      return t === "string";
    case "string":
      return t === "string";
    default:
      return e === "tuple" && "components" in i ? Object.values(i.components).every((n, o) => l(Object.values(r)[o], n)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(e) ? t === "number" || t === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(e) ? t === "string" || r instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(e) ? Array.isArray(r) && r.every((n) => l(n, {
        ...i,
        // Pop off `[]` or `[M]` from end of type
        type: e.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function a(r, i, t) {
  for (const e in r) {
    const n = r[e], o = i[e];
    if (n.type === "tuple" && o.type === "tuple" && "components" in n && "components" in o)
      return a(n.components, o.components, t[e]);
    const s = [n.type, o.type];
    if (s.includes("address") && s.includes("bytes20") ? !0 : s.includes("address") && s.includes("string") ? c(t[e], {
      strict: !1
    }) : s.includes("address") && s.includes("bytes") ? c(t[e], {
      strict: !1
    }) : !1)
      return s;
  }
}
export {
  a as getAmbiguousTypes,
  l as isArgOfType,
  y as normalizeSignature
};
