import { InvalidTypeError as g, InvalidArrayError as b, ArrayLengthMismatchError as w, BytesSizeMismatchError as z } from "../AbiParameters.js";
import { assert as x } from "../Address.js";
import { BaseError as S } from "../Errors.js";
import { size as d, fromNumber as f, concat as p, padLeft as h, fromBoolean as A, IntegerOutOfRangeError as E, padRight as y, fromString as I, slice as B } from "../Hex.js";
import { integerRegex as L } from "../Solidity.js";
function q({ checksumAddress: e, parameters: n, values: r }) {
  const t = [];
  for (let o = 0; o < n.length; o++)
    t.push(u({
      checksumAddress: e,
      parameter: n[o],
      value: r[o]
    }));
  return t;
}
function u({ checksumAddress: e = !1, parameter: n, value: r }) {
  const t = n, o = k(t.type);
  if (o) {
    const [i, c] = o;
    return P(r, {
      checksumAddress: e,
      length: i,
      parameter: {
        ...t,
        type: c
      }
    });
  }
  if (t.type === "tuple")
    return R(r, {
      checksumAddress: e,
      parameter: t
    });
  if (t.type === "address")
    return N(r, {
      checksum: e
    });
  if (t.type === "bool")
    return C(r);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const i = t.type.startsWith("int"), [, , c = "256"] = L.exec(t.type) ?? [];
    return M(r, {
      signed: i,
      size: Number(c)
    });
  }
  if (t.type.startsWith("bytes"))
    return $(r, { type: t.type });
  if (t.type === "string")
    return W(r);
  throw new g(t.type);
}
function l(e) {
  let n = 0;
  for (let i = 0; i < e.length; i++) {
    const { dynamic: c, encoded: s } = e[i];
    c ? n += 32 : n += d(s);
  }
  const r = [], t = [];
  let o = 0;
  for (let i = 0; i < e.length; i++) {
    const { dynamic: c, encoded: s } = e[i];
    c ? (r.push(f(n + o, { size: 32 })), t.push(s), o += d(s)) : r.push(s);
  }
  return p(...r, ...t);
}
function N(e, n) {
  const { checksum: r = !1 } = n;
  return x(e, { strict: r }), {
    dynamic: !1,
    encoded: h(e.toLowerCase())
  };
}
function P(e, n) {
  const { checksumAddress: r, length: t, parameter: o } = n, i = t === null;
  if (!Array.isArray(e))
    throw new b(e);
  if (!i && e.length !== t)
    throw new w({
      expectedLength: t,
      givenLength: e.length,
      type: `${o.type}[${t}]`
    });
  let c = !1;
  const s = [];
  for (let a = 0; a < e.length; a++) {
    const m = u({
      checksumAddress: r,
      parameter: o,
      value: e[a]
    });
    m.dynamic && (c = !0), s.push(m);
  }
  if (i || c) {
    const a = l(s);
    if (i) {
      const m = f(s.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: s.length > 0 ? p(m, a) : m
      };
    }
    if (c)
      return { dynamic: !0, encoded: a };
  }
  return {
    dynamic: !1,
    encoded: p(...s.map(({ encoded: a }) => a))
  };
}
function $(e, { type: n }) {
  const [, r] = n.split("bytes"), t = d(e);
  if (!r) {
    let o = e;
    return t % 32 !== 0 && (o = y(o, Math.ceil((e.length - 2) / 2 / 32) * 32)), {
      dynamic: !0,
      encoded: p(h(f(t, { size: 32 })), o)
    };
  }
  if (t !== Number.parseInt(r))
    throw new z({
      expectedSize: Number.parseInt(r),
      value: e
    });
  return { dynamic: !1, encoded: y(e) };
}
function C(e) {
  if (typeof e != "boolean")
    throw new S(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: h(A(e)) };
}
function M(e, { signed: n, size: r }) {
  if (typeof r == "number") {
    const t = 2n ** (BigInt(r) - (n ? 1n : 0n)) - 1n, o = n ? -t - 1n : 0n;
    if (e > t || e < o)
      throw new E({
        max: t.toString(),
        min: o.toString(),
        signed: n,
        size: r / 8,
        value: e.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: f(e, {
      size: 32,
      signed: n
    })
  };
}
function W(e) {
  const n = I(e), r = Math.ceil(d(n) / 32), t = [];
  for (let o = 0; o < r; o++)
    t.push(y(B(n, o * 32, (o + 1) * 32)));
  return {
    dynamic: !0,
    encoded: p(y(f(d(n), { size: 32 })), ...t)
  };
}
function R(e, n) {
  const { checksumAddress: r, parameter: t } = n;
  let o = !1;
  const i = [];
  for (let c = 0; c < t.components.length; c++) {
    const s = t.components[c], a = Array.isArray(e) ? c : s.name, m = u({
      checksumAddress: r,
      parameter: s,
      value: e[a]
    });
    i.push(m), m.dynamic && (o = !0);
  }
  return {
    dynamic: o,
    encoded: o ? l(i) : p(...i.map(({ encoded: c }) => c))
  };
}
function k(e) {
  const n = e.match(/^(.*)\[(\d+)?\]$/);
  return n ? (
    // Return `null` if the array is dynamic.
    [n[2] ? Number(n[2]) : null, n[1]]
  ) : void 0;
}
export {
  l as encode,
  N as encodeAddress,
  P as encodeArray,
  C as encodeBoolean,
  $ as encodeBytes,
  M as encodeNumber,
  W as encodeString,
  R as encodeTuple,
  k as getArrayComponents,
  u as prepareParameter,
  q as prepareParameters
};
