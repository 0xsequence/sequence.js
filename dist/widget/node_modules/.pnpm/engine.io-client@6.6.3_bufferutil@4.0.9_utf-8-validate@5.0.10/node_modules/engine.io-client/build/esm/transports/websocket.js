import { Transport as h } from "../transport.js";
import { pick as p, randomString as d } from "../util.js";
import { encodePacket as m } from "../../../../../../engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/encodePacket.browser.js";
import "../../../../../../engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/commons.js";
import "../../../../../../engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js";
import { globalThisShim as i, nextTick as l } from "../globals.js";
const n = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class w extends h {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), e = this.opts.protocols, s = n ? {} : p(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (s.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, e, s);
    } catch (r) {
      return this.emitReserved("error", r);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const s = t[e], r = e === t.length - 1;
      m(s, this.supportsBinary, (c) => {
        try {
          this.doWrite(s, c);
        } catch {
        }
        r && l(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", e = this.query || {};
    return this.opts.timestampRequests && (e[this.opts.timestampParam] = d()), this.supportsBinary || (e.b64 = 1), this.createUri(t, e);
  }
}
const o = i.WebSocket || i.MozWebSocket;
class S extends w {
  createSocket(t, e, s) {
    return n ? new o(t, e, s) : e ? new o(t, e) : new o(t);
  }
  doWrite(t, e) {
    this.ws.send(e);
  }
}
export {
  w as BaseWS,
  S as WS
};
