const c = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, u = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function p(t) {
  if (t.length > 8e3)
    throw "URI too long";
  const o = t, i = t.indexOf("["), r = t.indexOf("]");
  i != -1 && r != -1 && (t = t.substring(0, i) + t.substring(i, r).replace(/:/g, ";") + t.substring(r, t.length));
  let n = c.exec(t || ""), e = {}, s = 14;
  for (; s--; )
    e[u[s]] = n[s] || "";
  return i != -1 && r != -1 && (e.source = o, e.host = e.host.substring(1, e.host.length - 1).replace(/;/g, ":"), e.authority = e.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), e.ipv6uri = !0), e.pathNames = a(e, e.path), e.queryKey = l(e, e.query), e;
}
function a(t, o) {
  const i = /\/{2,9}/g, r = o.replace(i, "/").split("/");
  return (o.slice(0, 1) == "/" || o.length === 0) && r.splice(0, 1), o.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function l(t, o) {
  const i = {};
  return o.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, n, e) {
    n && (i[n] = e);
  }), i;
}
export {
  p as parse
};
