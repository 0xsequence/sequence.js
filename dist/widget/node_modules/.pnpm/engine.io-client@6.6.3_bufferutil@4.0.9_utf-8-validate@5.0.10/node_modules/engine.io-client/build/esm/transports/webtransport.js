import { Transport as h } from "../transport.js";
import { nextTick as c } from "../globals.js";
import { createPacketDecoderStream as d, createPacketEncoderStream as p } from "../../../../../../engine.io-parser@5.2.3/node_modules/engine.io-parser/build/esm/index.js";
class _ extends h {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const e = d(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = t.readable.pipeThrough(e).getReader(), r = p();
        r.readable.pipeTo(t.writable), this._writer = r.writable.getWriter();
        const s = () => {
          i.read().then(({ done: a, value: n }) => {
            a || (this.onPacket(n), s());
          }).catch((a) => {
          });
        };
        s();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      this._writer.write(i).then(() => {
        r && c(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
export {
  _ as WT
};
