import { getAddress as k, SwitchChainError as U, numberToHex as M, UserRejectedRequestError as b, withRetry as I, hexToNumber as R, withTimeout as _, ResourceUnavailableRpcError as D } from "viem";
import { createConnector as q } from "../../../../../../@wagmi_core@2.17.2_@tanstack_query-core@5.80.5_@types_react@19.1.6_react@19.1.0_typescr_4f72fe994b45c490350d5701a857bfba/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js";
import { ChainNotConfiguredError as N } from "../../../../../../@wagmi_core@2.17.2_@tanstack_query-core@5.80.5_@types_react@19.1.6_react@19.1.0_typescr_4f72fe994b45c490350d5701a857bfba/node_modules/@wagmi/core/dist/esm/errors/config.js";
import { extractRpcUrls as W } from "../../../../../../@wagmi_core@2.17.2_@tanstack_query-core@5.80.5_@types_react@19.1.6_react@19.1.0_typescr_4f72fe994b45c490350d5701a857bfba/node_modules/@wagmi/core/dist/esm/utils/extractRpcUrls.js";
import { ProviderNotFoundError as L } from "../../../../../../@wagmi_core@2.17.2_@tanstack_query-core@5.80.5_@types_react@19.1.6_react@19.1.0_typescr_4f72fe994b45c490350d5701a857bfba/node_modules/@wagmi/core/dist/esm/errors/connector.js";
x.type = "metaMask";
function x(a = {}) {
  let v, C, m, y, h, s, A, l;
  return q((u) => ({
    id: "metaMaskSDK",
    name: "MetaMask",
    rdns: ["io.metamask", "io.metamask.mobile"],
    type: x.type,
    async setup() {
      const t = await this.getProvider();
      t != null && t.on && (s || (s = this.onConnect.bind(this), t.on("connect", s)), y || (y = this.onAccountsChanged.bind(this), t.on("accountsChanged", y)));
    },
    async connect({ chainId: t, isReconnecting: n } = {}) {
      const e = await this.getProvider();
      A || (A = this.onDisplayUri, e.on("display_uri", A));
      let i = [];
      n && (i = await this.getAccounts().catch(() => []));
      try {
        let w, r;
        i != null && i.length || (a.connectAndSign || a.connectWith ? (a.connectAndSign ? w = await v.connectAndSign({
          msg: a.connectAndSign
        }) : a.connectWith && (r = await v.connectWith({
          method: a.connectWith.method,
          params: a.connectWith.params
        })), i = await this.getAccounts()) : i = (await v.connect()).map((c) => k(c)));
        let d = await this.getChainId();
        if (t && d !== t) {
          const g = await this.switchChain({ chainId: t }).catch((c) => {
            if (c.code === b.code)
              throw c;
            return { id: d };
          });
          d = (g == null ? void 0 : g.id) ?? d;
        }
        return A && (e.removeListener("display_uri", A), A = void 0), w ? e.emit("connectAndSign", {
          accounts: i,
          chainId: d,
          signResponse: w
        }) : r && e.emit("connectWith", {
          accounts: i,
          chainId: d,
          connectWithResponse: r
        }), s && (e.removeListener("connect", s), s = void 0), y || (y = this.onAccountsChanged.bind(this), e.on("accountsChanged", y)), h || (h = this.onChainChanged.bind(this), e.on("chainChanged", h)), l || (l = this.onDisconnect.bind(this), e.on("disconnect", l)), { accounts: i, chainId: d };
      } catch (w) {
        const r = w;
        throw r.code === b.code ? new b(r) : r.code === D.code ? new D(r) : r;
      }
    },
    async disconnect() {
      const t = await this.getProvider();
      h && (t.removeListener("chainChanged", h), h = void 0), l && (t.removeListener("disconnect", l), l = void 0), s || (s = this.onConnect.bind(this), t.on("connect", s)), await v.terminate();
    },
    async getAccounts() {
      return (await (await this.getProvider()).request({
        method: "eth_accounts"
      })).map((e) => k(e));
    },
    async getChainId() {
      const t = await this.getProvider(), n = t.getChainId() || await (t == null ? void 0 : t.request({ method: "eth_chainId" }));
      return Number(n);
    },
    async getProvider() {
      async function t() {
        var r, d, g, c, f;
        const n = await (async () => {
          const { default: o } = await import("../../../../../../@metamask_sdk@0.32.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js");
          return typeof o != "function" && typeof o.default == "function" ? o.default : o;
        })(), e = {};
        for (const o of u.chains)
          e[M(o.id)] = (r = W({
            chain: o,
            transports: u.transports
          })) == null ? void 0 : r[0];
        v = new n({
          _source: "wagmi",
          forceDeleteProvider: !1,
          forceInjectProvider: !1,
          injectProvider: !1,
          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`
          ...a,
          readonlyRPCMap: e,
          dappMetadata: {
            ...a.dappMetadata,
            // Test if name and url are set AND not empty
            name: (d = a.dappMetadata) != null && d.name ? (g = a.dappMetadata) == null ? void 0 : g.name : "wagmi",
            url: (c = a.dappMetadata) != null && c.url ? (f = a.dappMetadata) == null ? void 0 : f.url : typeof window < "u" ? window.location.origin : "https://wagmi.sh"
          },
          useDeeplink: a.useDeeplink ?? !0
        });
        const i = await v.init(), w = i != null && i.activeProvider ? i.activeProvider : v.getProvider();
        if (!w)
          throw new L();
        return w;
      }
      return C || (m || (m = t()), C = await m), C;
    },
    async isAuthorized() {
      try {
        return !!(await I(() => _(() => this.getAccounts(), { timeout: 200 }), {
          delay: 201,
          retryCount: 3
        })).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: t, chainId: n }) {
      var d, g;
      const e = await this.getProvider(), i = u.chains.find((c) => c.id === n);
      if (!i)
        throw new U(new N());
      try {
        return await e.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: M(n) }]
        }), await w(), await r(n), i;
      } catch (c) {
        const f = c;
        if (f.code === b.code)
          throw new b(f);
        if (f.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((g = (d = f == null ? void 0 : f.data) == null ? void 0 : d.originalError) == null ? void 0 : g.code) === 4902)
          try {
            return await e.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  blockExplorerUrls: (() => {
                    const { default: o, ...p } = i.blockExplorers ?? {};
                    if (t != null && t.blockExplorerUrls)
                      return t.blockExplorerUrls;
                    if (o)
                      return [
                        o.url,
                        ...Object.values(p).map((S) => S.url)
                      ];
                  })(),
                  chainId: M(n),
                  chainName: (t == null ? void 0 : t.chainName) ?? i.name,
                  iconUrls: t == null ? void 0 : t.iconUrls,
                  nativeCurrency: (t == null ? void 0 : t.nativeCurrency) ?? i.nativeCurrency,
                  rpcUrls: (() => {
                    var o, p;
                    return (o = t == null ? void 0 : t.rpcUrls) != null && o.length ? t.rpcUrls : [((p = i.rpcUrls.default) == null ? void 0 : p.http[0]) ?? ""];
                  })()
                }
              ]
            }), await w(), await r(n), i;
          } catch (o) {
            const p = o;
            throw p.code === b.code ? new b(p) : new U(p);
          }
        throw new U(f);
      }
      async function w() {
        await I(async () => {
          const c = R(
            // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks
            await e.request({ method: "eth_chainId" })
          );
          if (c !== n)
            throw new Error("User rejected switch after adding network.");
          return c;
        }, {
          delay: 50,
          retryCount: 20
          // android device encryption is slower
        });
      }
      async function r(c) {
        await new Promise((f) => {
          const o = (p) => {
            "chainId" in p && p.chainId === c && (u.emitter.off("change", o), f());
          };
          u.emitter.on("change", o), u.emitter.emit("change", { chainId: c });
        });
      }
    },
    async onAccountsChanged(t) {
      if (t.length === 0)
        if (v.isExtensionActive())
          this.onDisconnect();
        else
          return;
      else if (u.emitter.listenerCount("connect")) {
        const n = (await this.getChainId()).toString();
        this.onConnect({ chainId: n });
      } else
        u.emitter.emit("change", {
          accounts: t.map((n) => k(n))
        });
    },
    onChainChanged(t) {
      const n = Number(t);
      u.emitter.emit("change", { chainId: n });
    },
    async onConnect(t) {
      const n = await this.getAccounts();
      if (n.length === 0)
        return;
      const e = Number(t.chainId);
      u.emitter.emit("connect", { accounts: n, chainId: e });
      const i = await this.getProvider();
      s && (i.removeListener("connect", s), s = void 0), y || (y = this.onAccountsChanged.bind(this), i.on("accountsChanged", y)), h || (h = this.onChainChanged.bind(this), i.on("chainChanged", h)), l || (l = this.onDisconnect.bind(this), i.on("disconnect", l));
    },
    async onDisconnect(t) {
      const n = await this.getProvider();
      t && t.code === 1013 && n && (await this.getAccounts()).length || (u.emitter.emit("disconnect"), h && (n.removeListener("chainChanged", h), h = void 0), l && (n.removeListener("disconnect", l), l = void 0), s || (s = this.onConnect.bind(this), n.on("connect", s)));
    },
    onDisplayUri(t) {
      u.emitter.emit("message", { type: "display_uri", data: t });
    }
  }));
}
export {
  x as metaMask
};
