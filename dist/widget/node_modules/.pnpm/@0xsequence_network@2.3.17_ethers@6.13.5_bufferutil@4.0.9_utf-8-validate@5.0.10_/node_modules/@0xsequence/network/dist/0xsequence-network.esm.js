import { networks as c, ChainId as r } from "../constants/dist/0xsequence-network-constants.esm.js";
import { NetworkType as m } from "../constants/dist/0xsequence-network-constants.esm.js";
import "../../../../../@0xsequence_utils@2.3.17_ethers@6.13.5_bufferutil@4.0.9_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js";
function f() {
  return f = Object.assign ? Object.assign.bind() : function(t) {
    for (var n = 1; n < arguments.length; n++) {
      var l = arguments[n];
      for (var o in l) ({}).hasOwnProperty.call(l, o) && (t[o] = l[o]);
    }
    return t;
  }, f.apply(null, arguments);
}
const A = (t, n = !1, l = !1) => {
  if (!t) throw new Error("invalid network config: empty config");
  const o = [];
  if (Array.isArray(t) ? o.push(...t) : o.push(t), o.length === 0) {
    if (n) throw new Error("invalid network config: empty config");
    return !1;
  }
  const i = o.map((a) => a.chainId).sort(), T = i.filter((a, s) => i.indexOf(a) !== s);
  if (T.length > 0) {
    if (n) throw new Error(`invalid network config: duplicate chainIds ${T}`);
    return !1;
  }
  o.forEach((a) => a.name = a.name.toLowerCase());
  const d = o.map((a) => a.name).sort(), h = d.filter((a, s) => d.indexOf(a) !== s);
  if (h.length > 0) {
    if (n) throw new Error(`invalid network config: duplicate network names ${h}`);
    return !1;
  }
  let E = !1;
  for (let a = 0; a < o.length; a++) {
    const s = o[a];
    if ((!s.rpcUrl || s.rpcUrl === "") && !s.provider) {
      if (n) throw new Error(`invalid network config for chainId ${s.chainId}: rpcUrl or provider must be provided`);
      return !1;
    }
    if (!l && !s.relayer) {
      if (n) throw new Error(`invalid network config for chainId ${s.chainId}: relayer must be provided`);
      return !1;
    }
    if (s.isDefaultChain) {
      if (E) {
        if (n) throw new Error(`invalid network config for chainId ${s.chainId}: DefaultChain is already set by another config`);
        return !1;
      }
      E = !0;
    }
  }
  if (!E) {
    if (n) throw new Error("invalid network config: DefaultChain must be set");
    return !1;
  }
  return !0;
}, p = (t, n = !1) => (A(t, !0, n), t), I = (t) => p(N(t)), N = (t) => {
  if (!t)
    return [];
  const n = t.sort((o, i) => o.chainId === i.chainId ? 0 : o.chainId < i.chainId ? -1 : 1), l = n.findIndex((o) => o.isDefaultChain);
  return l > 0 && n.splice(0, 0, n.splice(l, 1)[0]), n;
}, u = (t, n) => typeof t == "string" ? (n = n || {}, t.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(l, o) {
  let i = n[o];
  return typeof i == "function" ? i = i() : i == null ? i = "" : typeof i == "object" || typeof i == "symbol" ? i = i.toString() : i = i.valueOf(), i;
})) : "", O = (t) => u("https://${network}-indexer.sequence.app", {
  network: t
}), S = (t) => u("https://${network}-relayer.sequence.app", {
  network: t
}), w = (t) => u("https://nodes.sequence.app/${network}", {
  network: t
}), e = (t, n) => {
  const l = c[t];
  if (!l)
    throw new Error(`Network with chainId ${t} not found`);
  const o = w(l.name);
  return f({}, l, {
    rpcUrl: o,
    indexerUrl: O(l.name),
    relayer: {
      url: S(l.name),
      provider: {
        url: o
      }
    }
  }, n);
}, _ = [f({}, c[r.HARDHAT], {
  rpcUrl: "http://localhost:8545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:8545"
    }
  }
}), f({}, c[r.HARDHAT_2], {
  rpcUrl: "http://localhost:9545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:9545"
    }
  }
})];
I([f({}, e(r.POLYGON), {
  isDefaultChain: !0,
  isAuthChain: !0
}), e(r.MAINNET), e(r.BSC), e(r.AVALANCHE), e(r.ARBITRUM), e(r.ARBITRUM_NOVA), e(r.OPTIMISM), e(r.OPTIMISM_SEPOLIA), e(r.POLYGON_ZKEVM), e(r.GNOSIS), e(r.RINKEBY, {
  disabled: !0
}), e(r.GOERLI, {
  disabled: !0
}), e(r.SEPOLIA), e(r.POLYGON_MUMBAI, {
  disabled: !0
}), e(r.POLYGON_AMOY), e(r.BSC_TESTNET), e(r.ARBITRUM_SEPOLIA), e(r.BASE), e(r.BASE_SEPOLIA), e(r.HOMEVERSE), e(r.HOMEVERSE_TESTNET), e(r.XAI), e(r.XAI_SEPOLIA), e(r.AVALANCHE_TESTNET), e(r.B3), e(r.B3_SEPOLIA), e(r.APECHAIN), e(r.APECHAIN_TESTNET), e(r.BLAST), e(r.BLAST_SEPOLIA), e(r.TELOS), e(r.TELOS_TESTNET), e(r.BORNE_TESTNET), e(r.SKALE_NEBULA), e(r.SKALE_NEBULA_TESTNET), e(r.SONEIUM), e(r.SONEIUM_MINATO), e(r.TOY_TESTNET), e(r.IMMUTABLE_ZKEVM), e(r.IMMUTABLE_ZKEVM_TESTNET), e(r.ROOT_NETWORK), e(r.ROOT_NETWORK_PORCINI), e(r.LAOS), e(r.LAOS_SIGMA_TESTNET), e(r.MOONBEAM), e(r.MOONBASE_ALPHA), e(r.ETHERLINK), e(r.ETHERLINK_TESTNET), e(r.SOMNIA_TESTNET), e(r.MONAD_TESTNET), e(r.INCENTIV_TESTNET), ..._]);
export {
  r as ChainId,
  m as NetworkType,
  p as ensureValidNetworks,
  _ as hardhatNetworks,
  O as indexerURL,
  A as isValidNetworkConfig,
  c as networks,
  w as nodesURL,
  S as relayerURL,
  N as sortNetworks,
  u as stringTemplate,
  I as validateAndSortNetworks
};
