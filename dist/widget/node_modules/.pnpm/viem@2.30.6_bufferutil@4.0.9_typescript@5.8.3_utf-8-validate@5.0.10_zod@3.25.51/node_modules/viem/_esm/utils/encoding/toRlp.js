import { BaseError as l } from "../../errors/base.js";
import { createCursor as r } from "../cursor.js";
import { hexToBytes as g } from "./toBytes.js";
import { bytesToHex as u } from "./toHex.js";
function m(n, e = "hex") {
  const i = s(n), h = r(new Uint8Array(i.length));
  return i.encode(h), e === "hex" ? u(h.bytes) : h.bytes;
}
function s(n) {
  return Array.isArray(n) ? p(n.map((e) => s(e))) : y(n);
}
function p(n) {
  const e = n.reduce((t, f) => t + f.length, 0), i = o(e);
  return {
    length: e <= 55 ? 1 + e : 1 + i + e,
    encode(t) {
      e <= 55 ? t.pushByte(192 + e) : (t.pushByte(247 + i), i === 1 ? t.pushUint8(e) : i === 2 ? t.pushUint16(e) : i === 3 ? t.pushUint24(e) : t.pushUint32(e));
      for (const { encode: f } of n)
        f(t);
    }
  };
}
function y(n) {
  const e = typeof n == "string" ? g(n) : n, i = o(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + i + e.length,
    encode(t) {
      e.length === 1 && e[0] < 128 ? t.pushBytes(e) : e.length <= 55 ? (t.pushByte(128 + e.length), t.pushBytes(e)) : (t.pushByte(183 + i), i === 1 ? t.pushUint8(e.length) : i === 2 ? t.pushUint16(e.length) : i === 3 ? t.pushUint24(e.length) : t.pushUint32(e.length), t.pushBytes(e));
    }
  };
}
function o(n) {
  if (n < 2 ** 8)
    return 1;
  if (n < 2 ** 16)
    return 2;
  if (n < 2 ** 24)
    return 3;
  if (n < 2 ** 32)
    return 4;
  throw new l("Length is too large.");
}
export {
  m as toRlp
};
