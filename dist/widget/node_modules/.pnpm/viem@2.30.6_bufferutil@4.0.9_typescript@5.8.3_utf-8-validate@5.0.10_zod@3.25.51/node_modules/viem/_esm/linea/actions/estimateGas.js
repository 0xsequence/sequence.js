import { parseAccount as w } from "../../accounts/utils/parseAccount.js";
import { AccountNotFoundError as N } from "../../errors/account.js";
import { numberToHex as B } from "../../utils/encoding/toHex.js";
import { getCallError as H } from "../../utils/errors/getCallError.js";
import { extract as I } from "../../utils/formatters/extract.js";
import { formatTransactionRequest as L } from "../../utils/formatters/transactionRequest.js";
import { assertRequest as R } from "../../utils/transaction/assertRequest.js";
async function J(t, r) {
  var s, c, i;
  const { account: a = t.account } = r;
  if (!a)
    throw new N();
  const e = w(a);
  try {
    const { accessList: o, blockNumber: m, blockTag: p, data: b, gas: h, gasPrice: F, maxFeePerGas: G, maxPriorityFeePerGas: P, nonce: d, to: g, value: x, ...l } = r, n = (typeof m == "bigint" ? B(m) : void 0) || p;
    R(r);
    const f = (i = (c = (s = t.chain) == null ? void 0 : s.formatters) == null ? void 0 : c.transactionRequest) == null ? void 0 : i.format, u = (f || L)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...I(l, { format: f }),
      from: e == null ? void 0 : e.address,
      accessList: o,
      data: b,
      gas: h,
      gasPrice: F,
      maxFeePerGas: G,
      maxPriorityFeePerGas: P,
      nonce: d,
      to: g,
      value: x
    }), { baseFeePerGas: y, gasLimit: k, priorityFeePerGas: q } = await t.request({
      method: "linea_estimateGas",
      params: n ? [u, n] : [u]
    });
    return {
      baseFeePerGas: BigInt(y),
      gasLimit: BigInt(k),
      priorityFeePerGas: BigInt(q)
    };
  } catch (o) {
    throw H(o, {
      ...r,
      account: e,
      chain: t.chain
    });
  }
}
export {
  J as estimateGas
};
