import { NegativeOffsetError as o, PositionOutOfBoundsError as e, RecursiveReadLimitExceededError as n } from "../errors/cursor.js";
const h = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new n({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new e({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new o({ offset: t });
    const i = this.position - t;
    this.assertPosition(i), this.position = i;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new o({ offset: t });
    const i = this.position + t;
    this.assertPosition(i), this.position = i;
  },
  inspectByte(t) {
    const i = t ?? this.position;
    return this.assertPosition(i), this.bytes[i];
  },
  inspectBytes(t, i) {
    const s = i ?? this.position;
    return this.assertPosition(s + t - 1), this.bytes.subarray(s, s + t);
  },
  inspectUint8(t) {
    const i = t ?? this.position;
    return this.assertPosition(i), this.bytes[i];
  },
  inspectUint16(t) {
    const i = t ?? this.position;
    return this.assertPosition(i + 1), this.dataView.getUint16(i);
  },
  inspectUint24(t) {
    const i = t ?? this.position;
    return this.assertPosition(i + 2), (this.dataView.getUint16(i) << 8) + this.dataView.getUint8(i + 2);
  },
  inspectUint32(t) {
    const i = t ?? this.position;
    return this.assertPosition(i + 3), this.dataView.getUint32(i);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, i) {
    this.assertReadLimit(), this._touch();
    const s = this.inspectBytes(t);
    return this.position += i ?? t, s;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const i = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = i;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function a(t, { recursiveReadLimit: i = 8192 } = {}) {
  const s = Object.create(h);
  return s.bytes = t, s.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), s.positionReadCount = /* @__PURE__ */ new Map(), s.recursiveReadLimit = i, s;
}
export {
  a as createCursor
};
