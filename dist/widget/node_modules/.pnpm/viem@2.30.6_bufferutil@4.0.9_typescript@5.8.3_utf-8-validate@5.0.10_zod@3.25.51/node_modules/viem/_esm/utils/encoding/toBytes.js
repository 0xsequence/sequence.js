import { BaseError as g } from "../../errors/base.js";
import { isHex as x } from "../data/isHex.js";
import { pad as s } from "../data/pad.js";
import { assertSize as u } from "./fromHex.js";
import { numberToHex as h } from "./toHex.js";
const A = /* @__PURE__ */ new TextEncoder();
function F(e, n = {}) {
  return typeof e == "number" || typeof e == "bigint" ? T(e, n) : typeof e == "boolean" ? B(e, n) : x(e) ? y(e, n) : l(e, n);
}
function B(e, n = {}) {
  const r = new Uint8Array(1);
  return r[0] = Number(e), typeof n.size == "number" ? (u(r, { size: n.size }), s(r, { size: n.size })) : r;
}
const t = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function m(e) {
  if (e >= t.zero && e <= t.nine)
    return e - t.zero;
  if (e >= t.A && e <= t.F)
    return e - (t.A - 10);
  if (e >= t.a && e <= t.f)
    return e - (t.a - 10);
}
function y(e, n = {}) {
  let r = e;
  n.size && (u(r, { size: n.size }), r = s(r, { dir: "right", size: n.size }));
  let i = r.slice(2);
  i.length % 2 && (i = `0${i}`);
  const z = i.length / 2, d = new Uint8Array(z);
  for (let f = 0, o = 0; f < z; f++) {
    const b = m(i.charCodeAt(o++)), c = m(i.charCodeAt(o++));
    if (b === void 0 || c === void 0)
      throw new g(`Invalid byte sequence ("${i[o - 2]}${i[o - 1]}" in "${i}").`);
    d[f] = b * 16 + c;
  }
  return d;
}
function T(e, n) {
  const r = h(e, n);
  return y(r);
}
function l(e, n = {}) {
  const r = A.encode(e);
  return typeof n.size == "number" ? (u(r, { size: n.size }), s(r, { dir: "right", size: n.size })) : r;
}
export {
  B as boolToBytes,
  y as hexToBytes,
  T as numberToBytes,
  l as stringToBytes,
  F as toBytes
};
