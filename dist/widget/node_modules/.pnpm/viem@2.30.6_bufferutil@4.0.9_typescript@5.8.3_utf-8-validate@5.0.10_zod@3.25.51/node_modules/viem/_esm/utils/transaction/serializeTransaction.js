import { InvalidLegacyVError as H } from "../../errors/transaction.js";
import { serializeAuthorizationList as g } from "../authorization/serializeAuthorizationList.js";
import { blobsToCommitments as B } from "../blob/blobsToCommitments.js";
import { blobsToProofs as V } from "../blob/blobsToProofs.js";
import { commitmentsToVersionedHashes as C } from "../blob/commitmentsToVersionedHashes.js";
import { toBlobSidecars as k } from "../blob/toBlobSidecars.js";
import { concatHex as h } from "../data/concat.js";
import { trim as T } from "../data/trim.js";
import { toHex as o, bytesToHex as w } from "../encoding/toHex.js";
import { toRlp as y } from "../encoding/toRlp.js";
import { assertTransactionEIP1559 as S, assertTransactionEIP2930 as _, assertTransactionEIP4844 as R, assertTransactionEIP7702 as Y, assertTransactionLegacy as j } from "./assertTransaction.js";
import { getTransactionType as q } from "./getTransactionType.js";
import { serializeAccessList as v } from "./serializeAccessList.js";
function te(e, r) {
  const i = q(e);
  return i === "eip1559" ? K(e, r) : i === "eip2930" ? M(e, r) : i === "eip4844" ? J(e, r) : i === "eip7702" ? D(e, r) : N(e, r);
}
function D(e, r) {
  const { authorizationList: i, chainId: s, gas: n, nonce: c, to: f, value: a, maxFeePerGas: x, maxPriorityFeePerGas: t, accessList: p, data: l } = e;
  Y(e);
  const d = v(p), m = g(i);
  return h([
    "0x04",
    y([
      o(s),
      c ? o(c) : "0x",
      t ? o(t) : "0x",
      x ? o(x) : "0x",
      n ? o(n) : "0x",
      f ?? "0x",
      a ? o(a) : "0x",
      l ?? "0x",
      d,
      m,
      ...I(e, r)
    ])
  ]);
}
function J(e, r) {
  const { chainId: i, gas: s, nonce: n, to: c, value: f, maxFeePerBlobGas: a, maxFeePerGas: x, maxPriorityFeePerGas: t, accessList: p, data: l } = e;
  R(e);
  let d = e.blobVersionedHashes, m = e.sidecars;
  if (e.blobs && (typeof d > "u" || typeof m > "u")) {
    const u = typeof e.blobs[0] == "string" ? e.blobs : e.blobs.map((P) => w(P)), z = e.kzg, b = B({
      blobs: u,
      kzg: z
    });
    if (typeof d > "u" && (d = C({
      commitments: b
    })), typeof m > "u") {
      const P = V({ blobs: u, commitments: b, kzg: z });
      m = k({ blobs: u, commitments: b, proofs: P });
    }
  }
  const L = v(p), E = [
    o(i),
    n ? o(n) : "0x",
    t ? o(t) : "0x",
    x ? o(x) : "0x",
    s ? o(s) : "0x",
    c ?? "0x",
    f ? o(f) : "0x",
    l ?? "0x",
    L,
    a ? o(a) : "0x",
    d ?? [],
    ...I(e, r)
  ], A = [], F = [], G = [];
  if (m)
    for (let u = 0; u < m.length; u++) {
      const { blob: z, commitment: b, proof: P } = m[u];
      A.push(z), F.push(b), G.push(P);
    }
  return h([
    "0x03",
    m ? (
      // If sidecars are enabled, envelope turns into a "wrapper":
      y([E, A, F, G])
    ) : (
      // If sidecars are disabled, standard envelope is used:
      y(E)
    )
  ]);
}
function K(e, r) {
  const { chainId: i, gas: s, nonce: n, to: c, value: f, maxFeePerGas: a, maxPriorityFeePerGas: x, accessList: t, data: p } = e;
  S(e);
  const l = v(t), d = [
    o(i),
    n ? o(n) : "0x",
    x ? o(x) : "0x",
    a ? o(a) : "0x",
    s ? o(s) : "0x",
    c ?? "0x",
    f ? o(f) : "0x",
    p ?? "0x",
    l,
    ...I(e, r)
  ];
  return h([
    "0x02",
    y(d)
  ]);
}
function M(e, r) {
  const { chainId: i, gas: s, data: n, nonce: c, to: f, value: a, accessList: x, gasPrice: t } = e;
  _(e);
  const p = v(x), l = [
    o(i),
    c ? o(c) : "0x",
    t ? o(t) : "0x",
    s ? o(s) : "0x",
    f ?? "0x",
    a ? o(a) : "0x",
    n ?? "0x",
    p,
    ...I(e, r)
  ];
  return h([
    "0x01",
    y(l)
  ]);
}
function N(e, r) {
  const { chainId: i = 0, gas: s, data: n, nonce: c, to: f, value: a, gasPrice: x } = e;
  j(e);
  let t = [
    c ? o(c) : "0x",
    x ? o(x) : "0x",
    s ? o(s) : "0x",
    f ?? "0x",
    a ? o(a) : "0x",
    n ?? "0x"
  ];
  if (r) {
    const p = (() => {
      if (r.v >= 35n)
        return (r.v - 35n) / 2n > 0 ? r.v : 27n + (r.v === 35n ? 0n : 1n);
      if (i > 0)
        return BigInt(i * 2) + BigInt(35n + r.v - 27n);
      const m = 27n + (r.v === 27n ? 0n : 1n);
      if (r.v !== m)
        throw new H({ v: r.v });
      return m;
    })(), l = T(r.r), d = T(r.s);
    t = [
      ...t,
      o(p),
      l === "0x00" ? "0x" : l,
      d === "0x00" ? "0x" : d
    ];
  } else i > 0 && (t = [
    ...t,
    o(i),
    "0x",
    "0x"
  ]);
  return y(t);
}
function I(e, r) {
  const i = r ?? e, { v: s, yParity: n } = i;
  if (typeof i.r > "u")
    return [];
  if (typeof i.s > "u")
    return [];
  if (typeof s > "u" && typeof n > "u")
    return [];
  const c = T(i.r), f = T(i.s);
  return [typeof n == "number" ? n ? o(1) : "0x" : s === 0n ? "0x" : s === 1n ? o(1) : s === 27n ? "0x" : o(1), c === "0x00" ? "0x" : c, f === "0x00" ? "0x" : f];
}
export {
  te as serializeTransaction,
  I as toYParitySignatureArray
};
