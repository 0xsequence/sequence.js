import { maxBytesPerTransaction as y, bytesPerBlob as a, fieldElementsPerBlob as f, bytesPerFieldElement as p } from "../../constants/blob.js";
import { EmptyBlobError as c, BlobSizeTooLargeError as h } from "../../errors/blob.js";
import { createCursor as B } from "../cursor.js";
import { size as u } from "../data/size.js";
import { hexToBytes as x } from "../encoding/toBytes.js";
import { bytesToHex as d } from "../encoding/toHex.js";
function S(e) {
  const m = e.to ?? (typeof e.data == "string" ? "hex" : "bytes"), i = typeof e.data == "string" ? x(e.data) : e.data, o = u(i);
  if (!o)
    throw new c();
  if (o > y)
    throw new h({
      maxSize: y,
      size: o
    });
  const s = [];
  let n = !0, r = 0;
  for (; n; ) {
    const t = B(new Uint8Array(a));
    let l = 0;
    for (; l < f; ) {
      const b = i.slice(r, r + (p - 1));
      if (t.pushByte(0), t.pushBytes(b), b.length < 31) {
        t.pushByte(128), n = !1;
        break;
      }
      l++, r += 31;
    }
    s.push(t);
  }
  return m === "bytes" ? s.map((t) => t.bytes) : s.map((t) => d(t.bytes));
}
export {
  S as toBlobs
};
