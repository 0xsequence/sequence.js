import { BaseError as c } from "../../errors/base.js";
import { ExecutionRevertedError as t, FeeCapTooHighError as u, FeeCapTooLowError as d, NonceTooHighError as a, NonceTooLowError as f, NonceMaxValueError as w, InsufficientFundsError as r, IntrinsicGasTooHighError as E, IntrinsicGasTooLowError as m, TransactionTypeNotSupportedError as x, TipAboveFeeCapError as F, UnknownNodeError as M } from "../../errors/node.js";
function P(o, e) {
  const n = (o.details || "").toLowerCase(), s = o instanceof c ? o.walk((i) => (i == null ? void 0 : i.code) === t.code) : o;
  return s instanceof c ? new t({
    cause: o,
    message: s.details
  }) : t.nodeMessage.test(n) ? new t({
    cause: o,
    message: o.details
  }) : u.nodeMessage.test(n) ? new u({
    cause: o,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : d.nodeMessage.test(n) ? new d({
    cause: o,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : a.nodeMessage.test(n) ? new a({ cause: o, nonce: e == null ? void 0 : e.nonce }) : f.nodeMessage.test(n) ? new f({ cause: o, nonce: e == null ? void 0 : e.nonce }) : w.nodeMessage.test(n) ? new w({ cause: o, nonce: e == null ? void 0 : e.nonce }) : r.nodeMessage.test(n) ? new r({ cause: o }) : E.nodeMessage.test(n) ? new E({ cause: o, gas: e == null ? void 0 : e.gas }) : m.nodeMessage.test(n) ? new m({ cause: o, gas: e == null ? void 0 : e.gas }) : x.nodeMessage.test(n) ? new x({ cause: o }) : F.nodeMessage.test(n) ? new F({
    cause: o,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new M({
    cause: o
  });
}
export {
  P as getNodeError
};
