import { IntegerOutOfRangeError as x } from "../../errors/encoding.js";
import { pad as s } from "../data/pad.js";
import { assertSize as c } from "./fromHex.js";
const b = /* @__PURE__ */ Array.from({ length: 256 }, (n, e) => e.toString(16).padStart(2, "0"));
function B(n, e = {}) {
  return typeof n == "number" || typeof n == "bigint" ? y(n, e) : typeof n == "string" ? $(n, e) : typeof n == "boolean" ? z(n, e) : m(n, e);
}
function z(n, e = {}) {
  const t = `0x${Number(n)}`;
  return typeof e.size == "number" ? (c(t, { size: e.size }), s(t, { size: e.size })) : t;
}
function m(n, e = {}) {
  let t = "";
  for (let i = 0; i < n.length; i++)
    t += b[n[i]];
  const r = `0x${t}`;
  return typeof e.size == "number" ? (c(r, { size: e.size }), s(r, { dir: "right", size: e.size })) : r;
}
function y(n, e = {}) {
  const { signed: t, size: r } = e, i = BigInt(n);
  let o;
  r ? t ? o = (1n << BigInt(r) * 8n - 1n) - 1n : o = 2n ** (BigInt(r) * 8n) - 1n : typeof n == "number" && (o = BigInt(Number.MAX_SAFE_INTEGER));
  const g = typeof o == "bigint" && t ? -o - 1n : 0;
  if (o && i > o || i < g) {
    const f = typeof n == "bigint" ? "n" : "";
    throw new x({
      max: o ? `${o}${f}` : void 0,
      min: `${g}${f}`,
      signed: t,
      size: r,
      value: `${n}${f}`
    });
  }
  const u = `0x${(t && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(16)}`;
  return r ? s(u, { size: r }) : u;
}
const d = /* @__PURE__ */ new TextEncoder();
function $(n, e = {}) {
  const t = d.encode(n);
  return m(t, e);
}
export {
  z as boolToHex,
  m as bytesToHex,
  y as numberToHex,
  $ as stringToHex,
  B as toHex
};
