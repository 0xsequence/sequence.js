import { parseAccount as w } from "../accounts/utils/parseAccount.js";
import { formatEther as $ } from "../utils/unit/formatEther.js";
import { formatGwei as o } from "../utils/unit/formatGwei.js";
import { BaseError as b } from "./base.js";
import { prettyStateOverride as x } from "./stateOverride.js";
import { prettyPrint as C } from "./transaction.js";
class G extends b {
  constructor(e, { account: s, docsPath: l, chain: r, data: u, gas: g, gasPrice: i, maxFeePerGas: f, maxPriorityFeePerGas: m, nonce: y, to: E, value: n, stateOverride: a }) {
    var d;
    const t = s ? w(s) : void 0;
    let p = C({
      from: t == null ? void 0 : t.address,
      to: E,
      value: typeof n < "u" && `${$(n)} ${((d = r == null ? void 0 : r.nativeCurrency) == null ? void 0 : d.symbol) || "ETH"}`,
      data: u,
      gas: g,
      gasPrice: typeof i < "u" && `${o(i)} gwei`,
      maxFeePerGas: typeof f < "u" && `${o(f)} gwei`,
      maxPriorityFeePerGas: typeof m < "u" && `${o(m)} gwei`,
      nonce: y
    });
    a && (p += `
${x(a)}`), super(e.shortMessage, {
      cause: e,
      docsPath: l,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Raw Call Arguments:",
        p
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
export {
  G as CallExecutionError
};
