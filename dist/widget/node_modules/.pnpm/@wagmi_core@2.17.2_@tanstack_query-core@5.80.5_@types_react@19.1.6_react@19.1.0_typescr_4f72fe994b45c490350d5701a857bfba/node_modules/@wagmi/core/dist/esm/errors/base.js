import { getVersion as n } from "../utils/getVersion.js";
var l = function(t, a, e, r) {
  if (e === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
  if (typeof a == "function" ? t !== a || !r : !a.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? r : e === "a" ? r.call(t) : r ? r.value : a.get(t);
}, s, d;
class i extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return n();
  }
  constructor(a, e = {}) {
    var c;
    super(), s.add(this), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiCoreError"
    });
    const r = e.cause instanceof i ? e.cause.details : (c = e.cause) != null && c.message ? e.cause.message : e.details, u = e.cause instanceof i && e.cause.docsPath || e.docsPath;
    this.message = [
      a || "An error occurred.",
      "",
      ...e.metaMessages ? [...e.metaMessages, ""] : [],
      ...u ? [
        `Docs: ${this.docsBaseUrl}${u}.html${e.docsSlug ? `#${e.docsSlug}` : ""}`
      ] : [],
      ...r ? [`Details: ${r}`] : [],
      `Version: ${this.version}`
    ].join(`
`), e.cause && (this.cause = e.cause), this.details = r, this.docsPath = u, this.metaMessages = e.metaMessages, this.shortMessage = a;
  }
  walk(a) {
    return l(this, s, "m", d).call(this, this, a);
  }
}
s = /* @__PURE__ */ new WeakSet(), d = function t(a, e) {
  return e != null && e(a) ? a : a.cause ? l(this, s, "m", t).call(this, a.cause, e) : a;
};
export {
  i as BaseError
};
