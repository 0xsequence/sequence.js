import { getAddress as k, SwitchChainError as q, numberToHex as L, UserRejectedRequestError as m, withRetry as D, withTimeout as N, ResourceUnavailableRpcError as _ } from "viem";
import { ChainNotConfiguredError as O } from "../errors/config.js";
import { ProviderNotFoundError as A } from "../errors/connector.js";
import { createConnector as T } from "./createConnector.js";
M.type = "injected";
function M(r = {}) {
  const { shimDisconnect: a = !0, unstable_shimAsyncInject: u } = r;
  function h() {
    const n = r.target;
    if (typeof n == "function") {
      const e = n();
      if (e)
        return e;
    }
    return typeof n == "object" ? n : typeof n == "string" ? {
      ...R[n] ?? {
        id: n,
        name: `${n[0].toUpperCase()}${n.slice(1)}`,
        provider: `is${n[0].toUpperCase()}${n.slice(1)}`
      }
    } : {
      id: "injected",
      name: "Injected",
      provider(e) {
        return e == null ? void 0 : e.ethereum;
      }
    };
  }
  let f, l, d, p;
  return T((n) => ({
    get icon() {
      return h().icon;
    },
    get id() {
      return h().id;
    },
    get name() {
      return h().name;
    },
    /** @deprecated */
    get supportsSimulation() {
      return !0;
    },
    type: M.type,
    async setup() {
      const e = await this.getProvider();
      e != null && e.on && r.target && (d || (d = this.onConnect.bind(this), e.on("connect", d)), f || (f = this.onAccountsChanged.bind(this), e.on("accountsChanged", f)));
    },
    async connect({ chainId: e, isReconnecting: t } = {}) {
      var b, g, y, C, w, v;
      const s = await this.getProvider();
      if (!s)
        throw new A();
      let o = [];
      if (t)
        o = await this.getAccounts().catch(() => []);
      else if (a)
        try {
          o = (C = (y = (g = (b = (await s.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          }))[0]) == null ? void 0 : b.caveats) == null ? void 0 : g[0]) == null ? void 0 : y.value) == null ? void 0 : C.map((i) => k(i)), o.length > 0 && (o = await this.getAccounts());
        } catch (c) {
          const i = c;
          if (i.code === m.code)
            throw new m(i);
          if (i.code === _.code)
            throw i;
        }
      try {
        !(o != null && o.length) && !t && (o = (await s.request({
          method: "eth_requestAccounts"
        })).map((I) => k(I))), d && (s.removeListener("connect", d), d = void 0), f || (f = this.onAccountsChanged.bind(this), s.on("accountsChanged", f)), l || (l = this.onChainChanged.bind(this), s.on("chainChanged", l)), p || (p = this.onDisconnect.bind(this), s.on("disconnect", p));
        let c = await this.getChainId();
        if (e && c !== e) {
          const i = await this.switchChain({ chainId: e }).catch((I) => {
            if (I.code === m.code)
              throw I;
            return { id: c };
          });
          c = (i == null ? void 0 : i.id) ?? c;
        }
        return a && await ((w = n.storage) == null ? void 0 : w.removeItem(`${this.id}.disconnected`)), r.target || await ((v = n.storage) == null ? void 0 : v.setItem("injected.connected", !0)), { accounts: o, chainId: c };
      } catch (c) {
        const i = c;
        throw i.code === m.code ? new m(i) : i.code === _.code ? new _(i) : i;
      }
    },
    async disconnect() {
      var t, s;
      const e = await this.getProvider();
      if (!e)
        throw new A();
      l && (e.removeListener("chainChanged", l), l = void 0), p && (e.removeListener("disconnect", p), p = void 0), d || (d = this.onConnect.bind(this), e.on("connect", d));
      try {
        await N(() => (
          // TODO: Remove explicit type for viem@3
          e.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      a && await ((t = n.storage) == null ? void 0 : t.setItem(`${this.id}.disconnected`, !0)), r.target || await ((s = n.storage) == null ? void 0 : s.removeItem("injected.connected"));
    },
    async getAccounts() {
      const e = await this.getProvider();
      if (!e)
        throw new A();
      return (await e.request({ method: "eth_accounts" })).map((s) => k(s));
    },
    async getChainId() {
      const e = await this.getProvider();
      if (!e)
        throw new A();
      const t = await e.request({ method: "eth_chainId" });
      return Number(t);
    },
    async getProvider() {
      if (typeof window > "u")
        return;
      let e;
      const t = h();
      return typeof t.provider == "function" ? e = t.provider(window) : typeof t.provider == "string" ? e = W(window, t.provider) : e = t.provider, e && !e.removeListener && ("off" in e && typeof e.off == "function" ? e.removeListener = e.off : e.removeListener = () => {
      }), e;
    },
    async isAuthorized() {
      var e, t;
      try {
        if (a && // If shim exists in storage, connector is disconnected
        await ((e = n.storage) == null ? void 0 : e.getItem(`${this.id}.disconnected`)) || !r.target && !await ((t = n.storage) == null ? void 0 : t.getItem("injected.connected")))
          return !1;
        if (!await this.getProvider()) {
          if (u !== void 0 && u !== !1) {
            const g = async () => (typeof window < "u" && window.removeEventListener("ethereum#initialized", g), !!await this.getProvider()), y = typeof u == "number" ? u : 1e3;
            if (await Promise.race([
              ...typeof window < "u" ? [
                new Promise((w) => window.addEventListener("ethereum#initialized", () => w(g()), { once: !0 }))
              ] : [],
              new Promise((w) => setTimeout(() => w(g()), y))
            ]))
              return !0;
          }
          throw new A();
        }
        return !!(await D(() => this.getAccounts())).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: e, chainId: t }) {
      var g, y, C, w;
      const s = await this.getProvider();
      if (!s)
        throw new A();
      const o = n.chains.find((v) => v.id === t);
      if (!o)
        throw new q(new O());
      const b = new Promise((v) => {
        const c = (i) => {
          "chainId" in i && i.chainId === t && (n.emitter.off("change", c), v());
        };
        n.emitter.on("change", c);
      });
      try {
        return await Promise.all([
          s.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: L(t) }]
          }).then(async () => {
            await this.getChainId() === t && n.emitter.emit("change", { chainId: t });
          }),
          b
        ]), o;
      } catch (v) {
        const c = v;
        if (c.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((y = (g = c == null ? void 0 : c.data) == null ? void 0 : g.originalError) == null ? void 0 : y.code) === 4902)
          try {
            const { default: i, ...I } = o.blockExplorers ?? {};
            let U;
            e != null && e.blockExplorerUrls ? U = e.blockExplorerUrls : i && (U = [
              i.url,
              ...Object.values(I).map((j) => j.url)
            ]);
            let x;
            (C = e == null ? void 0 : e.rpcUrls) != null && C.length ? x = e.rpcUrls : x = [((w = o.rpcUrls.default) == null ? void 0 : w.http[0]) ?? ""];
            const $ = {
              blockExplorerUrls: U,
              chainId: L(t),
              chainName: (e == null ? void 0 : e.chainName) ?? o.name,
              iconUrls: e == null ? void 0 : e.iconUrls,
              nativeCurrency: (e == null ? void 0 : e.nativeCurrency) ?? o.nativeCurrency,
              rpcUrls: x
            };
            return await Promise.all([
              s.request({
                method: "wallet_addEthereumChain",
                params: [$]
              }).then(async () => {
                if (await this.getChainId() === t)
                  n.emitter.emit("change", { chainId: t });
                else
                  throw new m(new Error("User rejected switch after adding network."));
              }),
              b
            ]), o;
          } catch (i) {
            throw new m(i);
          }
        throw c.code === m.code ? new m(c) : new q(c);
      }
    },
    async onAccountsChanged(e) {
      var t;
      if (e.length === 0)
        this.onDisconnect();
      else if (n.emitter.listenerCount("connect")) {
        const s = (await this.getChainId()).toString();
        this.onConnect({ chainId: s }), a && await ((t = n.storage) == null ? void 0 : t.removeItem(`${this.id}.disconnected`));
      } else
        n.emitter.emit("change", {
          accounts: e.map((s) => k(s))
        });
    },
    onChainChanged(e) {
      const t = Number(e);
      n.emitter.emit("change", { chainId: t });
    },
    async onConnect(e) {
      const t = await this.getAccounts();
      if (t.length === 0)
        return;
      const s = Number(e.chainId);
      n.emitter.emit("connect", { accounts: t, chainId: s });
      const o = await this.getProvider();
      o && (d && (o.removeListener("connect", d), d = void 0), f || (f = this.onAccountsChanged.bind(this), o.on("accountsChanged", f)), l || (l = this.onChainChanged.bind(this), o.on("chainChanged", l)), p || (p = this.onDisconnect.bind(this), o.on("disconnect", p)));
    },
    async onDisconnect(e) {
      const t = await this.getProvider();
      e && e.code === 1013 && t && (await this.getAccounts()).length || (n.emitter.emit("disconnect"), t && (l && (t.removeListener("chainChanged", l), l = void 0), p && (t.removeListener("disconnect", p), p = void 0), d || (d = this.onConnect.bind(this), t.on("connect", d))));
    }
  }));
}
const R = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(r) {
      return r != null && r.coinbaseWalletExtension ? r.coinbaseWalletExtension : W(r, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(r) {
      return W(r, (a) => {
        if (!a.isMetaMask || a.isBraveWallet && !a._events && !a._state)
          return !1;
        const u = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPhantom",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const h of u)
          if (a[h])
            return !1;
        return !0;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(r) {
      var a, u;
      return (a = r == null ? void 0 : r.phantom) != null && a.ethereum ? (u = r.phantom) == null ? void 0 : u.ethereum : W(r, "isPhantom");
    }
  }
};
function W(r, a) {
  function u(f) {
    return typeof a == "function" ? a(f) : typeof a == "string" ? f[a] : !0;
  }
  const h = r.ethereum;
  if (h != null && h.providers)
    return h.providers.find((f) => u(f));
  if (h && u(h))
    return h;
}
export {
  M as injected
};
