import { execTyped as E, bytesRegex as x, integerRegex as $, isTupleRegex as P } from "../../regex.js";
import { UnknownSolidityTypeError as M } from "../errors/abiItem.js";
import { InvalidParameterError as R, SolidityProtectedKeywordError as k, InvalidModifierError as z, InvalidFunctionModifierError as A } from "../errors/abiParameter.js";
import { UnknownSignatureError as F, InvalidSignatureError as m } from "../errors/signature.js";
import { InvalidParenthesisError as T } from "../errors/splitParameters.js";
import { getParameterCacheKey as _, parameterCache as p } from "./cache.js";
import { isFunctionSignature as C, isEventSignature as I, isErrorSignature as Z, isConstructorSignature as K, isFallbackSignature as L, isReceiveSignature as U, execFunctionSignature as W, execEventSignature as D, execErrorSignature as V, execConstructorSignature as j, execFallbackSignature as q, functionModifiers as h, eventModifiers as B } from "./signatures.js";
function le(e, t = {}) {
  if (C(e))
    return G(e, t);
  if (I(e))
    return H(e, t);
  if (Z(e))
    return J(e, t);
  if (K(e))
    return N(e, t);
  if (L(e))
    return O(e);
  if (U(e))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new F({ signature: e });
}
function G(e, t = {}) {
  const n = W(e);
  if (!n)
    throw new m({ signature: e, type: "function" });
  const a = s(n.parameters), r = [], c = a.length;
  for (let o = 0; o < c; o++)
    r.push(l(a[o], {
      modifiers: h,
      structs: t,
      type: "function"
    }));
  const i = [];
  if (n.returns) {
    const o = s(n.returns), u = o.length;
    for (let f = 0; f < u; f++)
      i.push(l(o[f], {
        modifiers: h,
        structs: t,
        type: "function"
      }));
  }
  return {
    name: n.name,
    type: "function",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: r,
    outputs: i
  };
}
function H(e, t = {}) {
  const n = D(e);
  if (!n)
    throw new m({ signature: e, type: "event" });
  const a = s(n.parameters), r = [], c = a.length;
  for (let i = 0; i < c; i++)
    r.push(l(a[i], {
      modifiers: B,
      structs: t,
      type: "event"
    }));
  return { name: n.name, type: "event", inputs: r };
}
function J(e, t = {}) {
  const n = V(e);
  if (!n)
    throw new m({ signature: e, type: "error" });
  const a = s(n.parameters), r = [], c = a.length;
  for (let i = 0; i < c; i++)
    r.push(l(a[i], { structs: t, type: "error" }));
  return { name: n.name, type: "error", inputs: r };
}
function N(e, t = {}) {
  const n = j(e);
  if (!n)
    throw new m({ signature: e, type: "constructor" });
  const a = s(n.parameters), r = [], c = a.length;
  for (let i = 0; i < c; i++)
    r.push(l(a[i], { structs: t, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: r
  };
}
function O(e) {
  const t = q(e);
  if (!t)
    throw new m({ signature: e, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: t.stateMutability ?? "nonpayable"
  };
}
const Q = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, X = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, Y = /^u?int$/;
function l(e, t) {
  var y, b;
  const n = _(e, t == null ? void 0 : t.type, t == null ? void 0 : t.structs);
  if (p.has(n))
    return p.get(n);
  const a = P.test(e), r = E(a ? X : Q, e);
  if (!r)
    throw new R({ param: e });
  if (r.name && re(r.name))
    throw new k({ param: e, name: r.name });
  const c = r.name ? { name: r.name } : {}, i = r.modifier === "indexed" ? { indexed: !0 } : {}, o = (t == null ? void 0 : t.structs) ?? {};
  let u, f = {};
  if (a) {
    u = "tuple";
    const w = s(r.type), S = [], v = w.length;
    for (let d = 0; d < v; d++)
      S.push(l(w[d], { structs: o }));
    f = { components: S };
  } else if (r.type in o)
    u = "tuple", f = { components: o[r.type] };
  else if (Y.test(r.type))
    u = `${r.type}256`;
  else if (u = r.type, (t == null ? void 0 : t.type) !== "struct" && !ee(u))
    throw new M({ type: u });
  if (r.modifier) {
    if (!((b = (y = t == null ? void 0 : t.modifiers) == null ? void 0 : y.has) != null && b.call(y, r.modifier)))
      throw new z({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: r.modifier
      });
    if (h.has(r.modifier) && !ne(u, !!r.array))
      throw new A({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: r.modifier
      });
  }
  const g = {
    type: `${u}${r.array ?? ""}`,
    ...c,
    ...i,
    ...f
  };
  return p.set(n, g), g;
}
function s(e, t = [], n = "", a = 0) {
  const r = e.trim().length;
  for (let c = 0; c < r; c++) {
    const i = e[c], o = e.slice(c + 1);
    switch (i) {
      case ",":
        return a === 0 ? s(o, [...t, n.trim()]) : s(o, t, `${n}${i}`, a);
      case "(":
        return s(o, t, `${n}${i}`, a + 1);
      case ")":
        return s(o, t, `${n}${i}`, a - 1);
      default:
        return s(o, t, `${n}${i}`, a);
    }
  }
  if (n === "")
    return t;
  if (a !== 0)
    throw new T({ current: n, depth: a });
  return t.push(n.trim()), t;
}
function ee(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || x.test(e) || $.test(e);
}
const te = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function re(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || e === "tuple" || x.test(e) || $.test(e) || te.test(e);
}
function ne(e, t) {
  return t || e === "bytes" || e === "string" || e === "tuple";
}
export {
  re as isSolidityKeyword,
  ee as isSolidityType,
  ne as isValidDataLocation,
  l as parseAbiParameter,
  N as parseConstructorSignature,
  J as parseErrorSignature,
  H as parseEventSignature,
  O as parseFallbackSignature,
  G as parseFunctionSignature,
  le as parseSignature,
  s as splitParameters
};
