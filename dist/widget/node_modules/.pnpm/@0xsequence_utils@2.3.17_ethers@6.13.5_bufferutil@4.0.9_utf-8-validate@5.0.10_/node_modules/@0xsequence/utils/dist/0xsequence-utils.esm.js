BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function t() {
  return t = Object.assign ? Object.assign.bind() : function(i) {
    for (var f = 1; f < arguments.length; f++) {
      var e = arguments[f];
      for (var r in e) ({}).hasOwnProperty.call(e, r) && (i[r] = e[r]);
    }
    return i;
  }, t.apply(null, arguments);
}
var n = /* @__PURE__ */ function(i) {
  return i[i.DEBUG = 1] = "DEBUG", i[i.INFO = 2] = "INFO", i[i.WARN = 3] = "WARN", i[i.ERROR = 4] = "ERROR", i[i.DISABLED = 5] = "DISABLED", i;
}(n || {});
class s {
  constructor(f) {
    this.config = f, this.logLevel = void 0, this.configure(f);
  }
  configure(f) {
    switch (this.config = t({}, this.config, f), this.config.logLevel) {
      case "DEBUG":
        this.logLevel = n.DEBUG;
        break;
      case "INFO":
        this.logLevel = n.INFO;
        break;
      case "WARN":
        this.logLevel = n.WARN;
        break;
      case "ERROR":
        this.logLevel = n.ERROR;
        break;
      case "DISABLED":
        this.logLevel = n.DISABLED;
        break;
      default:
        this.logLevel = n.INFO;
        break;
    }
    this.config.silence === void 0 && (this.config.silence = !1);
  }
  debug(f, ...e) {
    this.config.silence !== !0 && this.logLevel === n.DEBUG && console.log(f, ...e);
  }
  info(f, ...e) {
    this.config.silence !== !0 && this.logLevel <= n.INFO && console.log(f, ...e);
  }
  warn(f, ...e) {
    this.config.silence !== !0 && this.logLevel <= n.WARN && (console.warn(f, ...e), this.config.onwarn && this.config.onwarn(f, e));
  }
  error(f, ...e) {
    this.config.silence !== !0 && this.logLevel <= n.ERROR && (console.error(f, ...e), this.config.onerror && this.config.onerror(f, e));
  }
}
new s({
  logLevel: "INFO",
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: !0
});
export {
  s as Logger
};
