import { rotlSH as L, rotlSL as T, rotlBH as S, rotlBL as m, split as F } from "./_u64.js";
import { createHasher as X, Hash as E, anumber as d, u32 as U, swap32IfBE as I, aexists as x, toBytes as P, abytes as k, aoutput as M, clean as y } from "./utils.js";
const R = BigInt(0), f = BigInt(1), j = BigInt(2), q = BigInt(7), v = BigInt(256), z = BigInt(113), _ = [], g = [], B = [];
for (let n = 0, t = f, s = 1, i = 0; n < 24; n++) {
  [s, i] = [i, (2 * s + 3 * i) % 5], _.push(2 * (5 * i + s)), g.push((n + 1) * (n + 2) / 2 % 64);
  let o = R;
  for (let r = 0; r < 7; r++)
    t = (t << f ^ (t >> q) * z) % v, t & j && (o ^= f << (f << /* @__PURE__ */ BigInt(r)) - f);
  B.push(o);
}
const A = F(B, !0), C = A[0], D = A[1], O = (n, t, s) => s > 32 ? S(n, t, s) : L(n, t, s), w = (n, t, s) => s > 32 ? m(n, t, s) : T(n, t, s);
function G(n, t = 24) {
  const s = new Uint32Array(10);
  for (let i = 24 - t; i < 24; i++) {
    for (let e = 0; e < 10; e++)
      s[e] = n[e] ^ n[e + 10] ^ n[e + 20] ^ n[e + 30] ^ n[e + 40];
    for (let e = 0; e < 10; e += 2) {
      const h = (e + 8) % 10, l = (e + 2) % 10, u = s[l], c = s[l + 1], b = O(u, c, 1) ^ s[h], H = w(u, c, 1) ^ s[h + 1];
      for (let a = 0; a < 50; a += 10)
        n[e + a] ^= b, n[e + a + 1] ^= H;
    }
    let o = n[2], r = n[3];
    for (let e = 0; e < 24; e++) {
      const h = g[e], l = O(o, r, h), u = w(o, r, h), c = _[e];
      o = n[c], r = n[c + 1], n[c] = l, n[c + 1] = u;
    }
    for (let e = 0; e < 50; e += 10) {
      for (let h = 0; h < 10; h++)
        s[h] = n[e + h];
      for (let h = 0; h < 10; h++)
        n[e + h] ^= ~s[(h + 2) % 10] & s[(h + 4) % 10];
    }
    n[0] ^= C[i], n[1] ^= D[i];
  }
  y(s);
}
class p extends E {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, s, i, o = !1, r = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = t, this.suffix = s, this.outputLen = i, this.enableXOF = o, this.rounds = r, d(i), !(0 < t && t < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = U(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    I(this.state32), G(this.state32, this.rounds), I(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    x(this), t = P(t), k(t);
    const { blockLen: s, state: i } = this, o = t.length;
    for (let r = 0; r < o; ) {
      const e = Math.min(s - this.pos, o - r);
      for (let h = 0; h < e; h++)
        i[this.pos++] ^= t[r++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: s, pos: i, blockLen: o } = this;
    t[i] ^= s, s & 128 && i === o - 1 && this.keccak(), t[o - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    x(this, !1), k(t), this.finish();
    const s = this.state, { blockLen: i } = this;
    for (let o = 0, r = t.length; o < r; ) {
      this.posOut >= i && this.keccak();
      const e = Math.min(i - this.posOut, r - o);
      t.set(s.subarray(this.posOut, this.posOut + e), o), this.posOut += e, o += e;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return d(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (M(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, y(this.state);
  }
  _cloneInto(t) {
    const { blockLen: s, suffix: i, outputLen: o, rounds: r, enableXOF: e } = this;
    return t || (t = new p(s, i, o, e, r)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = r, t.suffix = i, t.outputLen = o, t.enableXOF = e, t.destroyed = this.destroyed, t;
  }
}
const J = (n, t, s) => X(() => new p(t, n, s)), Q = J(1, 136, 256 / 8);
export {
  p as Keccak,
  G as keccakP,
  Q as keccak_256
};
