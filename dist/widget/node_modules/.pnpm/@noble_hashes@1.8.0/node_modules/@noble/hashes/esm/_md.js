import { Hash as g, createView as l, aexists as b, toBytes as a, abytes as d, aoutput as x, clean as w } from "./utils.js";
function y(o, t, s, n) {
  if (typeof o.setBigUint64 == "function")
    return o.setBigUint64(t, s, n);
  const i = BigInt(32), h = BigInt(4294967295), e = Number(s >> i & h), r = Number(s & h), c = n ? 4 : 0, u = n ? 0 : 4;
  o.setUint32(t + c, e, n), o.setUint32(t + u, r, n);
}
function U(o, t, s) {
  return o & t ^ ~o & s;
}
function _(o, t, s) {
  return o & t ^ o & s ^ t & s;
}
class m extends g {
  constructor(t, s, n, i) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = s, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = l(this.buffer);
  }
  update(t) {
    b(this), t = a(t), d(t);
    const { view: s, buffer: n, blockLen: i } = this, h = t.length;
    for (let e = 0; e < h; ) {
      const r = Math.min(i - this.pos, h - e);
      if (r === i) {
        const c = l(t);
        for (; i <= h - e; e += i)
          this.process(c, e);
        continue;
      }
      n.set(t.subarray(e, e + r), this.pos), this.pos += r, e += r, this.pos === i && (this.process(s, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    b(this), x(t, this), this.finished = !0;
    const { buffer: s, view: n, blockLen: i, isLE: h } = this;
    let { pos: e } = this;
    s[e++] = 128, w(this.buffer.subarray(e)), this.padOffset > i - e && (this.process(n, 0), e = 0);
    for (let f = e; f < i; f++)
      s[f] = 0;
    y(n, i - 8, BigInt(this.length * 8), h), this.process(n, 0);
    const r = l(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, p = this.get();
    if (u > p.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      r.setUint32(4 * f, p[f], h);
  }
  digest() {
    const { buffer: t, outputLen: s } = this;
    this.digestInto(t);
    const n = t.slice(0, s);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: s, buffer: n, length: i, finished: h, destroyed: e, pos: r } = this;
    return t.destroyed = e, t.finished = h, t.length = i, t.pos = r, i % s && t.buffer.set(n), t;
  }
  clone() {
    return this._cloneInto();
  }
}
const B = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
export {
  U as Chi,
  m as HashMD,
  _ as Maj,
  B as SHA256_IV,
  y as setBigUint64
};
