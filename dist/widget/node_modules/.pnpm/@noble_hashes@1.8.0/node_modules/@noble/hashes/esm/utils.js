/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function o(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function w(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error("positive integer expected, got " + e);
}
function r(e, ...t) {
  if (!o(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function h(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function l(e, t) {
  r(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error("digestInto() expects output buffer of length at least " + n);
}
function a(e) {
  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function g(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function p(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function b(e, t) {
  return e << 32 - t | e >>> t;
}
const i = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function u(e) {
  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
function c(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = u(e[t]);
  return e;
}
const x = i ? (e) => e : c;
function s(e) {
  if (typeof e != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e));
}
function y(e) {
  return typeof e == "string" && (e = s(e)), r(e), e;
}
class d {
}
function E(e) {
  const t = (f) => e().update(y(f)).digest(), n = e();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t;
}
export {
  d as Hash,
  r as abytes,
  h as aexists,
  w as anumber,
  l as aoutput,
  u as byteSwap,
  c as byteSwap32,
  g as clean,
  E as createHasher,
  p as createView,
  o as isBytes,
  i as isLE,
  b as rotr,
  x as swap32IfBE,
  y as toBytes,
  a as u32,
  s as utf8ToBytes
};
