import { encodePacketToBinary as b, encodePacket as m } from "./encodePacket.browser.js";
import { decodePacket as h } from "./decodePacket.browser.js";
import { ERROR_PACKET as g } from "./commons.js";
const y = "", A = (r, a) => {
  const n = r.length, t = new Array(n);
  let e = 0;
  r.forEach((i, l) => {
    m(i, !1, (f) => {
      t[l] = f, ++e === n && a(t.join(y));
    });
  });
}, D = (r, a) => {
  const n = r.split(y), t = [];
  for (let e = 0; e < n.length; e++) {
    const i = h(n[e], a);
    if (t.push(i), i.type === "error")
      break;
  }
  return t;
};
function E() {
  return new TransformStream({
    transform(r, a) {
      b(r, (n) => {
        const t = n.length;
        let e;
        if (t < 126)
          e = new Uint8Array(1), new DataView(e.buffer).setUint8(0, t);
        else if (t < 65536) {
          e = new Uint8Array(3);
          const i = new DataView(e.buffer);
          i.setUint8(0, 126), i.setUint16(1, t);
        } else {
          e = new Uint8Array(9);
          const i = new DataView(e.buffer);
          i.setUint8(0, 127), i.setBigUint64(1, BigInt(t));
        }
        r.data && typeof r.data != "string" && (e[0] |= 128), a.enqueue(e), a.enqueue(n);
      });
    }
  });
}
let d;
function s(r) {
  return r.reduce((a, n) => a + n.length, 0);
}
function c(r, a) {
  if (r[0].length === a)
    return r.shift();
  const n = new Uint8Array(a);
  let t = 0;
  for (let e = 0; e < a; e++)
    n[e] = r[0][t++], t === r[0].length && (r.shift(), t = 0);
  return r.length && t < r[0].length && (r[0] = r[0].slice(t)), n;
}
function T(r, a) {
  d || (d = new TextDecoder());
  const n = [];
  let t = 0, e = -1, i = !1;
  return new TransformStream({
    transform(l, f) {
      for (n.push(l); ; ) {
        if (t === 0) {
          if (s(n) < 1)
            break;
          const o = c(n, 1);
          i = (o[0] & 128) === 128, e = o[0] & 127, e < 126 ? t = 3 : e === 126 ? t = 1 : t = 2;
        } else if (t === 1) {
          if (s(n) < 2)
            break;
          const o = c(n, 2);
          e = new DataView(o.buffer, o.byteOffset, o.length).getUint16(0), t = 3;
        } else if (t === 2) {
          if (s(n) < 8)
            break;
          const o = c(n, 8), u = new DataView(o.buffer, o.byteOffset, o.length), w = u.getUint32(0);
          if (w > Math.pow(2, 21) - 1) {
            f.enqueue(g);
            break;
          }
          e = w * Math.pow(2, 32) + u.getUint32(4), t = 3;
        } else {
          if (s(n) < e)
            break;
          const o = c(n, e);
          f.enqueue(h(i ? o : d.decode(o), a)), t = 0;
        }
        if (e === 0 || e > r) {
          f.enqueue(g);
          break;
        }
      }
    }
  });
}
const x = 4;
export {
  T as createPacketDecoderStream,
  E as createPacketEncoderStream,
  h as decodePacket,
  D as decodePayload,
  m as encodePacket,
  A as encodePayload,
  x as protocol
};
