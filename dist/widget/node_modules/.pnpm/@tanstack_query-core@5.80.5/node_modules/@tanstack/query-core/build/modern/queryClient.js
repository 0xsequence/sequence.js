var b = (e) => {
  throw TypeError(e);
};
var D = (e, t, r) => t.has(e) || b("Cannot " + r);
var s = (e, t, r) => (D(e, t, "read from private field"), r ? r.call(e) : t.get(e)), h = (e, t, r) => t.has(e) ? b("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), n = (e, t, r, a) => (D(e, t, "write to private field"), a ? a.call(e, r) : t.set(e, r), r);
var v = (e, t, r, a) => ({
  set _(u) {
    n(e, t, u, r);
  },
  get _() {
    return s(e, t, a);
  }
});
import { resolveStaleTime as M, functionalUpdate as E, noop as c, hashKey as w, partialMatchKey as C, hashQueryKeyByOptions as S, skipToken as T } from "./utils.js";
import { QueryCache as K } from "./queryCache.js";
import { MutationCache as k } from "./mutationCache.js";
import { focusManager as F } from "./focusManager.js";
import { onlineManager as P } from "./onlineManager.js";
import { notifyManager as d } from "./notifyManager.js";
import { infiniteQueryBehavior as q } from "./infiniteQueryBehavior.js";
var i, o, f, y, m, l, Q, p, A, z = (A = class {
  constructor(e = {}) {
    h(this, i);
    h(this, o);
    h(this, f);
    h(this, y);
    h(this, m);
    h(this, l);
    h(this, Q);
    h(this, p);
    n(this, i, e.queryCache || new K()), n(this, o, e.mutationCache || new k()), n(this, f, e.defaultOptions || {}), n(this, y, /* @__PURE__ */ new Map()), n(this, m, /* @__PURE__ */ new Map()), n(this, l, 0);
  }
  mount() {
    v(this, l)._++, s(this, l) === 1 && (n(this, Q, F.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), s(this, i).onFocus());
    })), n(this, p, P.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), s(this, i).onOnline());
    })));
  }
  unmount() {
    var e, t;
    v(this, l)._--, s(this, l) === 0 && ((e = s(this, Q)) == null || e.call(this), n(this, Q, void 0), (t = s(this, p)) == null || t.call(this), n(this, p, void 0));
  }
  isFetching(e) {
    return s(this, i).findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return s(this, o).findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    var r;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (r = s(this, i).get(t.queryHash)) == null ? void 0 : r.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), r = s(this, i).build(this, t), a = r.state.data;
    return a === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime(M(t.staleTime, r)) && this.prefetchQuery(t), Promise.resolve(a));
  }
  getQueriesData(e) {
    return s(this, i).findAll(e).map(({ queryKey: t, state: r }) => {
      const a = r.data;
      return [t, a];
    });
  }
  setQueryData(e, t, r) {
    const a = this.defaultQueryOptions({ queryKey: e }), u = s(this, i).get(
      a.queryHash
    ), O = u == null ? void 0 : u.state.data, g = E(t, O);
    if (g !== void 0)
      return s(this, i).build(this, a).setData(g, { ...r, manual: !0 });
  }
  setQueriesData(e, t, r) {
    return d.batch(
      () => s(this, i).findAll(e).map(({ queryKey: a }) => [
        a,
        this.setQueryData(a, t, r)
      ])
    );
  }
  getQueryState(e) {
    var r;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (r = s(this, i).get(
      t.queryHash
    )) == null ? void 0 : r.state;
  }
  removeQueries(e) {
    const t = s(this, i);
    d.batch(() => {
      t.findAll(e).forEach((r) => {
        t.remove(r);
      });
    });
  }
  resetQueries(e, t) {
    const r = s(this, i);
    return d.batch(() => (r.findAll(e).forEach((a) => {
      a.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const r = { revert: !0, ...t }, a = d.batch(
      () => s(this, i).findAll(e).map((u) => u.cancel(r))
    );
    return Promise.all(a).then(c).catch(c);
  }
  invalidateQueries(e, t = {}) {
    return d.batch(() => (s(this, i).findAll(e).forEach((r) => {
      r.invalidate();
    }), (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const r = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, a = d.batch(
      () => s(this, i).findAll(e).filter((u) => !u.isDisabled() && !u.isStatic()).map((u) => {
        let O = u.fetch(void 0, r);
        return r.throwOnError || (O = O.catch(c)), u.state.fetchStatus === "paused" ? Promise.resolve() : O;
      })
    );
    return Promise.all(a).then(c);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const r = s(this, i).build(this, t);
    return r.isStaleByTime(
      M(t.staleTime, r)
    ) ? r.fetch(t) : Promise.resolve(r.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(c).catch(c);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = q(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(c).catch(c);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = q(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return P.isOnline() ? s(this, o).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return s(this, i);
  }
  getMutationCache() {
    return s(this, o);
  }
  getDefaultOptions() {
    return s(this, f);
  }
  setDefaultOptions(e) {
    n(this, f, e);
  }
  setQueryDefaults(e, t) {
    s(this, y).set(w(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...s(this, y).values()], r = {};
    return t.forEach((a) => {
      C(e, a.queryKey) && Object.assign(r, a.defaultOptions);
    }), r;
  }
  setMutationDefaults(e, t) {
    s(this, m).set(w(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...s(this, m).values()], r = {};
    return t.forEach((a) => {
      C(e, a.mutationKey) && Object.assign(r, a.defaultOptions);
    }), r;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...s(this, f).queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = S(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === T && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted ? e : {
      ...s(this, f).mutations,
      ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    s(this, i).clear(), s(this, o).clear();
  }
}, i = new WeakMap(), o = new WeakMap(), f = new WeakMap(), y = new WeakMap(), m = new WeakMap(), l = new WeakMap(), Q = new WeakMap(), p = new WeakMap(), A);
export {
  z as QueryClient
};
