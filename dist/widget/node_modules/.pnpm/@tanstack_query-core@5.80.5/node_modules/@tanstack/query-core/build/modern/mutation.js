var j = (i) => {
  throw TypeError(i);
};
var m = (i, t, s) => t.has(i) || j("Cannot " + s);
var e = (i, t, s) => (m(i, t, "read from private field"), s ? s.call(i) : t.get(i)), l = (i, t, s) => t.has(i) ? j("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, s), p = (i, t, s, r) => (m(i, t, "write to private field"), r ? r.call(i, s) : t.set(i, s), s), h = (i, t, s) => (m(i, t, "access private method"), s);
import { notifyManager as q } from "./notifyManager.js";
import { Removable as z } from "./removable.js";
import { createRetryer as B } from "./retryer.js";
var a, n, d, u, c, U, V = (U = class extends z {
  constructor(t) {
    super();
    l(this, u);
    l(this, a);
    l(this, n);
    l(this, d);
    this.mutationId = t.mutationId, p(this, n, t.mutationCache), p(this, a, []), this.state = t.state || H(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    e(this, a).includes(t) || (e(this, a).push(t), this.clearGcTimeout(), e(this, n).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    p(this, a, e(this, a).filter((s) => s !== t)), this.scheduleGc(), e(this, n).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    e(this, a).length || (this.state.status === "pending" ? this.scheduleGc() : e(this, n).remove(this));
  }
  continue() {
    var t;
    return ((t = e(this, d)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    var x, w, g, v, R, C, P, S, M, G, D, E, F, O, A, T, b, k, I, N;
    const s = () => {
      h(this, u, c).call(this, { type: "continue" });
    };
    p(this, d, B({
      fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
      onFail: (o, f) => {
        h(this, u, c).call(this, { type: "failed", failureCount: o, error: f });
      },
      onPause: () => {
        h(this, u, c).call(this, { type: "pause" });
      },
      onContinue: s,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => e(this, n).canRun(this)
    }));
    const r = this.state.status === "pending", y = !e(this, d).canStart();
    try {
      if (r)
        s();
      else {
        h(this, u, c).call(this, { type: "pending", variables: t, isPaused: y }), await ((w = (x = e(this, n).config).onMutate) == null ? void 0 : w.call(
          x,
          t,
          this
        ));
        const f = await ((v = (g = this.options).onMutate) == null ? void 0 : v.call(g, t));
        f !== this.state.context && h(this, u, c).call(this, {
          type: "pending",
          context: f,
          variables: t,
          isPaused: y
        });
      }
      const o = await e(this, d).start();
      return await ((C = (R = e(this, n).config).onSuccess) == null ? void 0 : C.call(
        R,
        o,
        t,
        this.state.context,
        this
      )), await ((S = (P = this.options).onSuccess) == null ? void 0 : S.call(P, o, t, this.state.context)), await ((G = (M = e(this, n).config).onSettled) == null ? void 0 : G.call(
        M,
        o,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((E = (D = this.options).onSettled) == null ? void 0 : E.call(D, o, null, t, this.state.context)), h(this, u, c).call(this, { type: "success", data: o }), o;
    } catch (o) {
      try {
        throw await ((O = (F = e(this, n).config).onError) == null ? void 0 : O.call(
          F,
          o,
          t,
          this.state.context,
          this
        )), await ((T = (A = this.options).onError) == null ? void 0 : T.call(
          A,
          o,
          t,
          this.state.context
        )), await ((k = (b = e(this, n).config).onSettled) == null ? void 0 : k.call(
          b,
          void 0,
          o,
          this.state.variables,
          this.state.context,
          this
        )), await ((N = (I = this.options).onSettled) == null ? void 0 : N.call(
          I,
          void 0,
          o,
          t,
          this.state.context
        )), o;
      } finally {
        h(this, u, c).call(this, { type: "error", error: o });
      }
    } finally {
      e(this, n).runNext(this);
    }
  }
}, a = new WeakMap(), n = new WeakMap(), d = new WeakMap(), u = new WeakSet(), c = function(t) {
  const s = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          failureCount: t.failureCount,
          failureReason: t.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: t.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: t.isPaused,
          status: "pending",
          variables: t.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: t.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: t.error,
          failureCount: r.failureCount + 1,
          failureReason: t.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = s(this.state), q.batch(() => {
    e(this, a).forEach((r) => {
      r.onMutationUpdate(t);
    }), e(this, n).notify({
      mutation: this,
      type: "updated",
      action: t
    });
  });
}, U);
function H() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
export {
  V as Mutation,
  H as getDefaultState
};
