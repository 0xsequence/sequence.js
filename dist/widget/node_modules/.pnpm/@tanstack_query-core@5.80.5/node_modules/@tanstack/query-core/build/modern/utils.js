var O = typeof window > "u" || "Deno" in globalThis;
function k() {
}
function q(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function F(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function b(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function w(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function K(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function P(e, t) {
  const {
    type: r = "all",
    exact: n,
    fetchStatus: i,
    predicate: o,
    queryKey: f,
    stale: s
  } = e;
  if (f) {
    if (n) {
      if (t.queryHash !== m(f, t.options))
        return !1;
    } else if (!S(t.queryKey, f))
      return !1;
  }
  if (r !== "all") {
    const c = t.isActive();
    if (r === "active" && !c || r === "inactive" && c)
      return !1;
  }
  return !(typeof s == "boolean" && t.isStale() !== s || i && i !== t.state.fetchStatus || o && !o(t));
}
function v(e, t) {
  const { exact: r, status: n, predicate: i, mutationKey: o } = e;
  if (o) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (y(t.options.mutationKey) !== y(o))
        return !1;
    } else if (!S(t.options.mutationKey, o))
      return !1;
  }
  return !(n && t.state.status !== n || i && !i(t));
}
function m(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || y)(e);
}
function y(e) {
  return JSON.stringify(
    e,
    (t, r) => p(r) ? Object.keys(r).sort().reduce((n, i) => (n[i] = r[i], n), {}) : r
  );
}
function S(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((r) => S(e[r], t[r])) : !1;
}
function h(e, t) {
  if (e === t)
    return e;
  const r = g(e) && g(t);
  if (r || p(e) && p(t)) {
    const n = r ? e : Object.keys(e), i = n.length, o = r ? t : Object.keys(t), f = o.length, s = r ? [] : {}, c = new Set(n);
    let l = 0;
    for (let a = 0; a < f; a++) {
      const u = r ? a : o[a];
      (!r && c.has(u) || r) && e[u] === void 0 && t[u] === void 0 ? (s[u] = void 0, l++) : (s[u] = h(e[u], t[u]), s[u] === e[u] && e[u] !== void 0 && l++);
    }
    return i === f && l === i ? e : s;
  }
  return t;
}
function T(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const r in e)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function g(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function p(e) {
  if (!d(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const r = t.prototype;
  return !(!d(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function d(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function E(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function I(e, t, r) {
  if (typeof r.structuralSharing == "function")
    return r.structuralSharing(e, t);
  if (r.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return h(e, t);
      } catch (n) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${n}`
        ), n;
      }
    return h(e, t);
  }
  return t;
}
function N(e, t, r = 0) {
  const n = [...e, t];
  return r && n.length > r ? n.slice(1) : n;
}
function A(e, t, r = 0) {
  const n = [t, ...e];
  return r && n.length > r ? n.slice(0, -1) : n;
}
var j = Symbol();
function H(e, t) {
  return process.env.NODE_ENV !== "production" && e.queryFn === j && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${e.queryHash}'`
  ), !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === j ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
function z(e, t) {
  return typeof e == "function" ? e(...t) : !!e;
}
export {
  N as addToEnd,
  A as addToStart,
  H as ensureQueryFn,
  q as functionalUpdate,
  y as hashKey,
  m as hashQueryKeyByOptions,
  g as isPlainArray,
  p as isPlainObject,
  O as isServer,
  F as isValidTimeout,
  v as matchMutation,
  P as matchQuery,
  k as noop,
  S as partialMatchKey,
  I as replaceData,
  h as replaceEqualDeep,
  K as resolveEnabled,
  w as resolveStaleTime,
  T as shallowEqualObjects,
  z as shouldThrowError,
  j as skipToken,
  E as sleep,
  b as timeUntilStale
};
