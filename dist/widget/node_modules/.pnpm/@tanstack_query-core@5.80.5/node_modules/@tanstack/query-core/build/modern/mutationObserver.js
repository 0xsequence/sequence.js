var K = (i) => {
  throw TypeError(i);
};
var c = (i, t, s) => t.has(i) || K("Cannot " + s);
var e = (i, t, s) => (c(i, t, "read from private field"), s ? s.call(i) : t.get(i)), p = (i, t, s) => t.has(i) ? K("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, s), l = (i, t, s, h) => (c(i, t, "write to private field"), h ? h.call(i, s) : t.set(i, s), s), m = (i, t, s) => (c(i, t, "access private method"), s);
import { getDefaultState as R } from "./mutation.js";
import { notifyManager as U } from "./notifyManager.js";
import { Subscribable as L } from "./subscribable.js";
import { shallowEqualObjects as j, hashKey as E } from "./utils.js";
var u, a, r, o, n, f, v, C, k = (C = class extends L {
  constructor(t, s) {
    super();
    p(this, n);
    p(this, u);
    p(this, a);
    p(this, r);
    p(this, o);
    l(this, u, t), this.setOptions(s), this.bindMethods(), m(this, n, f).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    var h;
    const s = this.options;
    this.options = e(this, u).defaultMutationOptions(t), j(this.options, s) || e(this, u).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: e(this, r),
      observer: this
    }), s != null && s.mutationKey && this.options.mutationKey && E(s.mutationKey) !== E(this.options.mutationKey) ? this.reset() : ((h = e(this, r)) == null ? void 0 : h.state.status) === "pending" && e(this, r).setOptions(this.options);
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || (t = e(this, r)) == null || t.removeObserver(this);
  }
  onMutationUpdate(t) {
    m(this, n, f).call(this), m(this, n, v).call(this, t);
  }
  getCurrentResult() {
    return e(this, a);
  }
  reset() {
    var t;
    (t = e(this, r)) == null || t.removeObserver(this), l(this, r, void 0), m(this, n, f).call(this), m(this, n, v).call(this);
  }
  mutate(t, s) {
    var h;
    return l(this, o, s), (h = e(this, r)) == null || h.removeObserver(this), l(this, r, e(this, u).getMutationCache().build(e(this, u), this.options)), e(this, r).addObserver(this), e(this, r).execute(t);
  }
}, u = new WeakMap(), a = new WeakMap(), r = new WeakMap(), o = new WeakMap(), n = new WeakSet(), f = function() {
  var s;
  const t = ((s = e(this, r)) == null ? void 0 : s.state) ?? R();
  l(this, a, {
    ...t,
    isPending: t.status === "pending",
    isSuccess: t.status === "success",
    isError: t.status === "error",
    isIdle: t.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, v = function(t) {
  U.batch(() => {
    var s, h, y, O, M, g, S, x;
    if (e(this, o) && this.hasListeners()) {
      const d = e(this, a).variables, b = e(this, a).context;
      (t == null ? void 0 : t.type) === "success" ? ((h = (s = e(this, o)).onSuccess) == null || h.call(s, t.data, d, b), (O = (y = e(this, o)).onSettled) == null || O.call(y, t.data, null, d, b)) : (t == null ? void 0 : t.type) === "error" && ((g = (M = e(this, o)).onError) == null || g.call(M, t.error, d, b), (x = (S = e(this, o)).onSettled) == null || x.call(
        S,
        void 0,
        t.error,
        d,
        b
      ));
    }
    this.listeners.forEach((d) => {
      d(e(this, a));
    });
  });
}, C);
export {
  k as MutationObserver
};
