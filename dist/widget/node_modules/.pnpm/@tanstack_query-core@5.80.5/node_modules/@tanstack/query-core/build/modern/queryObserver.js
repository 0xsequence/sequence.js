var ct = (i) => {
  throw TypeError(i);
};
var V = (i, t, s) => t.has(i) || ct("Cannot " + s);
var e = (i, t, s) => (V(i, t, "read from private field"), s ? s.call(i) : t.get(i)), l = (i, t, s) => t.has(i) ? ct("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, s), h = (i, t, s, a) => (V(i, t, "write to private field"), a ? a.call(i, s) : t.set(i, s), s), o = (i, t, s) => (V(i, t, "access private method"), s);
import { focusManager as gt } from "./focusManager.js";
import { notifyManager as Rt } from "./notifyManager.js";
import { fetchState as yt } from "./query.js";
import { Subscribable as Ot } from "./subscribable.js";
import { pendingThenable as lt } from "./thenable.js";
import { resolveEnabled as g, shallowEqualObjects as K, resolveStaleTime as M, noop as St, isServer as ut, isValidTimeout as dt, timeUntilStale as Ct, replaceData as ft } from "./utils.js";
var p, r, P, d, C, F, R, y, A, Q, D, I, U, O, E, n, L, N, G, J, X, Y, Z, $, vt, mt, Mt = (mt = class extends Ot {
  constructor(t, s) {
    super();
    l(this, n);
    l(this, p);
    l(this, r);
    l(this, P);
    l(this, d);
    l(this, C);
    l(this, F);
    l(this, R);
    l(this, y);
    l(this, A);
    l(this, Q);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    l(this, D);
    l(this, I);
    l(this, U);
    l(this, O);
    l(this, E, /* @__PURE__ */ new Set());
    this.options = s, h(this, p, t), h(this, y, null), h(this, R, lt()), this.options.experimental_prefetchInRender || e(this, R).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(s);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (e(this, r).addObserver(this), pt(e(this, r), this.options) ? o(this, n, L).call(this) : this.updateResult(), o(this, n, X).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return q(
      e(this, r),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return q(
      e(this, r),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), o(this, n, Y).call(this), o(this, n, Z).call(this), e(this, r).removeObserver(this);
  }
  setOptions(t) {
    const s = this.options, a = e(this, r);
    if (this.options = e(this, p).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof g(this.options.enabled, e(this, r)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    o(this, n, $).call(this), e(this, r).setOptions(this.options), s._defaulted && !K(this.options, s) && e(this, p).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: e(this, r),
      observer: this
    });
    const b = this.hasListeners();
    b && bt(
      e(this, r),
      a,
      this.options,
      s
    ) && o(this, n, L).call(this), this.updateResult(), b && (e(this, r) !== a || g(this.options.enabled, e(this, r)) !== g(s.enabled, e(this, r)) || M(this.options.staleTime, e(this, r)) !== M(s.staleTime, e(this, r))) && o(this, n, N).call(this);
    const c = o(this, n, G).call(this);
    b && (e(this, r) !== a || g(this.options.enabled, e(this, r)) !== g(s.enabled, e(this, r)) || c !== e(this, O)) && o(this, n, J).call(this, c);
  }
  getOptimisticResult(t) {
    const s = e(this, p).getQueryCache().build(e(this, p), t), a = this.createResult(s, t);
    return Ut(this, a) && (h(this, d, a), h(this, F, this.options), h(this, C, e(this, r).state)), a;
  }
  getCurrentResult() {
    return e(this, d);
  }
  trackResult(t, s) {
    return new Proxy(t, {
      get: (a, b) => (this.trackProp(b), s == null || s(b), Reflect.get(a, b))
    });
  }
  trackProp(t) {
    e(this, E).add(t);
  }
  getCurrentQuery() {
    return e(this, r);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const s = e(this, p).defaultQueryOptions(t), a = e(this, p).getQueryCache().build(e(this, p), s);
    return a.fetch().then(() => this.createResult(a, s));
  }
  fetch(t) {
    return o(this, n, L).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), e(this, d)));
  }
  createResult(t, s) {
    var ot;
    const a = e(this, r), b = this.options, c = e(this, d), w = e(this, C), x = e(this, F), z = t !== a ? t.state : e(this, P), { state: et } = t;
    let u = { ...et }, st = !1, f;
    if (s._optimisticResults) {
      const m = this.hasListeners(), j = !m && pt(t, s), T = m && bt(t, a, s, b);
      (j || T) && (u = {
        ...u,
        ...yt(et.data, t.options)
      }), s._optimisticResults === "isRestoring" && (u.fetchStatus = "idle");
    }
    let { error: it, errorUpdatedAt: rt, status: S } = u;
    f = u.data;
    let nt = !1;
    if (s.placeholderData !== void 0 && f === void 0 && S === "pending") {
      let m;
      c != null && c.isPlaceholderData && s.placeholderData === (x == null ? void 0 : x.placeholderData) ? (m = c.data, nt = !0) : m = typeof s.placeholderData == "function" ? s.placeholderData(
        (ot = e(this, D)) == null ? void 0 : ot.state.data,
        e(this, D)
      ) : s.placeholderData, m !== void 0 && (S = "success", f = ft(
        c == null ? void 0 : c.data,
        m,
        s
      ), st = !0);
    }
    if (s.select && f !== void 0 && !nt)
      if (c && f === (w == null ? void 0 : w.data) && s.select === e(this, A))
        f = e(this, Q);
      else
        try {
          h(this, A, s.select), f = s.select(f), f = ft(c == null ? void 0 : c.data, f, s), h(this, Q, f), h(this, y, null);
        } catch (m) {
          h(this, y, m);
        }
    e(this, y) && (it = e(this, y), f = e(this, Q), rt = Date.now(), S = "error");
    const W = u.fetchStatus === "fetching", B = S === "pending", H = S === "error", at = B && W, ht = f !== void 0, v = {
      status: S,
      fetchStatus: u.fetchStatus,
      isPending: B,
      isSuccess: S === "success",
      isError: H,
      isInitialLoading: at,
      isLoading: at,
      data: f,
      dataUpdatedAt: u.dataUpdatedAt,
      error: it,
      errorUpdatedAt: rt,
      failureCount: u.fetchFailureCount,
      failureReason: u.fetchFailureReason,
      errorUpdateCount: u.errorUpdateCount,
      isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
      isFetchedAfterMount: u.dataUpdateCount > z.dataUpdateCount || u.errorUpdateCount > z.errorUpdateCount,
      isFetching: W,
      isRefetching: W && !B,
      isLoadingError: H && !ht,
      isPaused: u.fetchStatus === "paused",
      isPlaceholderData: st,
      isRefetchError: H && ht,
      isStale: tt(t, s),
      refetch: this.refetch,
      promise: e(this, R)
    };
    if (this.options.experimental_prefetchInRender) {
      const m = (k) => {
        v.status === "error" ? k.reject(v.error) : v.data !== void 0 && k.resolve(v.data);
      }, j = () => {
        const k = h(this, R, v.promise = lt());
        m(k);
      }, T = e(this, R);
      switch (T.status) {
        case "pending":
          t.queryHash === a.queryHash && m(T);
          break;
        case "fulfilled":
          (v.status === "error" || v.data !== T.value) && j();
          break;
        case "rejected":
          (v.status !== "error" || v.error !== T.reason) && j();
          break;
      }
    }
    return v;
  }
  updateResult() {
    const t = e(this, d), s = this.createResult(e(this, r), this.options);
    if (h(this, C, e(this, r).state), h(this, F, this.options), e(this, C).data !== void 0 && h(this, D, e(this, r)), K(s, t))
      return;
    h(this, d, s);
    const a = () => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: b } = this.options, c = typeof b == "function" ? b() : b;
      if (c === "all" || !c && !e(this, E).size)
        return !0;
      const w = new Set(
        c ?? e(this, E)
      );
      return this.options.throwOnError && w.add("error"), Object.keys(e(this, d)).some((x) => {
        const _ = x;
        return e(this, d)[_] !== t[_] && w.has(_);
      });
    };
    o(this, n, vt).call(this, { listeners: a() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && o(this, n, X).call(this);
  }
}, p = new WeakMap(), r = new WeakMap(), P = new WeakMap(), d = new WeakMap(), C = new WeakMap(), F = new WeakMap(), R = new WeakMap(), y = new WeakMap(), A = new WeakMap(), Q = new WeakMap(), D = new WeakMap(), I = new WeakMap(), U = new WeakMap(), O = new WeakMap(), E = new WeakMap(), n = new WeakSet(), L = function(t) {
  o(this, n, $).call(this);
  let s = e(this, r).fetch(
    this.options,
    t
  );
  return t != null && t.throwOnError || (s = s.catch(St)), s;
}, N = function() {
  o(this, n, Y).call(this);
  const t = M(
    this.options.staleTime,
    e(this, r)
  );
  if (ut || e(this, d).isStale || !dt(t))
    return;
  const a = Ct(e(this, d).dataUpdatedAt, t) + 1;
  h(this, I, setTimeout(() => {
    e(this, d).isStale || this.updateResult();
  }, a));
}, G = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(e(this, r)) : this.options.refetchInterval) ?? !1;
}, J = function(t) {
  o(this, n, Z).call(this), h(this, O, t), !(ut || g(this.options.enabled, e(this, r)) === !1 || !dt(e(this, O)) || e(this, O) === 0) && h(this, U, setInterval(() => {
    (this.options.refetchIntervalInBackground || gt.isFocused()) && o(this, n, L).call(this);
  }, e(this, O)));
}, X = function() {
  o(this, n, N).call(this), o(this, n, J).call(this, o(this, n, G).call(this));
}, Y = function() {
  e(this, I) && (clearTimeout(e(this, I)), h(this, I, void 0));
}, Z = function() {
  e(this, U) && (clearInterval(e(this, U)), h(this, U, void 0));
}, $ = function() {
  const t = e(this, p).getQueryCache().build(e(this, p), this.options);
  if (t === e(this, r))
    return;
  const s = e(this, r);
  h(this, r, t), h(this, P, t.state), this.hasListeners() && (s == null || s.removeObserver(this), t.addObserver(this));
}, vt = function(t) {
  Rt.batch(() => {
    t.listeners && this.listeners.forEach((s) => {
      s(e(this, d));
    }), e(this, p).getQueryCache().notify({
      query: e(this, r),
      type: "observerResultsUpdated"
    });
  });
}, mt);
function It(i, t) {
  return g(t.enabled, i) !== !1 && i.state.data === void 0 && !(i.state.status === "error" && t.retryOnMount === !1);
}
function pt(i, t) {
  return It(i, t) || i.state.data !== void 0 && q(i, t, t.refetchOnMount);
}
function q(i, t, s) {
  if (g(t.enabled, i) !== !1 && M(t.staleTime, i) !== "static") {
    const a = typeof s == "function" ? s(i) : s;
    return a === "always" || a !== !1 && tt(i, t);
  }
  return !1;
}
function bt(i, t, s, a) {
  return (i !== t || g(a.enabled, i) === !1) && (!s.suspense || i.state.status !== "error") && tt(i, s);
}
function tt(i, t) {
  return g(t.enabled, i) !== !1 && i.isStaleByTime(M(t.staleTime, i));
}
function Ut(i, t) {
  return !K(i.getCurrentResult(), t);
}
export {
  Mt as QueryObserver
};
