var u = (s) => {
  throw TypeError(s);
};
var f = (s, t, e) => t.has(s) || u("Cannot " + e);
var h = (s, t, e) => (f(s, t, "read from private field"), e ? e.call(s) : t.get(s)), c = (s, t, e) => t.has(s) ? u("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), y = (s, t, e, i) => (f(s, t, "write to private field"), i ? i.call(s, e) : t.set(s, e), e);
import { hashQueryKeyByOptions as m, matchQuery as d } from "./utils.js";
import { Query as p } from "./query.js";
import { notifyManager as o } from "./notifyManager.js";
import { Subscribable as b } from "./subscribable.js";
var r, g, v = (g = class extends b {
  constructor(t = {}) {
    super();
    c(this, r);
    this.config = t, y(this, r, /* @__PURE__ */ new Map());
  }
  build(t, e, i) {
    const n = e.queryKey, l = e.queryHash ?? m(n, e);
    let a = this.get(l);
    return a || (a = new p({
      client: t,
      queryKey: n,
      queryHash: l,
      options: t.defaultQueryOptions(e),
      state: i,
      defaultOptions: t.getQueryDefaults(n)
    }), this.add(a)), a;
  }
  add(t) {
    h(this, r).has(t.queryHash) || (h(this, r).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const e = h(this, r).get(t.queryHash);
    e && (t.destroy(), e === t && h(this, r).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    o.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return h(this, r).get(t);
  }
  getAll() {
    return [...h(this, r).values()];
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => d(e, i)
    );
  }
  findAll(t = {}) {
    const e = this.getAll();
    return Object.keys(t).length > 0 ? e.filter((i) => d(t, i)) : e;
  }
  notify(t) {
    o.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  onFocus() {
    o.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    o.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, r = new WeakMap(), g);
export {
  v as QueryCache
};
