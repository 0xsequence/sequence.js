var u = (i) => {
  throw TypeError(i);
};
var g = (i, t, e) => t.has(i) || u("Cannot " + e);
var o = (i, t, e) => (g(i, t, "read from private field"), e ? e.call(i) : t.get(i)), d = (i, t, e) => t.has(i) ? u("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), a = (i, t, e, s) => (g(i, t, "write to private field"), s ? s.call(i, e) : t.set(i, e), e);
var y = (i, t, e, s) => ({
  set _(n) {
    a(i, t, n, e);
  },
  get _() {
    return o(i, t, s);
  }
});
import { notifyManager as p } from "./notifyManager.js";
import { Mutation as b } from "./mutation.js";
import { matchMutation as m, noop as P } from "./utils.js";
import { Subscribable as v } from "./subscribable.js";
var c, r, f, M, F = (M = class extends v {
  constructor(t = {}) {
    super();
    d(this, c);
    d(this, r);
    d(this, f);
    this.config = t, a(this, c, /* @__PURE__ */ new Set()), a(this, r, /* @__PURE__ */ new Map()), a(this, f, 0);
  }
  build(t, e, s) {
    const n = new b({
      mutationCache: this,
      mutationId: ++y(this, f)._,
      options: t.defaultMutationOptions(e),
      state: s
    });
    return this.add(n), n;
  }
  add(t) {
    o(this, c).add(t);
    const e = l(t);
    if (typeof e == "string") {
      const s = o(this, r).get(e);
      s ? s.push(t) : o(this, r).set(e, [t]);
    }
    this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    if (o(this, c).delete(t)) {
      const e = l(t);
      if (typeof e == "string") {
        const s = o(this, r).get(e);
        if (s)
          if (s.length > 1) {
            const n = s.indexOf(t);
            n !== -1 && s.splice(n, 1);
          } else s[0] === t && o(this, r).delete(e);
      }
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    const e = l(t);
    if (typeof e == "string") {
      const s = o(this, r).get(e), n = s == null ? void 0 : s.find(
        (h) => h.state.status === "pending"
      );
      return !n || n === t;
    } else
      return !0;
  }
  runNext(t) {
    var s;
    const e = l(t);
    if (typeof e == "string") {
      const n = (s = o(this, r).get(e)) == null ? void 0 : s.find((h) => h !== t && h.state.isPaused);
      return (n == null ? void 0 : n.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    p.batch(() => {
      o(this, c).forEach((t) => {
        this.notify({ type: "removed", mutation: t });
      }), o(this, c).clear(), o(this, r).clear();
    });
  }
  getAll() {
    return Array.from(o(this, c));
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (s) => m(e, s)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((e) => m(t, e));
  }
  notify(t) {
    p.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((e) => e.state.isPaused);
    return p.batch(
      () => Promise.all(
        t.map((e) => e.continue().catch(P))
      )
    );
  }
}, c = new WeakMap(), r = new WeakMap(), f = new WeakMap(), M);
function l(i) {
  var t;
  return (t = i.options.scope) == null ? void 0 : t.id;
}
export {
  F as MutationCache
};
