var k = (i) => {
  throw TypeError(i);
};
var E = (i, e, s) => e.has(i) || k("Cannot " + s);
var r = (i, e, s) => (E(i, e, "read from private field"), s ? s.call(i) : e.get(i)), f = (i, e, s) => e.has(i) ? k("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, s), u = (i, e, s, t) => (E(i, e, "write to private field"), t ? t.call(i, s) : e.set(i, s), s), p = (i, e, s) => (E(i, e, "access private method"), s);
import { notifyManager as H } from "./notifyManager.js";
import { QueryObserver as L } from "./queryObserver.js";
import { Subscribable as N } from "./subscribable.js";
import { replaceEqualDeep as P } from "./utils.js";
function z(i, e) {
  const s = new Set(e);
  return i.filter((t) => !s.has(t));
}
function T(i, e, s) {
  const t = i.slice(0);
  return t[e] = s, t;
}
var d, a, O, y, l, b, m, g, Q, o, x, C, M, S, q, D, j = (D = class extends N {
  constructor(e, s, t) {
    super();
    f(this, o);
    f(this, d);
    f(this, a);
    f(this, O);
    f(this, y);
    f(this, l);
    f(this, b);
    f(this, m);
    f(this, g);
    f(this, Q, []);
    u(this, d, e), u(this, y, t), u(this, O, []), u(this, l, []), u(this, a, []), this.setQueries(s);
  }
  onSubscribe() {
    this.listeners.size === 1 && r(this, l).forEach((e) => {
      e.subscribe((s) => {
        p(this, o, S).call(this, e, s);
      });
    });
  }
  onUnsubscribe() {
    this.listeners.size || this.destroy();
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), r(this, l).forEach((e) => {
      e.destroy();
    });
  }
  setQueries(e, s) {
    if (u(this, O, e), u(this, y, s), process.env.NODE_ENV !== "production") {
      const t = e.map(
        (h) => r(this, d).defaultQueryOptions(h).queryHash
      );
      new Set(t).size !== t.length && console.warn(
        "[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior."
      );
    }
    H.batch(() => {
      const t = r(this, l), h = p(this, o, M).call(this, r(this, O));
      u(this, Q, h), h.forEach(
        (c) => c.observer.setOptions(c.defaultedQueryOptions)
      );
      const n = h.map((c) => c.observer), v = n.map(
        (c) => c.getCurrentResult()
      ), R = n.some(
        (c, w) => c !== t[w]
      );
      t.length === n.length && !R || (u(this, l, n), u(this, a, v), this.hasListeners() && (z(t, n).forEach((c) => {
        c.destroy();
      }), z(n, t).forEach((c) => {
        c.subscribe((w) => {
          p(this, o, S).call(this, c, w);
        });
      }), p(this, o, q).call(this)));
    });
  }
  getCurrentResult() {
    return r(this, a);
  }
  getQueries() {
    return r(this, l).map((e) => e.getCurrentQuery());
  }
  getObservers() {
    return r(this, l);
  }
  getOptimisticResult(e, s) {
    const t = p(this, o, M).call(this, e), h = t.map(
      (n) => n.observer.getOptimisticResult(n.defaultedQueryOptions)
    );
    return [
      h,
      (n) => p(this, o, C).call(this, n ?? h, s),
      () => p(this, o, x).call(this, h, t)
    ];
  }
}, d = new WeakMap(), a = new WeakMap(), O = new WeakMap(), y = new WeakMap(), l = new WeakMap(), b = new WeakMap(), m = new WeakMap(), g = new WeakMap(), Q = new WeakMap(), o = new WeakSet(), x = function(e, s) {
  return s.map((t, h) => {
    const n = e[h];
    return t.defaultedQueryOptions.notifyOnChangeProps ? n : t.observer.trackResult(n, (v) => {
      s.forEach((R) => {
        R.observer.trackProp(v);
      });
    });
  });
}, C = function(e, s) {
  return s ? ((!r(this, b) || r(this, a) !== r(this, g) || s !== r(this, m)) && (u(this, m, s), u(this, g, r(this, a)), u(this, b, P(
    r(this, b),
    s(e)
  ))), r(this, b)) : e;
}, M = function(e) {
  const s = new Map(
    r(this, l).map((h) => [h.options.queryHash, h])
  ), t = [];
  return e.forEach((h) => {
    const n = r(this, d).defaultQueryOptions(h), v = s.get(n.queryHash);
    v ? t.push({
      defaultedQueryOptions: n,
      observer: v
    }) : t.push({
      defaultedQueryOptions: n,
      observer: new L(r(this, d), n)
    });
  }), t;
}, S = function(e, s) {
  const t = r(this, l).indexOf(e);
  t !== -1 && (u(this, a, T(r(this, a), t, s)), p(this, o, q).call(this));
}, q = function() {
  var e;
  if (this.hasListeners()) {
    const s = r(this, b), t = p(this, o, x).call(this, r(this, a), r(this, Q)), h = p(this, o, C).call(this, t, (e = r(this, y)) == null ? void 0 : e.combine);
    s !== h && H.batch(() => {
      this.listeners.forEach((n) => {
        n(r(this, a));
      });
    });
  }
}, D);
export {
  j as QueriesObserver
};
