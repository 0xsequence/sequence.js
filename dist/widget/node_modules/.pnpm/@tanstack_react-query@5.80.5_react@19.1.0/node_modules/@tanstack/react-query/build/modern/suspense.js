var s = (c) => {
  if (c.suspense) {
    const i = (m) => m === "static" ? m : Math.max(m ?? 1e3, 1e3), e = c.staleTime;
    c.staleTime = typeof e == "function" ? (...m) => i(e(...m)) : i(e), typeof c.gcTime == "number" && (c.gcTime = Math.max(c.gcTime, 1e3));
  }
}, r = (c, i) => c.isLoading && c.isFetching && !i, h = (c, i) => (c == null ? void 0 : c.suspense) && i.isPending, g = (c, i, e) => i.fetchOptimistic(c).catch(() => {
  e.clearReset();
});
export {
  s as ensureSuspenseTimers,
  g as fetchOptimistic,
  h as shouldSuspend,
  r as willFetch
};
