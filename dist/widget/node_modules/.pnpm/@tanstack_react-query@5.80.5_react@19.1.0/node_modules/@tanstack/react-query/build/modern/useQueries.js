import * as c from "react";
import { QueryObserver as O } from "../../../../../../@tanstack_query-core@5.80.5/node_modules/@tanstack/query-core/build/modern/queryObserver.js";
import { QueriesObserver as C } from "../../../../../../@tanstack_query-core@5.80.5/node_modules/@tanstack/query-core/build/modern/queriesObserver.js";
import { notifyManager as E } from "../../../../../../@tanstack_query-core@5.80.5/node_modules/@tanstack/query-core/build/modern/notifyManager.js";
import { noop as Q } from "../../../../../../@tanstack_query-core@5.80.5/node_modules/@tanstack/query-core/build/modern/utils.js";
import { useQueryClient as v } from "./QueryClientProvider.js";
import { useIsRestoring as w } from "./IsRestoringProvider.js";
import { useQueryErrorResetBoundary as S } from "./QueryErrorResetBoundary.js";
import { ensurePreventErrorBoundaryRetry as B, useClearResetErrorBoundary as q, getHasError as M } from "./errorBoundaryUtils.js";
import { ensureSuspenseTimers as P, shouldSuspend as b, fetchOptimistic as R, willFetch as k } from "./suspense.js";
function J({
  queries: f,
  ...u
}, x) {
  const n = v(), m = w(), i = S(), t = c.useMemo(
    () => f.map((e) => {
      const s = n.defaultQueryOptions(
        e
      );
      return s._optimisticResults = m ? "isRestoring" : "optimistic", s;
    }),
    [f, n, m]
  );
  t.forEach((e) => {
    P(e), B(e, i);
  }), q(i);
  const [o] = c.useState(
    () => new C(
      n,
      t,
      u
    )
  ), [l, g, h] = o.getOptimisticResult(
    t,
    u.combine
  ), p = !m && u.subscribed !== !1;
  c.useSyncExternalStore(
    c.useCallback(
      (e) => p ? o.subscribe(E.batchCalls(e)) : Q,
      [o, p]
    ),
    () => o.getCurrentResult(),
    () => o.getCurrentResult()
  ), c.useEffect(() => {
    o.setQueries(
      t,
      u
    );
  }, [t, u, o]);
  const d = l.some(
    (e, s) => b(t[s], e)
  ) ? l.flatMap((e, s) => {
    const r = t[s];
    if (r) {
      const y = new O(n, r);
      if (b(r, e))
        return R(r, y, i);
      k(e, m) && R(r, y, i);
    }
    return [];
  }) : [];
  if (d.length > 0)
    throw Promise.all(d);
  const a = l.find(
    (e, s) => {
      const r = t[s];
      return r && M({
        result: e,
        errorResetBoundary: i,
        throwOnError: r.throwOnError,
        query: n.getQueryCache().get(r.queryHash),
        suspense: r.suspense
      });
    }
  );
  if (a != null && a.error)
    throw a.error;
  return g(h());
}
export {
  J as useQueries
};
