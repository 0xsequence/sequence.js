import * as c from "react";
import { notifyManager as R } from "../../../../../../@tanstack_query-core@5.80.5/node_modules/@tanstack/query-core/build/modern/notifyManager.js";
import { noop as m, isServer as b } from "../../../../../../@tanstack_query-core@5.80.5/node_modules/@tanstack/query-core/build/modern/utils.js";
import { useQueryClient as E } from "./QueryClientProvider.js";
import { useQueryErrorResetBoundary as O } from "./QueryErrorResetBoundary.js";
import { ensurePreventErrorBoundaryRetry as C, useClearResetErrorBoundary as Q, getHasError as S } from "./errorBoundaryUtils.js";
import { useIsRestoring as _ } from "./IsRestoringProvider.js";
import { ensureSuspenseTimers as v, shouldSuspend as k, fetchOptimistic as d, willFetch as B } from "./suspense.js";
function A(u, g, F) {
  var i, p, a, y, h;
  if (process.env.NODE_ENV !== "production" && (typeof u != "object" || Array.isArray(u)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const l = _(), o = O(), t = E(), e = t.defaultQueryOptions(u);
  (p = (i = t.getDefaultOptions().queries) == null ? void 0 : i._experimental_beforeQuery) == null || p.call(
    i,
    e
  ), process.env.NODE_ENV !== "production" && (e.queryFn || console.error(
    `[${e.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), e._optimisticResults = l ? "isRestoring" : "optimistic", v(e), C(e, o), Q(o);
  const q = !t.getQueryCache().get(e.queryHash), [r] = c.useState(
    () => new g(
      t,
      e
    )
  ), s = r.getOptimisticResult(e), f = !l && u.subscribed !== !1;
  if (c.useSyncExternalStore(
    c.useCallback(
      (n) => {
        const w = f ? r.subscribe(R.batchCalls(n)) : m;
        return r.updateResult(), w;
      },
      [r, f]
    ),
    () => r.getCurrentResult(),
    () => r.getCurrentResult()
  ), c.useEffect(() => {
    r.setOptions(e);
  }, [e, r]), k(e, s))
    throw d(e, r, o);
  if (S({
    result: s,
    errorResetBoundary: o,
    throwOnError: e.throwOnError,
    query: t.getQueryCache().get(e.queryHash),
    suspense: e.suspense
  }))
    throw s.error;
  if ((y = (a = t.getDefaultOptions().queries) == null ? void 0 : a._experimental_afterQuery) == null || y.call(
    a,
    e,
    s
  ), e.experimental_prefetchInRender && !b && B(s, l)) {
    const n = q ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      d(e, r, o)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (h = t.getQueryCache().get(e.queryHash)) == null ? void 0 : h.promise
    );
    n == null || n.catch(m).finally(() => {
      r.updateResult();
    });
  }
  return e.notifyOnChangeProps ? s : r.trackResult(s);
}
export {
  A as useBaseQuery
};
