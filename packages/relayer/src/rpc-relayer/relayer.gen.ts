/* eslint-disable */
// sequence-relayer v0.4.1 db311ae9a6a93829f172c5d6db44955c2f7ba6f0
// --
// Code generated by Webrpc-gen@v0.30.1 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=relayer.ridl -target=typescript -client -out=./clients/relayer.gen.ts -compat

// Webrpc description and code-gen version
export const WebrpcVersion = 'v1'

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = 'v0.4.1'

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = 'db311ae9a6a93829f172c5d6db44955c2f7ba6f0'

//
// Client interface
//

export interface RelayerClient {
  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>

  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>

  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>

  getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn>

  getChainID(headers?: object, signal?: AbortSignal): Promise<GetChainIDReturn>

  /**
   *
   * Transactions
   *
   * TODO (future): rename this to just, 'SendTransaction(txn: MetaTransaction)' or 'SendTransaction(txn: SignedTransaction)', or something..
   * Project ID is only used by service and admin calls. Other clients must have projectID passed via the context
   * TODO: rename return txnHash: string to metaTxnID: string
   */
  sendMetaTxn(req: SendMetaTxnArgs, headers?: object, signal?: AbortSignal): Promise<SendMetaTxnReturn>

  getMetaTxnNonce(req: GetMetaTxnNonceArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnNonceReturn>

  /**
   * TODO: one day, make GetMetaTxnReceipt respond immediately with receipt or not
   * and add WaitTransactionReceipt method, which will block and wait, similar to how GetMetaTxnReceipt
   * is implemented now.
   * For backwards compat, we can leave the current GetMetaTxnReceipt how it is, an deprecate it, and introduce
   * new, GetTransactionReceipt and WaitTransactionReceipt methods
   * we can also accept metaTxnId and txnHash .. so can take either or.. I wonder if ERC-4337 has any convention on this?
   */
  getMetaTxnReceipt(req: GetMetaTxnReceiptArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnReceiptReturn>

  simulate(req: SimulateArgs, headers?: object, signal?: AbortSignal): Promise<SimulateReturn>

  simulateV3(req: SimulateV3Args, headers?: object, signal?: AbortSignal): Promise<SimulateV3Return>

  /**
   * TODO: deprecated, to be removed by https://github.com/0xsequence/stack/pull/356 at a later date
   */
  updateMetaTxnGasLimits(
    req: UpdateMetaTxnGasLimitsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateMetaTxnGasLimitsReturn>

  feeTokens(headers?: object, signal?: AbortSignal): Promise<FeeTokensReturn>

  feeOptions(req: FeeOptionsArgs, headers?: object, signal?: AbortSignal): Promise<FeeOptionsReturn>

  /**
   * TODO: deprecated, to be removed by https://github.com/0xsequence/stack/pull/356 at a later date
   */
  getMetaTxnNetworkFeeOptions(
    req: GetMetaTxnNetworkFeeOptionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMetaTxnNetworkFeeOptionsReturn>

  getMetaTransactions(req: GetMetaTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTransactionsReturn>

  getTransactionCost(req: GetTransactionCostArgs, headers?: object, signal?: AbortSignal): Promise<GetTransactionCostReturn>

  /**
   * Sent transactions from an account. If filter is omitted then it will return all transactions.
   */
  sentTransactions(req: SentTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<SentTransactionsReturn>

  /**
   * Pending transactions waiting to be mined for an account. This endpoint is just a sugar of `SentTransactions`
   * with the filter set to pending: true.
   */
  pendingTransactions(req: PendingTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<PendingTransactionsReturn>

  /**
   * Legacy Gas Tank
   */
  getGasTank(req: GetGasTankArgs, headers?: object, signal?: AbortSignal): Promise<GetGasTankReturn>

  addGasTank(req: AddGasTankArgs, headers?: object, signal?: AbortSignal): Promise<AddGasTankReturn>

  updateGasTank(req: UpdateGasTankArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasTankReturn>

  /**
   * Legacy Gas Adjustment
   */
  nextGasTankBalanceAdjustmentNonce(
    req: NextGasTankBalanceAdjustmentNonceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<NextGasTankBalanceAdjustmentNonceReturn>

  adjustGasTankBalance(req: AdjustGasTankBalanceArgs, headers?: object, signal?: AbortSignal): Promise<AdjustGasTankBalanceReturn>

  getGasTankBalanceAdjustment(
    req: GetGasTankBalanceAdjustmentArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetGasTankBalanceAdjustmentReturn>

  listGasTankBalanceAdjustments(
    req: ListGasTankBalanceAdjustmentsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListGasTankBalanceAdjustmentsReturn>

  /**
   * Gas Sponsorship
   */
  listGasSponsors(req: ListGasSponsorsArgs, headers?: object, signal?: AbortSignal): Promise<ListGasSponsorsReturn>

  getGasSponsor(req: GetGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<GetGasSponsorReturn>

  addGasSponsor(req: AddGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<AddGasSponsorReturn>

  updateGasSponsor(req: UpdateGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasSponsorReturn>

  removeGasSponsor(req: RemoveGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<RemoveGasSponsorReturn>

  /**
   * Gas Sponsor Lookup
   */
  addressGasSponsors(req: AddressGasSponsorsArgs, headers?: object, signal?: AbortSignal): Promise<AddressGasSponsorsReturn>

  /**
   * Project Balance
   */
  getProjectBalance(req: GetProjectBalanceArgs, headers?: object, signal?: AbortSignal): Promise<GetProjectBalanceReturn>

  adjustProjectBalance(req: AdjustProjectBalanceArgs, headers?: object, signal?: AbortSignal): Promise<AdjustProjectBalanceReturn>
}

//
// Schema types
//

export enum ETHTxnStatus {
  UNKNOWN = 'UNKNOWN',
  DROPPED = 'DROPPED',
  QUEUED = 'QUEUED',
  SENT = 'SENT',
  SUCCEEDED = 'SUCCEEDED',
  PARTIALLY_FAILED = 'PARTIALLY_FAILED',
  FAILED = 'FAILED',
  PENDING_PRECONDITION = 'PENDING_PRECONDITION'
}

export enum TransferType {
  SEND = 'SEND',
  RECEIVE = 'RECEIVE',
  BRIDGE_DEPOSIT = 'BRIDGE_DEPOSIT',
  BRIDGE_WITHDRAW = 'BRIDGE_WITHDRAW',
  BURN = 'BURN',
  UNKNOWN = 'UNKNOWN'
}

export enum SimulateStatus {
  SKIPPED = 'SKIPPED',
  SUCCEEDED = 'SUCCEEDED',
  FAILED = 'FAILED',
  ABORTED = 'ABORTED',
  REVERTED = 'REVERTED',
  NOT_ENOUGH_GAS = 'NOT_ENOUGH_GAS'
}

export enum FeeTokenType {
  UNKNOWN = 'UNKNOWN',
  ERC20_TOKEN = 'ERC20_TOKEN',
  ERC1155_TOKEN = 'ERC1155_TOKEN'
}

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  chainID: number
  useEIP1559: boolean
  senders: Array<SenderStatus>
  checks: RuntimeChecks
}

export interface SenderStatus {
  index: number
  address: string
  etherBalance: number
  active: boolean
}

export interface RuntimeChecks {}

export interface SequenceContext {
  factory: string
  mainModule: string
  mainModuleUpgradable: string
  guestModule: string
  utils: string
}

export interface GasTank {
  id: number
  chainId: number
  name: string
  currentBalance: number
  unlimited: boolean
  feeMarkupFactor: number
  updatedAt: string
  createdAt: string
}

export interface GasTankBalanceAdjustment {
  gasTankId: number
  nonce: number
  amount: number
  totalBalance: number
  balanceTimestamp: string
  createdAt: string
}

export interface GasSponsor {
  id: number
  gasTankId: number
  projectId: number
  chainId: number
  address: string
  name: string
  active: boolean
  updatedAt: string
  createdAt: string
  deletedAt: string
}

export interface GasSponsorUsage {
  name: string
  id: number
  totalGasUsed: number
  totalTxnFees: number
  totalTxnFeesUsd: number
  avgGasPrice: number
  totalTxns: number
  startTime: string
  endTime: string
}

export interface MetaTxn {
  walletAddress: string
  contract: string
  input: string
}

export interface MetaTxnLog {
  id: number
  chainId: number
  projectId: number
  txnHash: string
  txnNonce: string
  metaTxnID?: string
  txnStatus: ETHTxnStatus
  txnRevertReason: string
  requeues: number
  queuedAt: string
  sentAt: string
  minedAt: string
  target: string
  input: string
  txnArgs: { [key: string]: any }
  txnReceipt?: { [key: string]: any }
  walletAddress: string
  metaTxnNonce: string
  gasLimit: number
  gasPrice: string
  gasUsed: number
  gasEstimated: number
  gasFeeMarkup?: number
  usdRate: string
  creditsUsed: number
  cost: string
  isWhitelisted: boolean
  gasSponsor?: number
  gasTank?: number
  updatedAt: string
  createdAt: string
}

export interface MetaTxnReceipt {
  id: string
  status: string
  revertReason?: string
  index: number
  logs: Array<MetaTxnReceiptLog>
  receipts: Array<MetaTxnReceipt>
  blockNumber: string
  txnHash: string
  txnReceipt: string
}

export interface MetaTxnReceiptLog {
  address: string
  topics: Array<string>
  data: string
}

export interface IntentPrecondition {
  type: string
  chainId: string
  data: any
}

export interface IntentSolution {
  transactions: Array<Transactions>
}

export interface Transactions {
  chainID: string
  transactions: Array<Transaction>
  preconditions?: Array<IntentPrecondition>
}

export interface Transaction {
  delegateCall: boolean
  revertOnError: boolean
  gasLimit: string
  target: string
  value: string
  data: string
}

export interface TxnLogUser {
  username: string
}

export interface TxnLogTransfer {
  transferType: TransferType
  contractAddress: string
  from: string
  to: string
  ids: Array<string>
  amounts: Array<string>
}

export interface SentTransactionsFilter {
  pending?: boolean
  failed?: boolean
}

export interface SimulateResult {
  executed: boolean
  succeeded: boolean
  result?: string
  reason?: string
  gasUsed: number
  gasLimit: number
}

export interface SimulateV3Result {
  status: SimulateStatus
  result?: string
  error?: string
  gasUsed: number
  gasLimit: number
}

export interface FeeOption {
  token: FeeToken
  to: string
  value: string
  gasLimit: number
}

export interface FeeToken {
  chainId: number
  name: string
  symbol: string
  type: FeeTokenType
  decimals?: number
  logoURL: string
  contractAddress?: string
  tokenID?: string
}

export interface Page {
  pageSize?: number
  page?: number
  more?: boolean
  totalRecords?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface PingArgs {}

export interface PingReturn {
  status: boolean
}

export interface VersionArgs {}

export interface VersionReturn {
  version: Version
}

export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: RuntimeStatus
}

export interface GetSequenceContextArgs {}

export interface GetSequenceContextReturn {
  data: SequenceContext
}

export interface GetChainIDArgs {}

export interface GetChainIDReturn {
  chainID: number
}

export interface SendMetaTxnArgs {
  call: MetaTxn
  quote?: string
  projectID?: number
  preconditions?: Array<IntentPrecondition>
}

export interface SendMetaTxnReturn {
  status: boolean
  txnHash: string
}

export interface GetMetaTxnNonceArgs {
  walletContractAddress: string
  space?: string
}

export interface GetMetaTxnNonceReturn {
  nonce: string
}

export interface GetMetaTxnReceiptArgs {
  metaTxID: string
}

export interface GetMetaTxnReceiptReturn {
  receipt: MetaTxnReceipt
}

export interface SimulateArgs {
  wallet: string
  transactions: string
}

export interface SimulateReturn {
  results: Array<SimulateResult>
}

export interface SimulateV3Args {
  wallet: string
  calls: string
}

export interface SimulateV3Return {
  results: Array<SimulateV3Result>
}

export interface UpdateMetaTxnGasLimitsArgs {
  walletAddress: string
  walletConfig: any
  payload: string
}

export interface UpdateMetaTxnGasLimitsReturn {
  payload: string
}

export interface FeeTokensArgs {}

export interface FeeTokensReturn {
  isFeeRequired: boolean
  tokens: Array<FeeToken>
  paymentAddress: string
}

export interface FeeOptionsArgs {
  wallet: string
  to: string
  data: string
  simulate?: boolean
}

export interface FeeOptionsReturn {
  options: Array<FeeOption>
  sponsored: boolean
  quote?: string
}

export interface GetMetaTxnNetworkFeeOptionsArgs {
  walletConfig: any
  payload: string
}

export interface GetMetaTxnNetworkFeeOptionsReturn {
  options: Array<FeeOption>
}

export interface GetMetaTransactionsArgs {
  projectId: number
  page?: Page
}

export interface GetMetaTransactionsReturn {
  page: Page
  transactions: Array<MetaTxnLog>
}

export interface GetTransactionCostArgs {
  projectId: number
  from: string
  to: string
}

export interface GetTransactionCostReturn {
  cost: number
}

export interface SentTransactionsArgs {
  filter?: SentTransactionsFilter
  page?: Page
}

export interface SentTransactionsReturn {
  page: Page
  transactions: Array<Transaction>
}

export interface PendingTransactionsArgs {
  page?: Page
}

export interface PendingTransactionsReturn {
  page: Page
  transactions: Array<Transaction>
}

export interface GetGasTankArgs {
  id: number
}

export interface GetGasTankReturn {
  gasTank: GasTank
}

export interface AddGasTankArgs {
  name: string
  feeMarkupFactor: number
  unlimited?: boolean
}

export interface AddGasTankReturn {
  status: boolean
  gasTank: GasTank
}

export interface UpdateGasTankArgs {
  id: number
  name?: string
  feeMarkupFactor?: number
  unlimited?: boolean
}

export interface UpdateGasTankReturn {
  status: boolean
  gasTank: GasTank
}

export interface NextGasTankBalanceAdjustmentNonceArgs {
  id: number
}

export interface NextGasTankBalanceAdjustmentNonceReturn {
  nonce: number
}

export interface AdjustGasTankBalanceArgs {
  id: number
  nonce: number
  amount: number
}

export interface AdjustGasTankBalanceReturn {
  status: boolean
  adjustment: GasTankBalanceAdjustment
}

export interface GetGasTankBalanceAdjustmentArgs {
  id: number
  nonce: number
}

export interface GetGasTankBalanceAdjustmentReturn {
  adjustment: GasTankBalanceAdjustment
}

export interface ListGasTankBalanceAdjustmentsArgs {
  id: number
  page?: Page
}

export interface ListGasTankBalanceAdjustmentsReturn {
  page: Page
  adjustments: Array<GasTankBalanceAdjustment>
}

export interface ListGasSponsorsArgs {
  projectId: number
  page?: Page
}

export interface ListGasSponsorsReturn {
  page: Page
  gasSponsors: Array<GasSponsor>
}

export interface GetGasSponsorArgs {
  projectId: number
  id: number
}

export interface GetGasSponsorReturn {
  gasSponsor: GasSponsor
}

export interface AddGasSponsorArgs {
  projectId: number
  address: string
  name?: string
  active?: boolean
}

export interface AddGasSponsorReturn {
  status: boolean
  gasSponsor: GasSponsor
}

export interface UpdateGasSponsorArgs {
  projectId: number
  id: number
  name?: string
  active?: boolean
}

export interface UpdateGasSponsorReturn {
  status: boolean
  gasSponsor: GasSponsor
}

export interface RemoveGasSponsorArgs {
  projectId: number
  id: number
}

export interface RemoveGasSponsorReturn {
  status: boolean
}

export interface AddressGasSponsorsArgs {
  address: string
  page?: Page
}

export interface AddressGasSponsorsReturn {
  page: Page
  gasSponsors: Array<GasSponsor>
}

export interface GetProjectBalanceArgs {
  projectId: number
}

export interface GetProjectBalanceReturn {
  balance: number
}

export interface AdjustProjectBalanceArgs {
  projectId: number
  amount: number
  identifier: string
}

export interface AdjustProjectBalanceReturn {
  balance: number
}

//
// Client
//

export class Relayer implements RelayerClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Relayer/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  queryKey = {
    ping: () => ['Relayer', 'ping'] as const,
    version: () => ['Relayer', 'version'] as const,
    runtimeStatus: () => ['Relayer', 'runtimeStatus'] as const,
    getSequenceContext: () => ['Relayer', 'getSequenceContext'] as const,
    getChainID: () => ['Relayer', 'getChainID'] as const,
    sendMetaTxn: (req: SendMetaTxnArgs) => ['Relayer', 'sendMetaTxn', req] as const,
    getMetaTxnNonce: (req: GetMetaTxnNonceArgs) => ['Relayer', 'getMetaTxnNonce', req] as const,
    getMetaTxnReceipt: (req: GetMetaTxnReceiptArgs) => ['Relayer', 'getMetaTxnReceipt', req] as const,
    simulate: (req: SimulateArgs) => ['Relayer', 'simulate', req] as const,
    simulateV3: (req: SimulateV3Args) => ['Relayer', 'simulateV3', req] as const,
    updateMetaTxnGasLimits: (req: UpdateMetaTxnGasLimitsArgs) => ['Relayer', 'updateMetaTxnGasLimits', req] as const,
    feeTokens: () => ['Relayer', 'feeTokens'] as const,
    feeOptions: (req: FeeOptionsArgs) => ['Relayer', 'feeOptions', req] as const,
    getMetaTxnNetworkFeeOptions: (req: GetMetaTxnNetworkFeeOptionsArgs) =>
      ['Relayer', 'getMetaTxnNetworkFeeOptions', req] as const,
    getMetaTransactions: (req: GetMetaTransactionsArgs) => ['Relayer', 'getMetaTransactions', req] as const,
    getTransactionCost: (req: GetTransactionCostArgs) => ['Relayer', 'getTransactionCost', req] as const,
    sentTransactions: (req: SentTransactionsArgs) => ['Relayer', 'sentTransactions', req] as const,
    pendingTransactions: (req: PendingTransactionsArgs) => ['Relayer', 'pendingTransactions', req] as const,
    getGasTank: (req: GetGasTankArgs) => ['Relayer', 'getGasTank', req] as const,
    addGasTank: (req: AddGasTankArgs) => ['Relayer', 'addGasTank', req] as const,
    updateGasTank: (req: UpdateGasTankArgs) => ['Relayer', 'updateGasTank', req] as const,
    nextGasTankBalanceAdjustmentNonce: (req: NextGasTankBalanceAdjustmentNonceArgs) =>
      ['Relayer', 'nextGasTankBalanceAdjustmentNonce', req] as const,
    adjustGasTankBalance: (req: AdjustGasTankBalanceArgs) => ['Relayer', 'adjustGasTankBalance', req] as const,
    getGasTankBalanceAdjustment: (req: GetGasTankBalanceAdjustmentArgs) =>
      ['Relayer', 'getGasTankBalanceAdjustment', req] as const,
    listGasTankBalanceAdjustments: (req: ListGasTankBalanceAdjustmentsArgs) =>
      ['Relayer', 'listGasTankBalanceAdjustments', req] as const,
    listGasSponsors: (req: ListGasSponsorsArgs) => ['Relayer', 'listGasSponsors', req] as const,
    getGasSponsor: (req: GetGasSponsorArgs) => ['Relayer', 'getGasSponsor', req] as const,
    addGasSponsor: (req: AddGasSponsorArgs) => ['Relayer', 'addGasSponsor', req] as const,
    updateGasSponsor: (req: UpdateGasSponsorArgs) => ['Relayer', 'updateGasSponsor', req] as const,
    removeGasSponsor: (req: RemoveGasSponsorArgs) => ['Relayer', 'removeGasSponsor', req] as const,
    addressGasSponsors: (req: AddressGasSponsorsArgs) => ['Relayer', 'addressGasSponsors', req] as const,
    getProjectBalance: (req: GetProjectBalanceArgs) => ['Relayer', 'getProjectBalance', req] as const,
    adjustProjectBalance: (req: AdjustProjectBalanceArgs) => ['Relayer', 'adjustProjectBalance', req] as const
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PingReturn>(_data, 'PingReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {
    return this.fetch(this.url('Version'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<VersionReturn>(_data, 'VersionReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {
    return this.fetch(this.url('RuntimeStatus'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RuntimeStatusReturn>(_data, 'RuntimeStatusReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getSequenceContext = (headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn> => {
    return this.fetch(this.url('GetSequenceContext'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetSequenceContextReturn>(_data, 'GetSequenceContextReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getChainID = (headers?: object, signal?: AbortSignal): Promise<GetChainIDReturn> => {
    return this.fetch(this.url('GetChainID'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetChainIDReturn>(_data, 'GetChainIDReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  sendMetaTxn = (req: SendMetaTxnArgs, headers?: object, signal?: AbortSignal): Promise<SendMetaTxnReturn> => {
    return this.fetch(this.url('SendMetaTxn'), createHttpRequest(JsonEncode(req, 'SendMetaTxnArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SendMetaTxnReturn>(_data, 'SendMetaTxnReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getMetaTxnNonce = (req: GetMetaTxnNonceArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnNonceReturn> => {
    return this.fetch(
      this.url('GetMetaTxnNonce'),
      createHttpRequest(JsonEncode(req, 'GetMetaTxnNonceArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetMetaTxnNonceReturn>(_data, 'GetMetaTxnNonceReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getMetaTxnReceipt = (req: GetMetaTxnReceiptArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnReceiptReturn> => {
    return this.fetch(
      this.url('GetMetaTxnReceipt'),
      createHttpRequest(JsonEncode(req, 'GetMetaTxnReceiptArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetMetaTxnReceiptReturn>(_data, 'GetMetaTxnReceiptReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  simulate = (req: SimulateArgs, headers?: object, signal?: AbortSignal): Promise<SimulateReturn> => {
    return this.fetch(this.url('Simulate'), createHttpRequest(JsonEncode(req, 'SimulateArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SimulateReturn>(_data, 'SimulateReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  simulateV3 = (req: SimulateV3Args, headers?: object, signal?: AbortSignal): Promise<SimulateV3Return> => {
    return this.fetch(this.url('SimulateV3'), createHttpRequest(JsonEncode(req, 'SimulateV3Args'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SimulateV3Return>(_data, 'SimulateV3Return')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  updateMetaTxnGasLimits = (
    req: UpdateMetaTxnGasLimitsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateMetaTxnGasLimitsReturn> => {
    return this.fetch(
      this.url('UpdateMetaTxnGasLimits'),
      createHttpRequest(JsonEncode(req, 'UpdateMetaTxnGasLimitsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UpdateMetaTxnGasLimitsReturn>(_data, 'UpdateMetaTxnGasLimitsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  feeTokens = (headers?: object, signal?: AbortSignal): Promise<FeeTokensReturn> => {
    return this.fetch(this.url('FeeTokens'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<FeeTokensReturn>(_data, 'FeeTokensReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  feeOptions = (req: FeeOptionsArgs, headers?: object, signal?: AbortSignal): Promise<FeeOptionsReturn> => {
    return this.fetch(this.url('FeeOptions'), createHttpRequest(JsonEncode(req, 'FeeOptionsArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<FeeOptionsReturn>(_data, 'FeeOptionsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getMetaTxnNetworkFeeOptions = (
    req: GetMetaTxnNetworkFeeOptionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMetaTxnNetworkFeeOptionsReturn> => {
    return this.fetch(
      this.url('GetMetaTxnNetworkFeeOptions'),
      createHttpRequest(JsonEncode(req, 'GetMetaTxnNetworkFeeOptionsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetMetaTxnNetworkFeeOptionsReturn>(_data, 'GetMetaTxnNetworkFeeOptionsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getMetaTransactions = (
    req: GetMetaTransactionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMetaTransactionsReturn> => {
    return this.fetch(
      this.url('GetMetaTransactions'),
      createHttpRequest(JsonEncode(req, 'GetMetaTransactionsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetMetaTransactionsReturn>(_data, 'GetMetaTransactionsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTransactionCost = (
    req: GetTransactionCostArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTransactionCostReturn> => {
    return this.fetch(
      this.url('GetTransactionCost'),
      createHttpRequest(JsonEncode(req, 'GetTransactionCostArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTransactionCostReturn>(_data, 'GetTransactionCostReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  sentTransactions = (req: SentTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<SentTransactionsReturn> => {
    return this.fetch(
      this.url('SentTransactions'),
      createHttpRequest(JsonEncode(req, 'SentTransactionsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SentTransactionsReturn>(_data, 'SentTransactionsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  pendingTransactions = (
    req: PendingTransactionsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<PendingTransactionsReturn> => {
    return this.fetch(
      this.url('PendingTransactions'),
      createHttpRequest(JsonEncode(req, 'PendingTransactionsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PendingTransactionsReturn>(_data, 'PendingTransactionsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getGasTank = (req: GetGasTankArgs, headers?: object, signal?: AbortSignal): Promise<GetGasTankReturn> => {
    return this.fetch(this.url('GetGasTank'), createHttpRequest(JsonEncode(req, 'GetGasTankArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetGasTankReturn>(_data, 'GetGasTankReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  addGasTank = (req: AddGasTankArgs, headers?: object, signal?: AbortSignal): Promise<AddGasTankReturn> => {
    return this.fetch(this.url('AddGasTank'), createHttpRequest(JsonEncode(req, 'AddGasTankArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AddGasTankReturn>(_data, 'AddGasTankReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  updateGasTank = (req: UpdateGasTankArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasTankReturn> => {
    return this.fetch(this.url('UpdateGasTank'), createHttpRequest(JsonEncode(req, 'UpdateGasTankArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UpdateGasTankReturn>(_data, 'UpdateGasTankReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  nextGasTankBalanceAdjustmentNonce = (
    req: NextGasTankBalanceAdjustmentNonceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<NextGasTankBalanceAdjustmentNonceReturn> => {
    return this.fetch(
      this.url('NextGasTankBalanceAdjustmentNonce'),
      createHttpRequest(JsonEncode(req, 'NextGasTankBalanceAdjustmentNonceArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<NextGasTankBalanceAdjustmentNonceReturn>(_data, 'NextGasTankBalanceAdjustmentNonceReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  adjustGasTankBalance = (
    req: AdjustGasTankBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdjustGasTankBalanceReturn> => {
    return this.fetch(
      this.url('AdjustGasTankBalance'),
      createHttpRequest(JsonEncode(req, 'AdjustGasTankBalanceArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AdjustGasTankBalanceReturn>(_data, 'AdjustGasTankBalanceReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getGasTankBalanceAdjustment = (
    req: GetGasTankBalanceAdjustmentArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetGasTankBalanceAdjustmentReturn> => {
    return this.fetch(
      this.url('GetGasTankBalanceAdjustment'),
      createHttpRequest(JsonEncode(req, 'GetGasTankBalanceAdjustmentArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetGasTankBalanceAdjustmentReturn>(_data, 'GetGasTankBalanceAdjustmentReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  listGasTankBalanceAdjustments = (
    req: ListGasTankBalanceAdjustmentsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListGasTankBalanceAdjustmentsReturn> => {
    return this.fetch(
      this.url('ListGasTankBalanceAdjustments'),
      createHttpRequest(JsonEncode(req, 'ListGasTankBalanceAdjustmentsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ListGasTankBalanceAdjustmentsReturn>(_data, 'ListGasTankBalanceAdjustmentsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  listGasSponsors = (req: ListGasSponsorsArgs, headers?: object, signal?: AbortSignal): Promise<ListGasSponsorsReturn> => {
    return this.fetch(
      this.url('ListGasSponsors'),
      createHttpRequest(JsonEncode(req, 'ListGasSponsorsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ListGasSponsorsReturn>(_data, 'ListGasSponsorsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getGasSponsor = (req: GetGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<GetGasSponsorReturn> => {
    return this.fetch(this.url('GetGasSponsor'), createHttpRequest(JsonEncode(req, 'GetGasSponsorArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetGasSponsorReturn>(_data, 'GetGasSponsorReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  addGasSponsor = (req: AddGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<AddGasSponsorReturn> => {
    return this.fetch(this.url('AddGasSponsor'), createHttpRequest(JsonEncode(req, 'AddGasSponsorArgs'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AddGasSponsorReturn>(_data, 'AddGasSponsorReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  updateGasSponsor = (req: UpdateGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasSponsorReturn> => {
    return this.fetch(
      this.url('UpdateGasSponsor'),
      createHttpRequest(JsonEncode(req, 'UpdateGasSponsorArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UpdateGasSponsorReturn>(_data, 'UpdateGasSponsorReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  removeGasSponsor = (req: RemoveGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<RemoveGasSponsorReturn> => {
    return this.fetch(
      this.url('RemoveGasSponsor'),
      createHttpRequest(JsonEncode(req, 'RemoveGasSponsorArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RemoveGasSponsorReturn>(_data, 'RemoveGasSponsorReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  addressGasSponsors = (
    req: AddressGasSponsorsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddressGasSponsorsReturn> => {
    return this.fetch(
      this.url('AddressGasSponsors'),
      createHttpRequest(JsonEncode(req, 'AddressGasSponsorsArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AddressGasSponsorsReturn>(_data, 'AddressGasSponsorsReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getProjectBalance = (req: GetProjectBalanceArgs, headers?: object, signal?: AbortSignal): Promise<GetProjectBalanceReturn> => {
    return this.fetch(
      this.url('GetProjectBalance'),
      createHttpRequest(JsonEncode(req, 'GetProjectBalanceArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetProjectBalanceReturn>(_data, 'GetProjectBalanceReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  adjustProjectBalance = (
    req: AdjustProjectBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AdjustProjectBalanceReturn> => {
    return this.fetch(
      this.url('AdjustProjectBalance'),
      createHttpRequest(JsonEncode(req, 'AdjustProjectBalanceArgs'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AdjustProjectBalanceReturn>(_data, 'AdjustProjectBalanceReturn')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }
}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>

export const JsonEncode = <T = any>(obj: T, _typ: string = ''): string => {
  return JSON.stringify(obj)
}

export const JsonDecode = <T = any>(data: string | any, _typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try {
      parsed = JSON.parse(data)
    } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return parsed as T
}

//
// Errors
//

type WebrpcErrorParams = { name?: string; code?: number; message?: string; status?: number; cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}

export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class AbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Aborted'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request aborted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Rate-limited. Please slow down.`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1008
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1101
    this.message = error.message || `Access key not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyMismatch'
    this.code = typeof error.code === 'number' ? error.code : 1102
    this.message = error.message || `Access key mismatch`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidOrigin'
    this.code = typeof error.code === 'number' ? error.code : 1103
    this.message = error.message || `Invalid origin for Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidService'
    this.code = typeof error.code === 'number' ? error.code : 1104
    this.message = error.message || `Service not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnauthorizedUser'
    this.code = typeof error.code === 'number' ? error.code : 1105
    this.message = error.message || `Unauthorized user`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaExceeded'
    this.code = typeof error.code === 'number' ? error.code : 1200
    this.message = error.message || `Quota request exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class QuotaRateLimitError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaRateLimit'
    this.code = typeof error.code === 'number' ? error.code : 1201
    this.message = error.message || `Quota rate limit exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaRateLimitError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NoDefaultKey'
    this.code = typeof error.code === 'number' ? error.code : 1300
    this.message = error.message || `No default access key found`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MaxAccessKeys'
    this.code = typeof error.code === 'number' ? error.code : 1301
    this.message = error.message || `Access keys limit reached`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AtLeastOneKey'
    this.code = typeof error.code === 'number' ? error.code : 1302
    this.message = error.message || `You need at least one Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 1900
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidArgument'
    this.code = typeof error.code === 'number' ? error.code : 2001
    this.message = error.message || `Invalid argument`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class UnavailableError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unavailable'
    this.code = typeof error.code === 'number' ? error.code : 2002
    this.message = error.message || `Unavailable resource`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnavailableError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QueryFailed'
    this.code = typeof error.code === 'number' ? error.code : 2003
    this.message = error.message || `Query failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotFound'
    this.code = typeof error.code === 'number' ? error.code : 3000
    this.message = error.message || `Resource not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class InsufficientFeeError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InsufficientFee'
    this.code = typeof error.code === 'number' ? error.code : 3004
    this.message = error.message || `Insufficient fee`
    this.status = typeof error.status === 'number' ? error.status : 402
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InsufficientFeeError.prototype)
  }
}

export class NotEnoughBalanceError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotEnoughBalance'
    this.code = typeof error.code === 'number' ? error.code : 3005
    this.message = error.message || `Not enough balance`
    this.status = typeof error.status === 'number' ? error.status : 402
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotEnoughBalanceError.prototype)
  }
}

export class SimulationFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SimulationFailed'
    this.code = typeof error.code === 'number' ? error.code : 3006
    this.message = error.message || `Simulation failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SimulationFailedError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Aborted = 'Aborted',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  ProjectNotFound = 'ProjectNotFound',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AccessKeyMismatch = 'AccessKeyMismatch',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  UnauthorizedUser = 'UnauthorizedUser',
  QuotaExceeded = 'QuotaExceeded',
  QuotaRateLimit = 'QuotaRateLimit',
  NoDefaultKey = 'NoDefaultKey',
  MaxAccessKeys = 'MaxAccessKeys',
  AtLeastOneKey = 'AtLeastOneKey',
  Timeout = 'Timeout',
  InvalidArgument = 'InvalidArgument',
  Unavailable = 'Unavailable',
  QueryFailed = 'QueryFailed',
  NotFound = 'NotFound',
  InsufficientFee = 'InsufficientFee',
  NotEnoughBalance = 'NotEnoughBalance',
  SimulationFailed = 'SimulationFailed'
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Aborted = 1005,
  Geoblocked = 1006,
  RateLimited = 1007,
  ProjectNotFound = 1008,
  AccessKeyNotFound = 1101,
  AccessKeyMismatch = 1102,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  UnauthorizedUser = 1105,
  QuotaExceeded = 1200,
  QuotaRateLimit = 1201,
  NoDefaultKey = 1300,
  MaxAccessKeys = 1301,
  AtLeastOneKey = 1302,
  Timeout = 1900,
  InvalidArgument = 2001,
  Unavailable = 2002,
  QueryFailed = 2003,
  NotFound = 3000,
  InsufficientFee = 3004,
  NotEnoughBalance = 3005,
  SimulationFailed = 3006
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [1006]: GeoblockedError,
  [1007]: RateLimitedError,
  [1008]: ProjectNotFoundError,
  [1101]: AccessKeyNotFoundError,
  [1102]: AccessKeyMismatchError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1105]: UnauthorizedUserError,
  [1200]: QuotaExceededError,
  [1201]: QuotaRateLimitError,
  [1300]: NoDefaultKeyError,
  [1301]: MaxAccessKeysError,
  [1302]: AtLeastOneKeyError,
  [1900]: TimeoutError,
  [2001]: InvalidArgumentError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [3000]: NotFoundError,
  [3004]: InsufficientFeeError,
  [3005]: NotEnoughBalanceError,
  [3006]: SimulationFailedError
}

//
// Webrpc
//

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.30.1;gen-typescript@v0.22.0;sequence-relayer@v0.4.1'

type WebrpcGenVersions = {
  WebrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  const [_, WebrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? ''
  }
}
