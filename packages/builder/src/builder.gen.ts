// sequence-builder v0.1.0 c6c429cc43bcc804043939b6d3afeeb4f898d91e
// --
// Code generated by webrpc-gen@v0.24.0 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=builder.main.ridl -target=golang -pkg=builder -client -json=sonic -out=./clients/builder.gen.go
package builder

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"cloud.google.com/go/civil"
	"github.com/0xsequence/go-sequence/lib/prototyp"
	"github.com/0xsequence/go-sequence/metadata"
	"github.com/bytedance/sonic"
	"github.com/goware/validation"
	"github.com/shopspring/decimal"
)

// Opinionated config for -json=sonic, see https://github.com/bytedance/sonic/blob/main/api.go.
var jsonCfg = sonic.Config{
	NoNullSliceOrMap: true, // Encode empty Array or Object as '[]' or '{}' instead of 'null'.
	CompactMarshaler: true,
	CopyString:       true,
	ValidateString:   true,
}.Froze()

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.24.0;gen-golang@v0.18.2;sequence-builder@v0.1.0"

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.1.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "c6c429cc43bcc804043939b6d3afeeb4f898d91e"
}

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}

//
// Common types
//

type AuthSessionType uint16

const (
	AuthSessionType_PUBLIC  AuthSessionType = 0
	AuthSessionType_WALLET  AuthSessionType = 1
	AuthSessionType_USER    AuthSessionType = 2
	AuthSessionType_ADMIN   AuthSessionType = 3
	AuthSessionType_SERVICE AuthSessionType = 4
)

var AuthSessionType_name = map[uint16]string{
	0: "PUBLIC",
	1: "WALLET",
	2: "USER",
	3: "ADMIN",
	4: "SERVICE",
}

var AuthSessionType_value = map[string]uint16{
	"PUBLIC":  0,
	"WALLET":  1,
	"USER":    2,
	"ADMIN":   3,
	"SERVICE": 4,
}

func (x AuthSessionType) String() string {
	return AuthSessionType_name[uint16(x)]
}

func (x AuthSessionType) MarshalText() ([]byte, error) {
	return []byte(AuthSessionType_name[uint16(x)]), nil
}

func (x *AuthSessionType) UnmarshalText(b []byte) error {
	*x = AuthSessionType(AuthSessionType_value[string(b)])
	return nil
}

func (x *AuthSessionType) Is(values ...AuthSessionType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SubscriptionTier uint8

const (
	// free tier
	SubscriptionTier_COMMUNITY SubscriptionTier = 0
	// paid tier
	SubscriptionTier_DEVELOPER SubscriptionTier = 1
	// paid tier
	SubscriptionTier_GROWTH SubscriptionTier = 2
	// paid tier
	SubscriptionTier_PRO SubscriptionTier = 3
	// paid tier
	SubscriptionTier_ENTERPRISE SubscriptionTier = 4
	// sponsored tier
	SubscriptionTier_ECOSYSTEM SubscriptionTier = 5
)

var SubscriptionTier_name = map[uint8]string{
	0: "COMMUNITY",
	1: "DEVELOPER",
	2: "GROWTH",
	3: "PRO",
	4: "ENTERPRISE",
	5: "ECOSYSTEM",
}

var SubscriptionTier_value = map[string]uint8{
	"COMMUNITY":  0,
	"DEVELOPER":  1,
	"GROWTH":     2,
	"PRO":        3,
	"ENTERPRISE": 4,
	"ECOSYSTEM":  5,
}

func (x SubscriptionTier) String() string {
	return SubscriptionTier_name[uint8(x)]
}

func (x SubscriptionTier) MarshalText() ([]byte, error) {
	return []byte(SubscriptionTier_name[uint8(x)]), nil
}

func (x *SubscriptionTier) UnmarshalText(b []byte) error {
	*x = SubscriptionTier(SubscriptionTier_value[string(b)])
	return nil
}

func (x *SubscriptionTier) Is(values ...SubscriptionTier) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ProjectType string

const (
	ProjectType_EMBEDDED_WALLET_REACT  ProjectType = "EMBEDDED_WALLET_REACT"
	ProjectType_EMBEDDED_WALLET_NEXTJS ProjectType = "EMBEDDED_WALLET_NEXTJS"
	ProjectType_EMBEDDED_WALLET_UNITY  ProjectType = "EMBEDDED_WALLET_UNITY"
	ProjectType_EMBEDDED_WALLET_UNREAL ProjectType = "EMBEDDED_WALLET_UNREAL"
	ProjectType_MARKETPLACE_STANDALONE ProjectType = "MARKETPLACE_STANDALONE"
	ProjectType_MARKETPLACE_REACT      ProjectType = "MARKETPLACE_REACT"
	ProjectType_MARKETPLACE_UNITY      ProjectType = "MARKETPLACE_UNITY"
	ProjectType_MARKETPLACE_UNREAL     ProjectType = "MARKETPLACE_UNREAL"
	ProjectType_SALE_CONTRACT_ERC1155  ProjectType = "SALE_CONTRACT_ERC1155"
	ProjectType_SALE_CONTRACT_ERC721   ProjectType = "SALE_CONTRACT_ERC721"
	ProjectType_ALLOWLIST_STARTER      ProjectType = "ALLOWLIST_STARTER"
)

func (x ProjectType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *ProjectType) UnmarshalText(b []byte) error {
	*x = ProjectType(string(b))
	return nil
}

func (x *ProjectType) Is(values ...ProjectType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ResourceType int8

const (
	ResourceType_CONTRACTS ResourceType = 0
)

var ResourceType_name = map[int8]string{
	0: "CONTRACTS",
}

var ResourceType_value = map[string]int8{
	"CONTRACTS": 0,
}

func (x ResourceType) String() string {
	return ResourceType_name[int8(x)]
}

func (x ResourceType) MarshalText() ([]byte, error) {
	return []byte(ResourceType_name[int8(x)]), nil
}

func (x *ResourceType) UnmarshalText(b []byte) error {
	*x = ResourceType(ResourceType_value[string(b)])
	return nil
}

func (x *ResourceType) Is(values ...ResourceType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SubscriptionProvider string

const (
	SubscriptionProvider_ADMIN     SubscriptionProvider = "ADMIN"
	SubscriptionProvider_STRIPE    SubscriptionProvider = "STRIPE"
	SubscriptionProvider_GOOGLE    SubscriptionProvider = "GOOGLE"
	SubscriptionProvider_ECOSYSTEM SubscriptionProvider = "ECOSYSTEM"
)

func (x SubscriptionProvider) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *SubscriptionProvider) UnmarshalText(b []byte) error {
	*x = SubscriptionProvider(string(b))
	return nil
}

func (x *SubscriptionProvider) Is(values ...SubscriptionProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollaboratorAccess uint32

const (
	CollaboratorAccess_NONE  CollaboratorAccess = 0
	CollaboratorAccess_READ  CollaboratorAccess = 1
	CollaboratorAccess_WRITE CollaboratorAccess = 2
	CollaboratorAccess_ADMIN CollaboratorAccess = 3
)

var CollaboratorAccess_name = map[uint32]string{
	0: "NONE",
	1: "READ",
	2: "WRITE",
	3: "ADMIN",
}

var CollaboratorAccess_value = map[string]uint32{
	"NONE":  0,
	"READ":  1,
	"WRITE": 2,
	"ADMIN": 3,
}

func (x CollaboratorAccess) String() string {
	return CollaboratorAccess_name[uint32(x)]
}

func (x CollaboratorAccess) MarshalText() ([]byte, error) {
	return []byte(CollaboratorAccess_name[uint32(x)]), nil
}

func (x *CollaboratorAccess) UnmarshalText(b []byte) error {
	*x = CollaboratorAccess(CollaboratorAccess_value[string(b)])
	return nil
}

func (x *CollaboratorAccess) Is(values ...CollaboratorAccess) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollaboratorType uint8

const (
	CollaboratorType_USER            CollaboratorType = 0
	CollaboratorType_SERVICE_ACCOUNT CollaboratorType = 1
)

var CollaboratorType_name = map[uint8]string{
	0: "USER",
	1: "SERVICE_ACCOUNT",
}

var CollaboratorType_value = map[string]uint8{
	"USER":            0,
	"SERVICE_ACCOUNT": 1,
}

func (x CollaboratorType) String() string {
	return CollaboratorType_name[uint8(x)]
}

func (x CollaboratorType) MarshalText() ([]byte, error) {
	return []byte(CollaboratorType_name[uint8(x)]), nil
}

func (x *CollaboratorType) UnmarshalText(b []byte) error {
	*x = CollaboratorType(CollaboratorType_value[string(b)])
	return nil
}

func (x *CollaboratorType) Is(values ...CollaboratorType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ContractSourceType uint8

const (
	ContractSourceType_LINKED   ContractSourceType = 0
	ContractSourceType_DEPLOYED ContractSourceType = 1
)

var ContractSourceType_name = map[uint8]string{
	0: "LINKED",
	1: "DEPLOYED",
}

var ContractSourceType_value = map[string]uint8{
	"LINKED":   0,
	"DEPLOYED": 1,
}

func (x ContractSourceType) String() string {
	return ContractSourceType_name[uint8(x)]
}

func (x ContractSourceType) MarshalText() ([]byte, error) {
	return []byte(ContractSourceType_name[uint8(x)]), nil
}

func (x *ContractSourceType) UnmarshalText(b []byte) error {
	*x = ContractSourceType(ContractSourceType_value[string(b)])
	return nil
}

func (x *ContractSourceType) Is(values ...ContractSourceType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type PaymentProvider uint16

const (
	PaymentProvider_NONE   PaymentProvider = 0
	PaymentProvider_STRIPE PaymentProvider = 1
	PaymentProvider_ADMIN  PaymentProvider = 2
)

var PaymentProvider_name = map[uint16]string{
	0: "NONE",
	1: "STRIPE",
	2: "ADMIN",
}

var PaymentProvider_value = map[string]uint16{
	"NONE":   0,
	"STRIPE": 1,
	"ADMIN":  2,
}

func (x PaymentProvider) String() string {
	return PaymentProvider_name[uint16(x)]
}

func (x PaymentProvider) MarshalText() ([]byte, error) {
	return []byte(PaymentProvider_name[uint16(x)]), nil
}

func (x *PaymentProvider) UnmarshalText(b []byte) error {
	*x = PaymentProvider(PaymentProvider_value[string(b)])
	return nil
}

func (x *PaymentProvider) Is(values ...PaymentProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type PaymentStatus uint16

const (
	// before creating payment intent
	PaymentStatus_INITIATED PaymentStatus = 0
	// payment intent created
	PaymentStatus_PENDING PaymentStatus = 1
	// webhook received (success)
	PaymentStatus_SUCCEEDED PaymentStatus = 2
	// webhook received (failure)
	PaymentStatus_FAILED PaymentStatus = 3
	// relayer balance adjusted
	PaymentStatus_PROCESSED PaymentStatus = 4
)

var PaymentStatus_name = map[uint16]string{
	0: "INITIATED",
	1: "PENDING",
	2: "SUCCEEDED",
	3: "FAILED",
	4: "PROCESSED",
}

var PaymentStatus_value = map[string]uint16{
	"INITIATED": 0,
	"PENDING":   1,
	"SUCCEEDED": 2,
	"FAILED":    3,
	"PROCESSED": 4,
}

func (x PaymentStatus) String() string {
	return PaymentStatus_name[uint16(x)]
}

func (x PaymentStatus) MarshalText() ([]byte, error) {
	return []byte(PaymentStatus_name[uint16(x)]), nil
}

func (x *PaymentStatus) UnmarshalText(b []byte) error {
	*x = PaymentStatus(PaymentStatus_value[string(b)])
	return nil
}

func (x *PaymentStatus) Is(values ...PaymentStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type MarketplaceWallet uint8

const (
	MarketplaceWallet_UNIVERSAL MarketplaceWallet = 0
	MarketplaceWallet_EMBEDDED  MarketplaceWallet = 1
	MarketplaceWallet_ECOSYSTEM MarketplaceWallet = 2
)

var MarketplaceWallet_name = map[uint8]string{
	0: "UNIVERSAL",
	1: "EMBEDDED",
	2: "ECOSYSTEM",
}

var MarketplaceWallet_value = map[string]uint8{
	"UNIVERSAL": 0,
	"EMBEDDED":  1,
	"ECOSYSTEM": 2,
}

func (x MarketplaceWallet) String() string {
	return MarketplaceWallet_name[uint8(x)]
}

func (x MarketplaceWallet) MarshalText() ([]byte, error) {
	return []byte(MarketplaceWallet_name[uint8(x)]), nil
}

func (x *MarketplaceWallet) UnmarshalText(b []byte) error {
	*x = MarketplaceWallet(MarketplaceWallet_value[string(b)])
	return nil
}

func (x *MarketplaceWallet) Is(values ...MarketplaceWallet) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type MarketplaceType uint8

const (
	MarketplaceType_AMM       MarketplaceType = 0
	MarketplaceType_P2P       MarketplaceType = 1
	MarketplaceType_SEQUENCE  MarketplaceType = 2
	MarketplaceType_ORDERBOOK MarketplaceType = 3
)

var MarketplaceType_name = map[uint8]string{
	0: "AMM",
	1: "P2P",
	2: "SEQUENCE",
	3: "ORDERBOOK",
}

var MarketplaceType_value = map[string]uint8{
	"AMM":       0,
	"P2P":       1,
	"SEQUENCE":  2,
	"ORDERBOOK": 3,
}

func (x MarketplaceType) String() string {
	return MarketplaceType_name[uint8(x)]
}

func (x MarketplaceType) MarshalText() ([]byte, error) {
	return []byte(MarketplaceType_name[uint8(x)]), nil
}

func (x *MarketplaceType) UnmarshalText(b []byte) error {
	*x = MarketplaceType(MarketplaceType_value[string(b)])
	return nil
}

func (x *MarketplaceType) Is(values ...MarketplaceType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OrderbookKind string

const (
	OrderbookKind_unknown                 OrderbookKind = "unknown"
	OrderbookKind_sequence_marketplace_v1 OrderbookKind = "sequence_marketplace_v1"
	OrderbookKind_sequence_marketplace_v2 OrderbookKind = "sequence_marketplace_v2"
	OrderbookKind_blur                    OrderbookKind = "blur"
	OrderbookKind_opensea                 OrderbookKind = "opensea"
	OrderbookKind_looks_rare              OrderbookKind = "looks_rare"
	OrderbookKind_reservoir               OrderbookKind = "reservoir"
	OrderbookKind_x2y2                    OrderbookKind = "x2y2"
)

func (x OrderbookKind) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *OrderbookKind) UnmarshalText(b []byte) error {
	*x = OrderbookKind(string(b))
	return nil
}

func (x *OrderbookKind) Is(values ...OrderbookKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type FilterCondition string

const (
	FilterCondition_ENTIRE_KEY     FilterCondition = "ENTIRE_KEY"
	FilterCondition_SPECIFIC_VALUE FilterCondition = "SPECIFIC_VALUE"
)

func (x FilterCondition) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *FilterCondition) UnmarshalText(b []byte) error {
	*x = FilterCondition(string(b))
	return nil
}

func (x *FilterCondition) Is(values ...FilterCondition) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type AdminMarketplaceContractType uint16

const (
	AdminMarketplaceContractType_UNKNOWN AdminMarketplaceContractType = 0
	AdminMarketplaceContractType_ERC20   AdminMarketplaceContractType = 1
	AdminMarketplaceContractType_ERC721  AdminMarketplaceContractType = 2
	AdminMarketplaceContractType_ERC1155 AdminMarketplaceContractType = 3
)

var AdminMarketplaceContractType_name = map[uint16]string{
	0: "UNKNOWN",
	1: "ERC20",
	2: "ERC721",
	3: "ERC1155",
}

var AdminMarketplaceContractType_value = map[string]uint16{
	"UNKNOWN": 0,
	"ERC20":   1,
	"ERC721":  2,
	"ERC1155": 3,
}

func (x AdminMarketplaceContractType) String() string {
	return AdminMarketplaceContractType_name[uint16(x)]
}

func (x AdminMarketplaceContractType) MarshalText() ([]byte, error) {
	return []byte(AdminMarketplaceContractType_name[uint16(x)]), nil
}

func (x *AdminMarketplaceContractType) UnmarshalText(b []byte) error {
	*x = AdminMarketplaceContractType(AdminMarketplaceContractType_value[string(b)])
	return nil
}

func (x *AdminMarketplaceContractType) Is(values ...AdminMarketplaceContractType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type AdminCollectionPriority uint8

const (
	AdminCollectionPriority_unknown AdminCollectionPriority = 0
	AdminCollectionPriority_low     AdminCollectionPriority = 1
	AdminCollectionPriority_normal  AdminCollectionPriority = 2
	AdminCollectionPriority_high    AdminCollectionPriority = 3
)

var AdminCollectionPriority_name = map[uint8]string{
	0: "unknown",
	1: "low",
	2: "normal",
	3: "high",
}

var AdminCollectionPriority_value = map[string]uint8{
	"unknown": 0,
	"low":     1,
	"normal":  2,
	"high":    3,
}

func (x AdminCollectionPriority) String() string {
	return AdminCollectionPriority_name[uint8(x)]
}

func (x AdminCollectionPriority) MarshalText() ([]byte, error) {
	return []byte(AdminCollectionPriority_name[uint8(x)]), nil
}

func (x *AdminCollectionPriority) UnmarshalText(b []byte) error {
	*x = AdminCollectionPriority(AdminCollectionPriority_value[string(b)])
	return nil
}

func (x *AdminCollectionPriority) Is(values ...AdminCollectionPriority) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type AdminCollectionStatus uint8

const (
	AdminCollectionStatus_unknown                   AdminCollectionStatus = 0
	AdminCollectionStatus_created                   AdminCollectionStatus = 1
	AdminCollectionStatus_syncing_contract_metadata AdminCollectionStatus = 2
	AdminCollectionStatus_synced_contract_metadata  AdminCollectionStatus = 3
	AdminCollectionStatus_syncing_metadata          AdminCollectionStatus = 4
	AdminCollectionStatus_synced_metadata           AdminCollectionStatus = 5
	AdminCollectionStatus_syncing_tokens            AdminCollectionStatus = 6
	AdminCollectionStatus_synced_tokens             AdminCollectionStatus = 7
	AdminCollectionStatus_syncing_orders            AdminCollectionStatus = 8
	AdminCollectionStatus_active                    AdminCollectionStatus = 9
	AdminCollectionStatus_failed                    AdminCollectionStatus = 10
	AdminCollectionStatus_inactive                  AdminCollectionStatus = 11
	AdminCollectionStatus_incompatible_type         AdminCollectionStatus = 12
)

var AdminCollectionStatus_name = map[uint8]string{
	0:  "unknown",
	1:  "created",
	2:  "syncing_contract_metadata",
	3:  "synced_contract_metadata",
	4:  "syncing_metadata",
	5:  "synced_metadata",
	6:  "syncing_tokens",
	7:  "synced_tokens",
	8:  "syncing_orders",
	9:  "active",
	10: "failed",
	11: "inactive",
	12: "incompatible_type",
}

var AdminCollectionStatus_value = map[string]uint8{
	"unknown":                   0,
	"created":                   1,
	"syncing_contract_metadata": 2,
	"synced_contract_metadata":  3,
	"syncing_metadata":          4,
	"synced_metadata":           5,
	"syncing_tokens":            6,
	"synced_tokens":             7,
	"syncing_orders":            8,
	"active":                    9,
	"failed":                    10,
	"inactive":                  11,
	"incompatible_type":         12,
}

func (x AdminCollectionStatus) String() string {
	return AdminCollectionStatus_name[uint8(x)]
}

func (x AdminCollectionStatus) MarshalText() ([]byte, error) {
	return []byte(AdminCollectionStatus_name[uint8(x)]), nil
}

func (x *AdminCollectionStatus) UnmarshalText(b []byte) error {
	*x = AdminCollectionStatus(AdminCollectionStatus_value[string(b)])
	return nil
}

func (x *AdminCollectionStatus) Is(values ...AdminCollectionStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TokenType uint8

const (
	TokenType_ERC20   TokenType = 0
	TokenType_ERC721  TokenType = 1
	TokenType_ERC1155 TokenType = 2
)

var TokenType_name = map[uint8]string{
	0: "ERC20",
	1: "ERC721",
	2: "ERC1155",
}

var TokenType_value = map[string]uint8{
	"ERC20":   0,
	"ERC721":  1,
	"ERC1155": 2,
}

func (x TokenType) String() string {
	return TokenType_name[uint8(x)]
}

func (x TokenType) MarshalText() ([]byte, error) {
	return []byte(TokenType_name[uint8(x)]), nil
}

func (x *TokenType) UnmarshalText(b []byte) error {
	*x = TokenType(TokenType_value[string(b)])
	return nil
}

func (x *TokenType) Is(values ...TokenType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type FileScope uint8

const (
	FileScope_LOGO            FileScope = 0
	FileScope_MARKETPLACE     FileScope = 1
	FileScope_AVATAR          FileScope = 2
	FileScope_EMAIL           FileScope = 3
	FileScope_WALLET          FileScope = 4
	FileScope_TOKEN_DIRECTORY FileScope = 5
	FileScope_ECOSYSTEM       FileScope = 6
)

var FileScope_name = map[uint8]string{
	0: "LOGO",
	1: "MARKETPLACE",
	2: "AVATAR",
	3: "EMAIL",
	4: "WALLET",
	5: "TOKEN_DIRECTORY",
	6: "ECOSYSTEM",
}

var FileScope_value = map[string]uint8{
	"LOGO":            0,
	"MARKETPLACE":     1,
	"AVATAR":          2,
	"EMAIL":           3,
	"WALLET":          4,
	"TOKEN_DIRECTORY": 5,
	"ECOSYSTEM":       6,
}

func (x FileScope) String() string {
	return FileScope_name[uint8(x)]
}

func (x FileScope) MarshalText() ([]byte, error) {
	return []byte(FileScope_name[uint8(x)]), nil
}

func (x *FileScope) UnmarshalText(b []byte) error {
	*x = FileScope(FileScope_value[string(b)])
	return nil
}

func (x *FileScope) Is(values ...FileScope) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type EmailTemplateType uint8

const (
	EmailTemplateType_UNKNOWN EmailTemplateType = 0
	EmailTemplateType_LOGIN   EmailTemplateType = 1
	EmailTemplateType_GUARD   EmailTemplateType = 2
)

var EmailTemplateType_name = map[uint8]string{
	0: "UNKNOWN",
	1: "LOGIN",
	2: "GUARD",
}

var EmailTemplateType_value = map[string]uint8{
	"UNKNOWN": 0,
	"LOGIN":   1,
	"GUARD":   2,
}

func (x EmailTemplateType) String() string {
	return EmailTemplateType_name[uint8(x)]
}

func (x EmailTemplateType) MarshalText() ([]byte, error) {
	return []byte(EmailTemplateType_name[uint8(x)]), nil
}

func (x *EmailTemplateType) UnmarshalText(b []byte) error {
	*x = EmailTemplateType(EmailTemplateType_value[string(b)])
	return nil
}

func (x *EmailTemplateType) Is(values ...EmailTemplateType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TaskStatus uint8

const (
	TaskStatus_PENDING   TaskStatus = 0
	TaskStatus_PAUSED    TaskStatus = 1
	TaskStatus_FAILED    TaskStatus = 2
	TaskStatus_COMPLETED TaskStatus = 3
	TaskStatus_DISABLED  TaskStatus = 4
)

var TaskStatus_name = map[uint8]string{
	0: "PENDING",
	1: "PAUSED",
	2: "FAILED",
	3: "COMPLETED",
	4: "DISABLED",
}

var TaskStatus_value = map[string]uint8{
	"PENDING":   0,
	"PAUSED":    1,
	"FAILED":    2,
	"COMPLETED": 3,
	"DISABLED":  4,
}

func (x TaskStatus) String() string {
	return TaskStatus_name[uint8(x)]
}

func (x TaskStatus) MarshalText() ([]byte, error) {
	return []byte(TaskStatus_name[uint8(x)]), nil
}

func (x *TaskStatus) UnmarshalText(b []byte) error {
	*x = TaskStatus(TaskStatus_value[string(b)])
	return nil
}

func (x *TaskStatus) Is(values ...TaskStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OnboardingStep string

const (
	OnboardingStep_linkOrDeployContract     OnboardingStep = "linkOrDeployContract"
	OnboardingStep_createMarketplace        OnboardingStep = "createMarketplace"
	OnboardingStep_setUpGasTank             OnboardingStep = "setUpGasTank"
	OnboardingStep_configureWaas            OnboardingStep = "configureWaas"
	OnboardingStep_customizeWallet          OnboardingStep = "customizeWallet"
	OnboardingStep_inviteCollaborator       OnboardingStep = "inviteCollaborator"
	OnboardingStep_cloneGithub              OnboardingStep = "cloneGithub"
	OnboardingStep_copyCredentials          OnboardingStep = "copyCredentials"
	OnboardingStep_customizeMarketplace     OnboardingStep = "customizeMarketplace"
	OnboardingStep_deployERC721Contract     OnboardingStep = "deployERC721Contract"
	OnboardingStep_deployERC1155Contract    OnboardingStep = "deployERC1155Contract"
	OnboardingStep_addMarketplaceCollection OnboardingStep = "addMarketplaceCollection"
	OnboardingStep_createCollection         OnboardingStep = "createCollection"
	OnboardingStep_customizeCollectible     OnboardingStep = "customizeCollectible"
	OnboardingStep_deploySaleContract       OnboardingStep = "deploySaleContract"
	OnboardingStep_setSaleSettings          OnboardingStep = "setSaleSettings"
	OnboardingStep_addMinterRoleToItems     OnboardingStep = "addMinterRoleToItems"
	OnboardingStep_setUpAudienceList        OnboardingStep = "setUpAudienceList"
	OnboardingStep_setUpBot                 OnboardingStep = "setUpBot"
)

func (x OnboardingStep) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *OnboardingStep) UnmarshalText(b []byte) error {
	*x = OnboardingStep(string(b))
	return nil
}

func (x *OnboardingStep) Is(values ...OnboardingStep) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type WaasTenantState uint8

const (
	WaasTenantState_PENDING   WaasTenantState = 0
	WaasTenantState_DEPLOYING WaasTenantState = 1
	WaasTenantState_READY     WaasTenantState = 2
	WaasTenantState_FAILED    WaasTenantState = 3
)

var WaasTenantState_name = map[uint8]string{
	0: "PENDING",
	1: "DEPLOYING",
	2: "READY",
	3: "FAILED",
}

var WaasTenantState_value = map[string]uint8{
	"PENDING":   0,
	"DEPLOYING": 1,
	"READY":     2,
	"FAILED":    3,
}

func (x WaasTenantState) String() string {
	return WaasTenantState_name[uint8(x)]
}

func (x WaasTenantState) MarshalText() ([]byte, error) {
	return []byte(WaasTenantState_name[uint8(x)]), nil
}

func (x *WaasTenantState) UnmarshalText(b []byte) error {
	*x = WaasTenantState(WaasTenantState_value[string(b)])
	return nil
}

func (x *WaasTenantState) Is(values ...WaasTenantState) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TrialType string

const (
	TrialType_ANALYTICS TrialType = "ANALYTICS"
)

func (x TrialType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *TrialType) UnmarshalText(b []byte) error {
	*x = TrialType(string(b))
	return nil
}

func (x *TrialType) Is(values ...TrialType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type AuditType string

const (
	AuditType_SUBSCRIPTION      AuditType = "SUBSCRIPTION"
	AuditType_BILLING_OVERRIDE  AuditType = "BILLING_OVERRIDE"
	AuditType_ECOSYSTEM_LICENSE AuditType = "ECOSYSTEM_LICENSE"
)

func (x AuditType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *AuditType) UnmarshalText(b []byte) error {
	*x = AuditType(string(b))
	return nil
}

func (x *AuditType) Is(values ...AuditType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type EcosystemType string

const (
	EcosystemType_UNKNOWN EcosystemType = "UNKNOWN"
	EcosystemType_OPEN    EcosystemType = "OPEN"
	EcosystemType_CLOSED  EcosystemType = "CLOSED"
)

func (x EcosystemType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *EcosystemType) UnmarshalText(b []byte) error {
	*x = EcosystemType(string(b))
	return nil
}

func (x *EcosystemType) Is(values ...EcosystemType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type EcosystemAccess uint8

const (
	// user of ecosystem (for private ecosystems)
	EcosystemAccess_User EcosystemAccess = 0
	// ecosystem read access, projects are read-only
	EcosystemAccess_Read EcosystemAccess = 1
	// ecosystem read access, admin of all projects
	EcosystemAccess_Write EcosystemAccess = 2
	// ecosystem admin, admin of all projects
	EcosystemAccess_Admin EcosystemAccess = 3
	// ecosystem owner, can add ecosystem collaborators, admin of all projects
	EcosystemAccess_Owner EcosystemAccess = 4
)

var EcosystemAccess_name = map[uint8]string{
	0: "User",
	1: "Read",
	2: "Write",
	3: "Admin",
	4: "Owner",
}

var EcosystemAccess_value = map[string]uint8{
	"User":  0,
	"Read":  1,
	"Write": 2,
	"Admin": 3,
	"Owner": 4,
}

func (x EcosystemAccess) String() string {
	return EcosystemAccess_name[uint8(x)]
}

func (x EcosystemAccess) MarshalText() ([]byte, error) {
	return []byte(EcosystemAccess_name[uint8(x)]), nil
}

func (x *EcosystemAccess) UnmarshalText(b []byte) error {
	*x = EcosystemAccess(EcosystemAccess_value[string(b)])
	return nil
}

func (x *EcosystemAccess) Is(values ...EcosystemAccess) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ThemeType string

const (
	ThemeType_LIGHT  ThemeType = "LIGHT"
	ThemeType_DARK   ThemeType = "DARK"
	ThemeType_CUSTOM ThemeType = "CUSTOM"
)

func (x ThemeType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *ThemeType) UnmarshalText(b []byte) error {
	*x = ThemeType(string(b))
	return nil
}

func (x *ThemeType) Is(values ...ThemeType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK   bool            `json:"healthOK"`
	StartTime  time.Time       `json:"startTime"`
	Uptime     uint64          `json:"uptime"`
	Ver        string          `json:"ver"`
	Env        string          `json:"env"`
	Branch     string          `json:"branch"`
	CommitHash string          `json:"commitHash"`
	Networks   map[string]bool `json:"networks"`
	Checks     *RuntimeChecks  `json:"checks"`
}

type RuntimeChecks struct {
	QuotaControl  bool `json:"quotaControl"`
	Joqueue       bool `json:"joqueue"`
	Stripe        bool `json:"stripe"`
	CloudCommerce bool `json:"cloudCommerce"`
}

type Configuration struct {
	EcosystemID       uint64             `json:"ecosystemId"`
	Name              string             `json:"name"`
	Domain            string             `json:"domain"`
	ChainIDs          []uint64           `json:"chainIds"`
	License           *EcosystemLicense  `json:"license"`
	Settings          *EcosystemSettings `json:"settings"`
	ExclusiveChainIDs map[uint64]uint64  `json:"exclusiveChainIds"`
}

type AuthState struct {
	JwtToken    string          `json:"jwtToken"`
	ExpiresAt   time.Time       `json:"expiresAt"`
	Address     string          `json:"address"`
	SessionType AuthSessionType `json:"sessionType"`
	User        *User           `json:"user"`
}

// db table: 'users'
type User struct {
	Address   prototyp.Hash `json:"address" db:"address"`
	Email     *string       `json:"email" db:"email"`
	CreatedAt time.Time     `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt time.Time     `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	SysAdmin  bool          `json:"sysAdmin" db:"sys_admin"`
	AvatarKey string        `json:"-" db:"avatar_key"`
	AvatarURL string        `json:"avatarUrl" db:"-"`
}

type UserSettings struct {
	FreeProjectsLeft      int64 `json:"freeProjectsLeft"`
	TotalFreeProjectLimit int64 `json:"totalFreeProjectLimit"`
	TotalFreeProjects     int64 `json:"totalFreeProjects"`
}

type UserOverride struct {
	ID            uint64        `json:"id" db:"id,omitempty"`
	Address       prototyp.Hash `json:"address" db:"address"`
	ExtraProjects int64         `json:"extraProjects" db:"extra_projects"`
	CreatedAt     time.Time     `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt     time.Time     `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

// db table: 'projects'
// when adding a new db field, add it to the `makeProjectColumns` function
type Project struct {
	ID   uint64      `json:"id" db:"id,omitempty"`
	Name string      `json:"name" db:"name"`
	Type ProjectType `json:"type,omitempty" db:"type"`
	// address of User who is owner / created this
	OwnerAddress         prototyp.Hash           `json:"ownerAddress" db:"owner_address"`
	OwnerEmail           *string                 `json:"ownerEmail,omitempty" db:"-"`
	OwnerAvatarURL       string                  `json:"ownerAvatarUrl,omitempty" db:"-"`
	LicenseID            *uint64                 `json:"licenseId" db:"-"`
	LogoImageKey         string                  `json:"-" db:"logo_image_key"`
	LogoImageURL         string                  `json:"logoImageUrl" db:"-"`
	WebsiteURL           string                  `json:"websiteUrl" db:"website_url"`
	ChainIDs             []uint64                `json:"chainIds" db:"chain_ids,omitempty"`
	EcosystemID          uint64                  `json:"ecosystemId,omitempty" db:"ecosystem_id,omitempty"`
	SubscriptionTier     SubscriptionTier        `json:"subscriptionTier" db:"subscription_tier"`
	CollaboratorCount    uint64                  `json:"collaboratorCount" db:"collaborator_count"`
	OnboardingVisibility bool                    `json:"onboardingVisibility" db:"onboarding_visibility"`
	OnboardingSteps      map[OnboardingStep]bool `json:"-" db:"onboarding_steps"`
	CreatedAt            time.Time               `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt            time.Time               `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	DeletedAt            *time.Time              `json:"deletedAt,omitempty" db:"deleted_at,omitempty"`
}

type CreateProjectOptions struct {
	Type     *ProjectType `json:"type"`
	ChainIDs []uint64     `json:"chainIds"`
}

type ProjectListFilter struct {
	Name                *string           `json:"name"`
	ChainID             *uint64           `json:"chainId"`
	CollaboratorAddress *prototyp.Hash    `json:"collaboratorAddress"`
	CollaboratorEmail   *string           `json:"collaboratorEmail"`
	SubscriptionTier    *SubscriptionTier `json:"subscriptionTier"`
	Active              *bool             `json:"active"`
}

type ResourceFilter struct {
	Contracts *ContractFilter `json:"contracts"`
}

type Resource struct {
	Type   ResourceType      `json:"type"`
	Total  uint64            `json:"total"`
	Detail []*ResourceDetail `json:"detail"`
}

type ResourceDetail struct {
	Key   interface{} `json:"key"`
	Count uint64      `json:"count"`
}

type ProjectSubscription struct {
	ID               uint64               `json:"id" db:"id,omitempty"`
	ProjectID        uint64               `json:"projectId" db:"project_id"`
	Provider         SubscriptionProvider `json:"provider" db:"provider"`
	LicenseID        *uint64              `json:"licenseId" db:"license_id"`
	SubscriptionTier SubscriptionTier     `json:"subscriptionTier" db:"subscription_tier"`
	SubscriptionID   string               `json:"subscriptionId" db:"subscription_id"`
	ProviderURL      string               `json:"providerUrl,omitempty" db:"-"`
	DateStart        time.Time            `json:"dateStart" db:"date_start,omitempty"`
	DateEnd          *time.Time           `json:"dateEnd" db:"date_end"`
}

type Collaborator struct {
	ID        uint64           `json:"id" db:"id,omitempty"`
	ProjectID uint64           `json:"projectId" db:"project_id"`
	Type      CollaboratorType `json:"type" db:"type"`
	// NOTE: we are using a user wallet address here instead of the userId uint64
	// because the wallet address will give us more flexibility. For example, someone
	// could make a project, and add a bunch of collaborators to it by knowning their wallet address
	// even before that collaborator ever signed into the builder -- then when they sign into
	// the builder, the collaborator will automatically see the projects they have access to
	UserAddress   prototyp.Hash      `json:"userAddress" db:"user_address"`
	UserEmail     *string            `json:"userEmail" db:"-"`
	UserAvatarURL *string            `json:"userAvatarUrl" db:"-"`
	UserAvatarKey *string            `json:"-" db:"-"`
	Access        CollaboratorAccess `json:"access" db:"access"`
	InvitationID  *uint64            `json:"invitationId" db:"project_invitation_id"`
	CreatedAt     time.Time          `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt     time.Time          `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

type Contract struct {
	ID              uint64        `json:"id" db:"id,omitempty"`
	ProjectID       uint64        `json:"projectId" db:"project_id"`
	ContractName    string        `json:"contractName" db:"contract_name"`
	ContractAddress prototyp.Hash `json:"contractAddress" db:"contract_address"`
	ContractType    string        `json:"contractType" db:"contract_type"`
	// blockchain network id
	ChainID            uint64              `json:"chainId" db:"chain_id"`
	Source             ContractSourceType  `json:"source" db:"source"`
	ABI                *string             `json:"abi,omitempty" db:"abi"`
	Bytecode           prototyp.Hash       `json:"bytecode,omitempty" db:"bytecode"`
	BytecodeHash       prototyp.Hash       `json:"bytecode_hash,omitempty" db:"bytecode_hash"`
	AudienceID         *uint64             `json:"audienceId" db:"audience_id"`
	Decimals           *uint64             `json:"decimals,omitempty" db:"decimals"`
	Symbol             *string             `json:"symbol,omitempty" db:"symbol"`
	ContractExtensions *ContractExtensions `json:"contractExtensions,omitempty" db:"contract_extensions"`
	Tags               []string            `json:"tags,omitempty" db:"tags"`
	CreatedAt          time.Time           `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt          time.Time           `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

type ContractExtensions struct {
	ItemsContractAddress      *prototyp.Hash  `json:"itemsContractAddress,omitempty"`
	SplitterContractAddresses []prototyp.Hash `json:"splitterContractAddresses,omitempty"`
	LaosCollectionAddress     *prototyp.Hash  `json:"laosCollectionAddress,omitempty"`
}

type ContractSync struct {
	Decimals *uint64 `json:"decimals,omitempty" db:"decimals"`
	Symbol   *string `json:"symbol,omitempty" db:"symbol"`
}

type ContractFilter struct {
	ChainID            *uint64             `json:"chainId"`
	ContractSourceType *ContractSourceType `json:"contractSourceType"`
	ContractTypes      []string            `json:"contractTypes"`
	Tag                *string             `json:"tag"`
}

type ContractTag struct {
	Tag   string `json:"tag"`
	Count uint64 `json:"count"`
}

// no db table, RPC-only entity
type ContractLink struct {
	Contract     *Contract     `json:"contract" db:"contracts"`
	Project      *Project      `json:"project" db:"projects"`
	Collaborator *Collaborator `json:"collaborator" db:"collaborators"`
}

// no db table, RPC-only entity
type RelayerGasSponsor struct {
	ID        uint64 `json:"id"`
	ProjectID uint64 `json:"projectId"`
	// blockchain network id
	ChainID     uint64        `json:"chainId" db:"chain_id"`
	DisplayName string        `json:"displayName"`
	Address     prototyp.Hash `json:"address"`
	Active      bool          `json:"active"`
	CreatedAt   *time.Time    `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time    `json:"updatedAt,omitempty"`
}

type RelayerTransaction struct {
	TxnHash         prototyp.HashMaybe     `json:"txnHash"`
	TxnNonce        prototyp.BigInt        `json:"txnNonce"`
	MetaTxnID       *string                `json:"metaTxnID"`
	TxnStatus       string                 `json:"txnStatus"`
	TxnRevertReason string                 `json:"txnRevertReason"`
	Requeues        uint                   `json:"requeues"`
	QueuedAt        *time.Time             `json:"queuedAt"`
	SentAt          *time.Time             `json:"sentAt"`
	MinedAt         *time.Time             `json:"minedAt"`
	Target          prototyp.Hash          `json:"target"`
	Input           prototyp.Hash          `json:"input"`
	TxnArgs         map[string]interface{} `json:"txnArgs"`
	TxnReceipt      map[string]interface{} `json:"txnReceipt"`
	WalletAddress   prototyp.Hash          `json:"walletAddress"`
	MetaTxnNonce    prototyp.BigInt        `json:"metaTxnNonce"`
	GasLimit        uint64                 `json:"gasLimit"`
	GasPrice        prototyp.BigInt        `json:"gasPrice"`
	GasUsed         uint64                 `json:"gasUsed"`
	GasEstimated    uint64                 `json:"gasEstimated"`
	GasFeeMarkup    *uint64                `json:"gasFeeMarkup"`
	UsdRate         prototyp.BigInt        `json:"usdRate"`
	CreditsUsed     uint64                 `json:"creditsUsed"`
	Cost            decimal.Decimal        `json:"cost"`
	IsWhitelisted   bool                   `json:"isWhitelisted"`
	GasSponsor      *uint64                `json:"gasSponsor"`
	CreatedAt       *time.Time             `json:"createdAt"`
	UpdatedAt       *time.Time             `json:"updatedAt"`
}

// db table: 'contract_sources'
//
// library of deployable contract sources
type ContractSource struct {
	ID uint64 `json:"id" db:"id,omitempty"`
	// unique string name for this contract
	UID          string  `json:"uid" db:"uid"`
	ContractType string  `json:"contractType" db:"contract_type"`
	ProjectID    *uint64 `json:"projectId" db:"project_id"`
	// name of contract
	Name        string `json:"name" db:"name"`
	Description string `json:"description" db:"description"`
	Author      string `json:"author" db:"author"`
	License     string `json:"license" db:"license"`
	Audited     bool   `json:"audited" db:"audited"`
	// for more details
	MoreInfoURL string `json:"moreInfoUrl" db:"more_info_url"`
	// off/on
	Disabled bool `json:"disabled" db:"disabled"`
	// uid of factory source
	FactorySourceUID string        `json:"factorySourceUid" db:"factory_source_uid"`
	ABI              string        `json:"abi" db:"abi"`
	Bytecode         prototyp.Hash `json:"bytecode" db:"bytecode"`
	BytecodeHash     prototyp.Hash `json:"-" db:"bytecode_hash"`
	CreatedAt        time.Time     `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt        time.Time     `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

// db table: 'contract_factories'
//
// deployed contract factory instances
type ContractFactory struct {
	ID uint64 `json:"id" db:"id,omitempty"`
	// blockchain network id
	ChainID         uint64        `json:"chainId" db:"chain_id"`
	ContractAddress prototyp.Hash `json:"contractAddress" db:"contract_address"`
	// uid of factory source
	UID          string        `json:"uid" db:"uid"`
	ABI          *string       `json:"abi,omitempty" db:"abi"`
	Bytecode     prototyp.Hash `json:"bytecode,omitempty" db:"bytecode"`
	BytecodeHash prototyp.Hash `json:"bytecode_hash,omitempty" db:"bytecode_hash"`
	CreatedAt    time.Time     `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt    time.Time     `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

// no db table, RPC-only entity
type NewContractSource struct {
	// unique string name for this contract
	UID string `json:"uid"`
	// name of contract
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Author      *string `json:"author"`
	License     *string `json:"license"`
	Audited     *bool   `json:"audited"`
	// for more details
	MoreInfoURL  *string       `json:"moreInfoUrl"`
	Disabled     *bool         `json:"disabled"`
	ContractType string        `json:"contractType"`
	Bytecode     prototyp.Hash `json:"bytecode"`
	ABI          string        `json:"abi" db:"abi"`
}

// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Common for both numbered pages and cursor: Number of items per page
	PageSize *uint32 `json:"pageSize"`
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	Page *uint32 `json:"page"`
	// Cursor: column to compare before/after to
	Column *string `json:"column,omitempty"`
	// More records: true if it's not the last page
	More *bool `json:"more"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before,omitempty"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after,omitempty"`
	// Sorting filter
	Sort []*SortBy `json:"sort,omitempty"`
}

type SortBy struct {
	Column string     `json:"column"`
	Order  *SortOrder `json:"order"`
}

type GasTankStatus struct {
	Provider        PaymentProvider `json:"provider"`
	SetupPayment    bool            `json:"setupPayment"`
	MainnetSponsors bool            `json:"mainnetSponsors"`
	GasTankBalance  *float64        `json:"gasTankBalance"`
}

type BillingSettings struct {
	Limits LimitSettings `json:"limits"`
	Prices PriceSettings `json:"prices"`
	TopUp  TopUpSettings `json:"topUp"`
}

type BillingCycle struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type LimitSettings struct {
	// Maximum number of access keys
	MaxKeys *uint64 `json:"maxKeys"`
	// Included Usage in MAU that triggers a warning
	MauIncludedWarn uint64 `json:"mauIncludedWarn"`
	// Maximum MAU before overage charges
	MauIncludedMax uint64 `json:"mauIncludedMax"`
	// Overage Usage in MAU that triggers a warning
	MauOverageWarn uint64 `json:"mauOverageWarn"`
	// Maximum MAU overage before requests are blocked
	MauOverageMax *uint64 `json:"mauOverageMax"`
	// Number of requests per MAU before overage charges
	RequestsPerMau uint64 `json:"requestsPerMau"`
	// Requests per minute rate limit
	RateLimit int64 `json:"rateLimit"`
}

type PriceSettings struct {
	// Base price for the Subscription
	Subscription decimal.Decimal `json:"subscription"`
	// Price per 1 MAU overage or $requestsPerMau requests
	Overage decimal.Decimal `json:"overage"`
	// Fee of marketplace transactions
	MarketplaceFee decimal.Decimal `json:"marketplaceFee"`
	// Fee of gas transactions
	GasFeeMarkup decimal.Decimal `json:"gasFeeMarkup"`
}

type TopUpSettings struct {
	// Top-up is enabled
	Active bool `json:"active"`
	// Provider
	Provider PaymentProvider `json:"provider"`
	// Top-up threshold before top-up is triggered
	Threshold decimal.Decimal `json:"threshold,omitempty"`
	// Top-up amount when triggered
	Amount decimal.Decimal `json:"amount,omitempty"`
	// Maximum top-up amount per cycle
	Limit decimal.Decimal `json:"limit,omitempty"`
}

// db table: 'billing_override'
//
// Project settings for billing
type BillingOverride struct {
	MauIncludedMax    *uint64          `json:"mauIncludedMax" db:"mau_included_max"`
	MauIncludedWarn   *uint64          `json:"mauIncludedWarn" db:"mau_included_warn"`
	MauOverageMax     *uint64          `json:"mauOverageMax" db:"mau_overage_max"`
	MauOverageWarn    *uint64          `json:"mauOverageWarn" db:"mau_overage_warn"`
	RateLimit         *int64           `json:"rateLimit" db:"rate_limit"`
	PriceSubscription *decimal.Decimal `json:"priceSubscription" db:"price_subscription"`
	PriceOverage      *decimal.Decimal `json:"priceOverage" db:"price_overage"`
	MarketplaceFee    *decimal.Decimal `json:"marketplaceFee" db:"marketplace_fee"`
	GasFeeMarkup      *decimal.Decimal `json:"gasFeeMarkup" db:"gas_fee_markup"`
	TopUpEnabled      bool             `json:"topUpEnabled" db:"top_up_enabled"`
	TopUpProvider     PaymentProvider  `json:"topUpProvider" db:"top_up_provider"`
	TopUpThreshold    *decimal.Decimal `json:"topUpThreshold" db:"top_up_threshold"`
	TopUpAmount       *decimal.Decimal `json:"topUpAmount" db:"top_up_amount"`
	TopUpLimit        *decimal.Decimal `json:"topUpLimit" db:"top_up_limit"`
}

type UsageInfo struct {
	IncludedWarn int64            `json:"includedWarn"`
	IncludedMax  int64            `json:"includedMax"`
	OverageWarn  int64            `json:"overageWarn"`
	OverageMax   int64            `json:"overageMax"`
	Mau          *uint64          `json:"mau"`
	Usage        int64            `json:"usage"`
	Balance      int64            `json:"balance"`
	Overage      int64            `json:"overage"`
	ExtraCharged *decimal.Decimal `json:"extraCharged,omitempty"`
}

// no db table, RPC-only entity
type SubscriptionInfo struct {
	Current  *ProjectSubscription `json:"current"`
	License  *EcosystemLicense    `json:"license"`
	Cycle    BillingCycle         `json:"cycle"`
	Settings *BillingSettings     `json:"settings"`
	// null => ongoing sub, not null => sub canceled (last cycle)
	Info             UsageInfo         `json:"info"`
	PlannedDowngrade *SubscriptionTier `json:"plannedDowngrade,omitempty"`
	PendingUpgrade   *SubscriptionTier `json:"pendingUpgrade,omitempty"`
}

type PaymentHistory struct {
	TotalPayments decimal.Decimal `json:"totalPayments" db:"total_payments,omitempty"`
	Payments      []*Payment      `json:"payments"`
}

type Redirect struct {
	URL string `json:"url"`
}

type StripeEventData struct {
	Object *StripeEventDataObject `json:"object"`
}

type StripeEventDataObject struct {
	Id     string `json:"id"`
	Object string `json:"object"`
}

type Payment struct {
	ID        uint64 `json:"id" db:"id,omitempty"`
	ProjectID uint64 `json:"projectId" db:"project_id"`
	// blockchain network id
	ChainID  *uint64         `json:"chainId" db:"chain_id"`
	Status   *PaymentStatus  `json:"status" db:"status"`
	Provider PaymentProvider `json:"provider" db:"provider"`
	// e.g. blockchain transaction hash, app store purchase id
	ExternalTxnID string     `json:"externalTxnID" db:"external_txn_id"`
	CreatedAt     *time.Time `json:"createdAt" db:"created_at,omitempty"`
}

type PaymentLog struct {
	ID        uint64          `json:"id" db:"id,omitempty"`
	PaymentID uint64          `json:"paymentID" db:"payment_id"`
	Data      *PaymentLogData `json:"data" db:"data"`
	CreatedAt *time.Time      `json:"createdAt" db:"created_at,omitempty"`
}

type PaymentLogData struct {
	Type string      `json:"type"`
	Data interface{} `json:"data"`
}

type InvoicesReturn struct {
	HasMore  bool       `json:"hasMore"`
	Invoices []*Invoice `json:"invoices"`
}

type Invoice struct {
	Id     string          `json:"id"`
	Date   time.Time       `json:"date"`
	Amount decimal.Decimal `json:"amount"`
	Paid   bool            `json:"paid"`
	URL    string          `json:"url"`
}

type SubscriptionPlans struct {
	Configs map[string]*SubscriptionPlan `json:"configs"`
}

type SubscriptionPlan struct {
	Tier     SubscriptionTier `json:"tier"`
	Settings *BillingSettings `json:"settings"`
	Features []string         `json:"features"`
}

// Wrapper for metadata's ContractInfo
type ContractInfo struct {
	Data *metadata.ContractInfo `json:"data"`
}

// Wrapper for metadata's ContractInfoOverride
type ContractInfoOverride struct {
	Data *metadata.ContractInfoOverride `json:"data"`
}

type ProjectInvitation struct {
	ID          uint64             `json:"id" db:"id,omitempty"`
	ProjectID   uint64             `json:"projectId" db:"project_id"`
	Code        string             `json:"code" db:"invitation_code"`
	Access      CollaboratorAccess `json:"access" db:"access"`
	ExpiresAt   *time.Time         `json:"expiresAt" db:"expires_at,omitempty"`
	UsageCount  uint64             `json:"usageCount" db:"-"`
	SignupLimit *uint64            `json:"signupLimit,omitempty" db:"signup_limit"`
	CreatedAt   *time.Time         `json:"createdAt" db:"created_at,omitempty"`
	DeletedAt   *time.Time         `json:"-" db:"deleted_at,omitempty"`
}

type MarketplaceConfig struct {
	ID        uint64                 `json:"id" db:"id,omitempty"`
	ProjectID uint64                 `json:"projectId" db:"project_id"`
	Settings  *MarketplaceSettings   `json:"settings" db:"settings,omitempty"`
	Style     map[string]interface{} `json:"style" db:"style,omitempty"`
	CreatedAt *time.Time             `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

type EcosystemWalletSettings struct {
	WalletUrl     string  `json:"walletUrl"`
	WalletAppName string  `json:"walletAppName"`
	LogoLightUrl  *string `json:"logoLightUrl"`
	LogoDarkUrl   *string `json:"logoDarkUrl"`
}

type MarketplaceWalletOptions struct {
	WalletType            MarketplaceWallet        `json:"walletType"`
	OidcIssuers           map[string]string        `json:"oidcIssuers"`
	Connectors            []string                 `json:"connectors"`
	IncludeEIP6963Wallets bool                     `json:"includeEIP6963Wallets"`
	Ecosystem             *EcosystemWalletSettings `json:"ecosystem"`
}

type MetadataFilterRule struct {
	Key       string          `json:"key"`
	Condition FilterCondition `json:"condition"`
	Value     *string         `json:"value"`
}

type CollectionFilterSettings struct {
	FilterOrder []string              `json:"filterOrder"`
	Exclusions  []*MetadataFilterRule `json:"exclusions"`
}

type MarketplaceCollection struct {
	MarketplaceType        MarketplaceType          `json:"marketplaceType"`
	ChainID                uint64                   `json:"chainId"`
	Address                prototyp.Hash            `json:"address"`
	Exchanges              []string                 `json:"exchanges"`
	BannerURL              string                   `json:"bannerUrl"`
	FeePercentage          decimal.Decimal          `json:"feePercentage"`
	CurrencyOptions        []prototyp.Hash          `json:"currencyOptions"`
	DestinationMarketplace OrderbookKind            `json:"destinationMarketplace"`
	FilterSettings         CollectionFilterSettings `json:"filterSettings"`
	IsLAOSERC721           *bool                    `json:"isLAOSERC721"`
}

type AdminMarketplaceCollection struct {
	Status                AdminCollectionStatus        `json:"status"`
	ChainID               uint64                       `json:"chainId"`
	ContractAddress       prototyp.Hash                `json:"contractAddress"`
	ContractType          AdminMarketplaceContractType `json:"contractType"`
	Priority              AdminCollectionPriority      `json:"priority"`
	TokenQuantityDecimals uint64                       `json:"tokenQuantityDecimals"`
	CreatedAt             time.Time                    `json:"createdAt"`
	UpdatedAt             time.Time                    `json:"updatedAt"`
	DeletedAt             *time.Time                   `json:"deletedAt,omitempty"`
}

type MarketplaceSocials struct {
	Twitter   string `json:"twitter"`
	Discord   string `json:"discord"`
	Website   string `json:"website"`
	Tiktok    string `json:"tiktok"`
	Instagram string `json:"instagram"`
	Youtube   string `json:"youtube"`
}

type MarketplaceSettings struct {
	PublisherID       string                    `json:"publisherId"`
	Title             string                    `json:"title"`
	ShortDescription  string                    `json:"shortDescription"`
	Socials           MarketplaceSocials        `json:"socials"`
	FaviconURL        string                    `json:"faviconUrl"`
	LandingBannerURL  string                    `json:"landingBannerUrl"`
	Collections       []*MarketplaceCollection  `json:"collections"`
	WalletOptions     *MarketplaceWalletOptions `json:"walletOptions"`
	LandingPageLayout string                    `json:"landingPageLayout"`
	LogoURL           string                    `json:"logoUrl"`
	BannerURL         string                    `json:"bannerUrl,omitempty"`
	FontURL           string                    `json:"fontUrl,omitempty"`
	OgImage           string                    `json:"ogImage,omitempty"`
}

type MarketplaceHostname struct {
	ID                  uint64    `json:"id" db:"id,omitempty"`
	MarketplaceConfigID uint64    `json:"marketplaceConfigId" db:"marketplace_config_id"`
	Hostname            string    `json:"hostname" db:"hostname"`
	IsDefaultHostname   bool      `json:"isDefaultHostname" db:"is_default_hostname"`
	IsCustomDomain      bool      `json:"isCustomDomain" db:"is_custom_domain"`
	CreatedAt           time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type OffchainInventory struct {
	ID                  uint64        `json:"id"`
	ProjectID           uint64        `json:"projectId"`
	ChainID             uint64        `json:"chainId"`
	ExternalProductID   string        `json:"externalProductId"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress"`
	PaymentTokenType    TokenType     `json:"paymentTokenType"`
	PaymentTokenID      uint64        `json:"paymentTokenId"`
	PaymentAmount       uint64        `json:"paymentAmount"`
	PaymentRecipient    prototyp.Hash `json:"paymentRecipient"`
	ChainedCallAddress  prototyp.Hash `json:"chainedCallAddress"`
	// product recipient address is added as the first argument (after selector)
	ChainedCallData         *string    `json:"chainedCallData"`
	AllowCrossChainPayments *bool      `json:"allowCrossChainPayments"`
	CallbackURL             *string    `json:"callbackURL"`
	CreatedAt               *time.Time `json:"createdAt,omitempty"`
	DeletedAt               *time.Time `json:"deletedAt,omitempty"`
}

type OffchainPayment struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	OffchainInventoryID uint64        `json:"offchainInventoryId" db:"offchain_inventory_id"`
	ProductRecipient    prototyp.Hash `json:"productRecipient" db:"product_recipient"`
	PaymentChainID      uint64        `json:"paymentChainId" db:"payment_chain_id"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress" db:"payment_token_address"`
	Expiration          *time.Time    `json:"expiration" db:"expiration"`
	CreatedAt           *time.Time    `json:"createdAt" db:"created_at"`
	CompletedAt         *time.Time    `json:"completedAt" db:"completed_at"`
	ProcessedAt         *time.Time    `json:"processedAt" db:"processed_at"`
}

type WalletConfigSchema struct {
	Version int                    `json:"version"`
	Config  map[string]interface{} `json:"config"`
}

type WalletConfig struct {
	ID        *uint64                `json:"id" db:"id,omitempty"`
	Version   int                    `json:"version" db:"version,omitempty"`
	ProjectID uint64                 `json:"projectId" db:"project_id"`
	Platform  string                 `json:"platform" db:"platform"`
	Config    map[string]interface{} `json:"config" db:"config,omitempty"`
	CreatedAt *time.Time             `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt *time.Time             `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

type ProjectFile struct {
	ID        uint64     `json:"id,omitempty" db:"id,omitempty"`
	ProjectID uint64     `json:"projectId,omitempty" db:"project_id"`
	Scope     FileScope  `json:"scope" db:"scope"`
	MimeType  string     `json:"mimetype" db:"mimetype"`
	FilePath  string     `json:"-" db:"filepath"`
	Contents  []byte     `json:"-" db:"-"`
	Hash      []byte     `json:"-" db:"hash"`
	URL       string     `json:"url" db:"-"`
	CreatedAt *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// db table: 'email_templates'
type EmailTemplate struct {
	ID           uint64             `json:"id" db:"id,omitempty"`
	TemplateType *EmailTemplateType `json:"templateType" db:"template_type"`
	ProjectID    uint64             `json:"projectId" db:"project_id"`
	Subject      string             `json:"subject" db:"subject"`
	IntroText    string             `json:"introText" db:"intro_text"`
	LogoURL      string             `json:"logoUrl" db:"logo_url"`
	Template     *string            `json:"template" db:"template"`
	FromEmail    *string            `json:"fromEmail" db:"from_email"`
	Placeholders []string           `json:"placeholders" db:"placeholders"`
	SesConfig    *SESSettings       `json:"sesConfig" db:"ses_config"`
	CreatedAt    time.Time          `json:"createdAt" db:"created_at"`
	UpdatedAt    time.Time          `json:"updatedAt" db:"updated_at"`
	DeletedAt    *time.Time         `json:"deletedAt,omitempty" db:"deleted_at,omitempty"`
}

type SESSettings struct {
	AccessRoleARN string `json:"accessRoleARN"`
	SourceARN     string `json:"sourceARN"`
	Region        string `json:"region"`
}

type TaskRunner struct {
	ID        uint64    `json:"id" db:"id,omitempty"`
	WorkGroup string    `json:"workGroup" db:"work_group"`
	RunAt     time.Time `json:"runAt" db:"run_at"`
}

type Task struct {
	ID        uint64     `json:"id" db:"id,omitempty"`
	Queue     string     `json:"queue" db:"queue"`
	Status    TaskStatus `json:"status" db:"status"`
	Try       uint32     `json:"try" db:"try"`
	RunAt     *time.Time `json:"runAt" db:"run_at,omitempty"`
	LastRanAt *time.Time `json:"lastRanAt" db:"last_ran_at,omitempty"`
	CreatedAt *time.Time `json:"createdAt" db:"created_at,omitempty"`
	Payload   []byte     `json:"payload" db:"payload"`
	Hash      string     `json:"hash" db:"-"`
}

type CreditBonus struct {
	ID        uint64    `json:"id" db:"id,omitempty"`
	ProjectID uint64    `json:"projectId" db:"project_id"`
	Amount    uint64    `json:"amount" db:"credit_amount"`
	Balance   uint64    `json:"balance" db:"-"`
	CreatedAt time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt time.Time `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

type OpenIdProvider struct {
	Issuer   string   `json:"iss"`
	Audience []string `json:"aud"`
}

// WaasSettings is the project configuration for WaaS
type WaasSettings struct {
	// address used for recovery. It's set on creation and cannot be changed.
	RecoveryAddress prototyp.Hash `json:"recoveryAddress"`
	// authConfig is the configuration for the WaaS authentication
	AuthConfig *WaasAuthConfig `json:"authConfig"`
	// tenantState indicates the deploy status of the tenant deployment
	TenantState WaasTenantState `json:"tenantState"`
	// emailAuth is a flag to enable email authentication
	EmailAuth bool `json:"emailAuth"`
	// list of OpenID providers
	OidcProviders []*OpenIdProvider `json:"oidcProviders"`
	// list of allowed origins
	AllowedOrigins validation.Origins `json:"allowedOrigins"`
	// code used in updates to WaaS settings
	UpdateCode string `json:"updateCode,omitempty"`
	// key used by the WaaS integration
	TenantKey string `json:"tenantKey"`
}

type WaasAuthEmailConfig struct {
	Enabled bool `json:"enabled"`
}

type WaasAuthGuestConfig struct {
	Enabled bool `json:"enabled"`
}

type WaasAuthPlayfabConfig struct {
	Enabled bool   `json:"enabled"`
	TitleID string `json:"titleId,omitempty"`
}

type WaasAuthStytchConfig struct {
	Enabled   bool   `json:"enabled"`
	ProjectID string `json:"projectId,omitempty"`
}

type WaasAuthConfig struct {
	Email   WaasAuthEmailConfig   `json:"email,omitempty"`
	Guest   WaasAuthGuestConfig   `json:"guest,omitempty"`
	Playfab WaasAuthPlayfabConfig `json:"playfab,omitempty"`
	Stytch  WaasAuthStytchConfig  `json:"stytch,omitempty"`
}

type WaasWalletStatus struct {
	ChainID  uint64        `json:"chainId"`
	Address  prototyp.Hash `json:"address"`
	Deployed bool          `json:"deployed"`
}

type Audience struct {
	ID           uint64     `json:"id" db:"id,omitempty"`
	ProjectID    uint64     `json:"projectId" db:"project_id"`
	Name         string     `json:"name" db:"name"`
	ContactCount uint32     `json:"contactCount" db:"-"`
	CreatedAt    time.Time  `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt    time.Time  `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	DeletedAt    *time.Time `json:"deletedAt" db:"deleted_at,omitempty"`
}

type AudienceContact struct {
	ID         uint64        `json:"id" db:"id,omitempty"`
	AudienceID uint64        `json:"audienceId" db:"audience_id"`
	Name       string        `json:"name" db:"name"`
	Address    prototyp.Hash `json:"address" db:"address"`
	Email      string        `json:"email" db:"email"`
	UserIP     string        `json:"user_ip,omitempty" db:"user_ip"`
	Stage      *uint32       `json:"stage,omitempty" db:"stage"`
	Provider   string        `json:"provider,omitempty" db:"provider"`
	CreatedAt  *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
	UpdatedAt  *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
}

type AudienceRegistrationStatus struct {
	// total number of contacts in the audience based on unique entries,
	// for example, unique email addresses.
	TotalCount uint32 `json:"totalCount"`
}

type Trial struct {
	ID        uint64    `json:"id" db:"id,omitempty"`
	ProjectID uint64    `json:"projectId" db:"project_id"`
	Type      TrialType `json:"type" db:"type"`
	StartAt   time.Time `json:"startAt" db:"start_at,omitempty"`
	EndAt     time.Time `json:"endAt" db:"end_at,omitempty"`
}

type ExtendedMarketplaceConfig struct {
	ProjectID        uint64               `json:"projectId"`
	Config           *MarketplaceSettings `json:"config"`
	AccessKey        string               `json:"accessKey"`
	WaasEmailEnabled bool                 `json:"waasEmailEnabled"`
	WaasTenantKey    string               `json:"waasTenantKey"`
	WaasProviders    []*OpenIdProvider    `json:"waasProviders"`
}

type WalletProof struct {
	// address of the wallet
	Address prototyp.Hash `json:"address"`
	// message signed by the wallet
	Message string `json:"message"`
	// signature of the message by the wallet
	// the value is expected to be hex encoded string, ie. '0xabc...'
	Signature string `json:"signature"`
	// for smart contract wallets, the chainId is required. for EOA wallets, you can just pass 0.
	ChainID uint64 `json:"chainId"`
}

type AuditLog struct {
	ID            uint64        `json:"id" db:"id,omitempty"`
	WalletAddress prototyp.Hash `json:"walletAddress" db:"wallet_address"`
	UserEmail     string        `json:"userEmail" db:"user_email"`
	EntityID      uint64        `json:"entityId" db:"entity_id"`
	Type          AuditType     `json:"type" db:"type"`
	OldValue      interface{}   `json:"oldValue" db:"old_value"`
	NewValue      interface{}   `json:"newValue" db:"new_value"`
	CreatedAt     time.Time     `json:"createdAt" db:"created_at,omitempty"`
}

type Ecosystem struct {
	// serial
	ID uint64 `json:"id" db:"id,omitempty"`
	// name of the ecosystem
	Name string `json:"name" db:"name"`
	// type of the ecosystem
	Type EcosystemType `json:"type" db:"type"`
	// ref: Users.address
	OwnerAddress prototyp.Hash `json:"ownerAddress" db:"owner_address"`
	// used by wallet v3 for lookup
	Domain string `json:"domain" db:"domain"`
	// access key prefix
	AccessKeyPrefix string `json:"accessKeyPrefix" db:"access_key_prefix"`
	// chain ids associated with the ecosystem
	ChainIDs []uint64 `json:"chainIds" db:"chain_ids"`
	// exclusive ecosystems prevent other ecosystems from using the same chains
	Exclusive    bool    `json:"exclusive" db:"exclusive"`
	ProjectCount *uint64 `json:"projectCount" db:"-"`
	// settings for the ecosystem, that collaborators can change
	Settings  *EcosystemSettings `json:"settings" db:"settings,omitempty"`
	CreatedAt time.Time          `json:"createdAt" db:"created_at,omitempty"`
	UpdatedAt time.Time          `json:"updatedAt" db:"updated_at,omitempty"`
}

type EcosystemCollaborator struct {
	// serial
	ID uint64 `json:"id" db:"id,omitempty"`
	// ref: Ecosystem.id
	EcosystemID uint64 `json:"ecosystemId" db:"ecosystem_id"`
	// ref: Users.address
	UserAddress prototyp.Hash `json:"userAddress" db:"user_address"`
	// access level
	Access    EcosystemAccess `json:"access" db:"access"`
	CreatedAt time.Time       `json:"createdAt" db:"created_at,omitempty"`
	UpdatedAt time.Time       `json:"updatedAt" db:"updated_at,omitempty"`
}

// settings that can be edited by ecosystem owner/admin
type EcosystemSettings struct {
	// Title of the ecosystem
	Title string `json:"title"`
	// Description of the ecosystem
	Description string `json:"description"`
	// Learn more
	LearnMoreButton string `json:"learnMoreButton"`
	LearnMoreURL    string `json:"learnMoreUrl"`
	// Website IDs
	CrispWebsiteID string `json:"crispWebsiteId"`
	// Themes of the ecosystem
	Themes []*ThemeSettings `json:"themes"`
}

type ThemeSettings struct {
	// Name of the theme (light, dark, etc)
	Type ThemeType `json:"type"`
	// Custom CSS for the ecosystem
	CustomCSS string `json:"customCss"`
	// Logo files
	FileLogo string `json:"fileLogo"`
	// Logo used in the landing page
	FileTitle string `json:"fileTitle"`
	// Background files
	FileBackground       string `json:"fileBackground"`
	FileBackgroundMobile string `json:"fileBackgroundMobile"`
	FileAnimation        string `json:"fileAnimation"`
}

type EcosystemLicense struct {
	// serial
	ID uint64 `json:"id" db:"id,omitempty"`
	// ref: Ecosystem.id
	EcosystemID uint64 `json:"ecosystemId" db:"ecosystem_id"`
	// if the license is the default license for the ecosystem
	IsDefault bool `json:"isDefault" db:"is_default"`
	// internal name of the license
	PackageName string `json:"packageName" db:"package_name"`
	// user facing name of the license
	Label string `json:"label" db:"label"`
	// allow to use main networks from ecosystem chains
	MainnetEnabled bool `json:"mainnetEnabled" db:"mainnet_enabled"`
	// list of default chains for the license
	DefaultChainIDs   []uint64 `json:"defaultChainIds" db:"default_chain_ids"`
	AvailableChainIDs []uint64 `json:"availableChainIds" db:"-"`
	// additional chains for special cases, like existing projects
	ExtraChainIDs []uint64 `json:"extraChainIds" db:"extra_chain_ids"`
	// quota control limits
	Limits *LimitSettings `json:"limits" db:"limits"`
	// monthly amount of gas included with the license
	GasIncluded int `json:"gasIncluded" db:"gas_included"`
	// amount of total licenses, -1 for unlimited
	TotalLicenses int `json:"totalLicenses" db:"total_licenses"`
	// amount of licenses left
	AvailableLicenses int `json:"availableLicenses" db:"-"`
	// number of users allowed to use the license
	LicensePerUser int       `json:"licensePerUser" db:"license_per_user"`
	CreatedAt      time.Time `json:"createdAt" db:"created_at,omitempty"`
	UpdatedAt      time.Time `json:"updatedAt" db:"updated_at,omitempty"`
}

type DateInterval uint16

const (
	DateInterval_DAY   DateInterval = 0
	DateInterval_WEEK  DateInterval = 1
	DateInterval_MONTH DateInterval = 2
)

var DateInterval_name = map[uint16]string{
	0: "DAY",
	1: "WEEK",
	2: "MONTH",
}

var DateInterval_value = map[string]uint16{
	"DAY":   0,
	"WEEK":  1,
	"MONTH": 2,
}

func (x DateInterval) String() string {
	return DateInterval_name[uint16(x)]
}

func (x DateInterval) MarshalText() ([]byte, error) {
	return []byte(DateInterval_name[uint16(x)]), nil
}

func (x *DateInterval) UnmarshalText(b []byte) error {
	*x = DateInterval(DateInterval_value[string(b)])
	return nil
}

func (x *DateInterval) Is(values ...DateInterval) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

// Analytics
type QueryFilter struct {
	ProjectID   *uint64    `json:"projectId"`
	EcosystemID *uint64    `json:"ecosystemId"`
	StartDate   civil.Date `json:"startDate"`
	// uses YYYY-MM-DD
	EndDate civil.Date `json:"endDate"`
	// uses YYYY-MM-DD
	DateInterval DateInterval `json:"dateInterval"`
	Collections  []string     `json:"collections"`
	TokenID      *string      `json:"tokenId"`
}

type Chart struct {
	Value float64 `json:"value"`
	Label string  `json:"label"`
}

type ChartWithPercentage struct {
	Label      string  `json:"label"`
	Total      float64 `json:"total"`
	Percentage float64 `json:"percentage"`
}

type MultiValueChart struct {
	Value map[string]float64 `json:"value"`
	Label string             `json:"label"`
}

type QueryResult struct {
	Collection string  `json:"collection" ch:"collection"`
	Source     string  `json:"source" ch:"source"`
	TokenId    *string `json:"tokenId" ch:"token_id"`
	VolumeUSD  float64 `json:"volumeUSD" ch:"volume_usd"`
	NumTokens  uint64  `json:"numTokens" ch:"num_tokens"`
	NumTxns    uint64  `json:"numTxns" ch:"num_txns"`
}

var methods = map[string]method{
	"/rpc/Analytics/TotalCompute": {
		Name:        "TotalCompute",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/ComputeByService": {
		Name:        "ComputeByService",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/DailyComputeByType": {
		Name:        "DailyComputeByType",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/DailyComputeByService": {
		Name:        "DailyComputeByService",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/GetOrderbookCollections": {
		Name:        "GetOrderbookCollections",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/CreditsPerDailyActiveUser": {
		Name:        "CreditsPerDailyActiveUser",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/CreditsPerMonthlyActiveUser": {
		Name:        "CreditsPerMonthlyActiveUser",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsTotal": {
		Name:        "WalletsTotal",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsDaily": {
		Name:        "WalletsDaily",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsMonthly": {
		Name:        "WalletsMonthly",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsByCountry": {
		Name:        "WalletsByCountry",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsByDevice": {
		Name:        "WalletsByDevice",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsByBrowser": {
		Name:        "WalletsByBrowser",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsByOS": {
		Name:        "WalletsByOS",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsByType": {
		Name:        "WalletsByType",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsTxnSentTotal": {
		Name:        "WalletsTxnSentTotal",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsTxnSentDaily": {
		Name:        "WalletsTxnSentDaily",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsTxnSentMonthly": {
		Name:        "WalletsTxnSentMonthly",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WalletsByOrigin": {
		Name:        "WalletsByOrigin",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/ConnectionsByOrigin": {
		Name:        "ConnectionsByOrigin",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MarketTxnEventTotal": {
		Name:        "MarketTxnEventTotal",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MarketTxnEventDaily": {
		Name:        "MarketTxnEventDaily",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MarketTxnEventMonthly": {
		Name:        "MarketTxnEventMonthly",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MarketWalletsTotal": {
		Name:        "MarketWalletsTotal",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MarketWalletsDaily": {
		Name:        "MarketWalletsDaily",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MarketWalletsMonthly": {
		Name:        "MarketWalletsMonthly",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/TotalWalletTxnConversionRate": {
		Name:        "TotalWalletTxnConversionRate",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/DailyWalletTxnConversionRate": {
		Name:        "DailyWalletTxnConversionRate",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MonthlyWalletTxnConversionRate": {
		Name:        "MonthlyWalletTxnConversionRate",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/DailyNewWallets": {
		Name:        "DailyNewWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MonthlyNewWallets": {
		Name:        "MonthlyNewWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/TotalNewWallets": {
		Name:        "TotalNewWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/AverageDAU": {
		Name:        "AverageDAU",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/RollingStickiness": {
		Name:        "RollingStickiness",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/AverageStickiness": {
		Name:        "AverageStickiness",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/D1RetentionByCohort": {
		Name:        "D1RetentionByCohort",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/D3RetentionByCohort": {
		Name:        "D3RetentionByCohort",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/D7RetentionByCohort": {
		Name:        "D7RetentionByCohort",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/D14RetentionByCohort": {
		Name:        "D14RetentionByCohort",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/D28RetentionByCohort": {
		Name:        "D28RetentionByCohort",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/AverageD1Retention": {
		Name:        "AverageD1Retention",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/AverageD3Retention": {
		Name:        "AverageD3Retention",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/AverageD7Retention": {
		Name:        "AverageD7Retention",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/AverageD14Retention": {
		Name:        "AverageD14Retention",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/AverageD28Retention": {
		Name:        "AverageD28Retention",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MonthlyActiveWalletsBySegment": {
		Name:        "MonthlyActiveWalletsBySegment",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MonthlyTransactingWalletsBySegment": {
		Name:        "MonthlyTransactingWalletsBySegment",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/WeeklyActiveWallets": {
		Name:        "WeeklyActiveWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/TotalViews": {
		Name:        "TotalViews",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/DailyViews": {
		Name:        "DailyViews",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/ViewsByCountry": {
		Name:        "ViewsByCountry",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/ViewsByDevice": {
		Name:        "ViewsByDevice",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/ViewsByOS": {
		Name:        "ViewsByOS",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/DailyUniqueVisitors": {
		Name:        "DailyUniqueVisitors",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/MonthlyUniqueVisitors": {
		Name:        "MonthlyUniqueVisitors",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/ActiveSessions": {
		Name:        "ActiveSessions",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/UserEvents": {
		Name:        "UserEvents",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTotalWallets": {
		Name:        "EcosystemTotalWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTotalProjects": {
		Name:        "EcosystemTotalProjects",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTotalActiveProjects": {
		Name:        "EcosystemTotalActiveProjects",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTotalDevelopers": {
		Name:        "EcosystemTotalDevelopers",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemDailyActiveWallets": {
		Name:        "EcosystemDailyActiveWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemMonthlyActiveWallets": {
		Name:        "EcosystemMonthlyActiveWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemDailyNewProjects": {
		Name:        "EcosystemDailyNewProjects",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemMonthlyNewProjects": {
		Name:        "EcosystemMonthlyNewProjects",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTotalContracts": {
		Name:        "EcosystemTotalContracts",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemMonthlyContracts": {
		Name:        "EcosystemMonthlyContracts",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTopProjectsByWallets": {
		Name:        "EcosystemTopProjectsByWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTopProjectsByActiveWallets": {
		Name:        "EcosystemTopProjectsByActiveWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTopProjectsByNewWallets": {
		Name:        "EcosystemTopProjectsByNewWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemWalletsPerProject": {
		Name:        "EcosystemWalletsPerProject",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemMonthlyWalletsPerProject": {
		Name:        "EcosystemMonthlyWalletsPerProject",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemDailyNewWallets": {
		Name:        "EcosystemDailyNewWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemMonthlyNewWallets": {
		Name:        "EcosystemMonthlyNewWallets",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTopProjectsByDeveloperActivity": {
		Name:        "EcosystemTopProjectsByDeveloperActivity",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemTotalMarketplaces": {
		Name:        "EcosystemTotalMarketplaces",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemMonthlyMarketplaces": {
		Name:        "EcosystemMonthlyMarketplaces",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemActiveMarketplaces": {
		Name:        "EcosystemActiveMarketplaces",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemWalletsByCountry": {
		Name:        "EcosystemWalletsByCountry",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemWalletsByDevice": {
		Name:        "EcosystemWalletsByDevice",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemWalletsByOS": {
		Name:        "EcosystemWalletsByOS",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemWalletsByBrowser": {
		Name:        "EcosystemWalletsByBrowser",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Analytics/EcosystemWalletsByType": {
		Name:        "EcosystemWalletsByType",
		Service:     "Analytics",
		Annotations: map[string]string{"analytics": ""},
	},
	"/rpc/Builder/Ping": {
		Name:        "Ping",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/Version": {
		Name:        "Version",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/RuntimeStatus": {
		Name:        "RuntimeStatus",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetConfiguration": {
		Name:        "GetConfiguration",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetCurrentUser": {
		Name:        "GetCurrentUser",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetCurrentUserSettings": {
		Name:        "GetCurrentUserSettings",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetEmailPreferences": {
		Name:        "GetEmailPreferences",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateEmailPreferences": {
		Name:        "UpdateEmailPreferences",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetAuthToken": {
		Name:        "GetAuthToken",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateProject": {
		Name:        "CreateProject",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetProject": {
		Name:        "GetProject",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateProject": {
		Name:        "UpdateProject",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AddProjectChain": {
		Name:        "AddProjectChain",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/RemoveProjectChain": {
		Name:        "RemoveProjectChain",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/SetProjectChains": {
		Name:        "SetProjectChains",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteProject": {
		Name:        "DeleteProject",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListProjects": {
		Name:        "ListProjects",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CountProjects": {
		Name:        "CountProjects",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetResource": {
		Name:        "GetResource",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/SetCollaborator": {
		Name:        "SetCollaborator",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetCollaborator": {
		Name:        "GetCollaborator",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListCollaborators": {
		Name:        "ListCollaborators",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteCollaborator": {
		Name:        "DeleteCollaborator",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AddServiceAccount": {
		Name:        "AddServiceAccount",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetServiceAccount": {
		Name:        "GetServiceAccount",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateContract": {
		Name:        "CreateContract",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetContract": {
		Name:        "GetContract",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateContract": {
		Name:        "UpdateContract",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/SetContractItemsAddress": {
		Name:        "SetContractItemsAddress",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteContract": {
		Name:        "DeleteContract",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListContracts": {
		Name:        "ListContracts",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ExploreContractLinks": {
		Name:        "ExploreContractLinks",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetContractLinks": {
		Name:        "GetContractLinks",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateContractSource": {
		Name:        "CreateContractSource",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteContractSource": {
		Name:        "DeleteContractSource",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListContractSources": {
		Name:        "ListContractSources",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetContractFactory": {
		Name:        "GetContractFactory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetContractSource": {
		Name:        "GetContractSource",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/SyncContracts": {
		Name:        "SyncContracts",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetContractTags": {
		Name:        "GetContractTags",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateEmailTemplate": {
		Name:        "CreateEmailTemplate",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetEmailTemplate": {
		Name:        "GetEmailTemplate",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateEmailTemplate": {
		Name:        "UpdateEmailTemplate",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GasTankStatus": {
		Name:        "GasTankStatus",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateBillingSession": {
		Name:        "CreateBillingSession",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateTopupSettings": {
		Name:        "UpdateTopupSettings",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/TopUpGasTank": {
		Name:        "TopUpGasTank",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetInvoices": {
		Name:        "GetInvoices",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/BuySubscriptionTier": {
		Name:        "BuySubscriptionTier",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CancelSubscriptionDowngrade": {
		Name:        "CancelSubscriptionDowngrade",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ChangeAccessQuotaLimit": {
		Name:        "ChangeAccessQuotaLimit",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetSubscriptionInfo": {
		Name:        "GetSubscriptionInfo",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetSubscriptionPlans": {
		Name:        "GetSubscriptionPlans",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateProjectInvitation": {
		Name:        "CreateProjectInvitation",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListProjectInvitations": {
		Name:        "ListProjectInvitations",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteProjectInvitation": {
		Name:        "DeleteProjectInvitation",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UseProjectInvitation": {
		Name:        "UseProjectInvitation",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetMarketplaceConfig": {
		Name:        "GetMarketplaceConfig",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateMarketplaceConfig": {
		Name:        "UpdateMarketplaceConfig",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteMarketplaceConfig": {
		Name:        "DeleteMarketplaceConfig",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListMarketplaceHostnames": {
		Name:        "ListMarketplaceHostnames",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AddMarketplaceHostname": {
		Name:        "AddMarketplaceHostname",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteMarkplaceHostname": {
		Name:        "DeleteMarkplaceHostname",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ChangeDefaultMarkplaceHostname": {
		Name:        "ChangeDefaultMarkplaceHostname",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ResetMarkplaceHostname": {
		Name:        "ResetMarkplaceHostname",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/SyncMarketplaceCollection": {
		Name:        "SyncMarketplaceCollection",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AddOffchainInventory": {
		Name:        "AddOffchainInventory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetOffchainInventory": {
		Name:        "GetOffchainInventory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListOffchainInventories": {
		Name:        "ListOffchainInventories",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateOffchainInventory": {
		Name:        "UpdateOffchainInventory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteOffchainInventory": {
		Name:        "DeleteOffchainInventory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListOffchainPayments": {
		Name:        "ListOffchainPayments",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetWalletConfig": {
		Name:        "GetWalletConfig",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateWalletConfig": {
		Name:        "UpdateWalletConfig",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListProjectFiles": {
		Name:        "ListProjectFiles",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteProjectFile": {
		Name:        "DeleteProjectFile",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/OnboardingMark": {
		Name:        "OnboardingMark",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/OnboardingStatus": {
		Name:        "OnboardingStatus",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetWaasSettings": {
		Name:        "GetWaasSettings",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateWaasSettings": {
		Name:        "CreateWaasSettings",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateWaasSettings": {
		Name:        "UpdateWaasSettings",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/WaasWalletStatus": {
		Name:        "WaasWalletStatus",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeployWaasWallet": {
		Name:        "DeployWaasWallet",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CloudCommerceConnect": {
		Name:        "CloudCommerceConnect",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/ListAudiences": {
		Name:        "ListAudiences",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetAudience": {
		Name:        "GetAudience",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/CreateAudience": {
		Name:        "CreateAudience",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateAudience": {
		Name:        "UpdateAudience",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/DeleteAudience": {
		Name:        "DeleteAudience",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetAudienceContacts": {
		Name:        "GetAudienceContacts",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AddAudienceContacts": {
		Name:        "AddAudienceContacts",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/RemoveAudienceContacts": {
		Name:        "RemoveAudienceContacts",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/FindAudienceContacts": {
		Name:        "FindAudienceContacts",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/RegisterAudienceContact": {
		Name:        "RegisterAudienceContact",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetRegisteredAudienceContact": {
		Name:        "GetRegisteredAudienceContact",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetAudienceRegistrationPublicStatus": {
		Name:        "GetAudienceRegistrationPublicStatus",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/IsAudienceContactRegistered": {
		Name:        "IsAudienceContactRegistered",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetTrial": {
		Name:        "GetTrial",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/StartTrial": {
		Name:        "StartTrial",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminListUsers": {
		Name:        "AdminListUsers",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminGetUser": {
		Name:        "AdminGetUser",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminFindUsers": {
		Name:        "AdminFindUsers",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminUpdateUser": {
		Name:        "AdminUpdateUser",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminGetProject": {
		Name:        "AdminGetProject",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminSetProjectOwner": {
		Name:        "AdminSetProjectOwner",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminListProjects": {
		Name:        "AdminListProjects",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminRestoreProject": {
		Name:        "AdminRestoreProject",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminGetEmailTemplate": {
		Name:        "AdminGetEmailTemplate",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminUpdateEmailTemplate": {
		Name:        "AdminUpdateEmailTemplate",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminCreateEmailTemplate": {
		Name:        "AdminCreateEmailTemplate",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminContractProjectLookup": {
		Name:        "AdminContractProjectLookup",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminCreateContractSource": {
		Name:        "AdminCreateContractSource",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminUpdateContractSource": {
		Name:        "AdminUpdateContractSource",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminGetUserOverride": {
		Name:        "AdminGetUserOverride",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminSetUserOverride": {
		Name:        "AdminSetUserOverride",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminGetBillingSettings": {
		Name:        "AdminGetBillingSettings",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminSetBillingSettings": {
		Name:        "AdminSetBillingSettings",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminSetProjectSubscriptionTier": {
		Name:        "AdminSetProjectSubscriptionTier",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminGetCreditBonus": {
		Name:        "AdminGetCreditBonus",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminSetCreditBonus": {
		Name:        "AdminSetCreditBonus",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminAddQuotaUsage": {
		Name:        "AdminAddQuotaUsage",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminListPayments": {
		Name:        "AdminListPayments",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminListPaymentLogs": {
		Name:        "AdminListPaymentLogs",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminRelayerAddressGasSponsors": {
		Name:        "AdminRelayerAddressGasSponsors",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminCloudCommerceEvent": {
		Name:        "AdminCloudCommerceEvent",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminListAuditLogs": {
		Name:        "AdminListAuditLogs",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/JobqueueListRunners": {
		Name:        "JobqueueListRunners",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/JobqueueListTasks": {
		Name:        "JobqueueListTasks",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/JobqueueGetTask": {
		Name:        "JobqueueGetTask",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/JobqueueFindTask": {
		Name:        "JobqueueFindTask",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/IsInTokenDirectory": {
		Name:        "IsInTokenDirectory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/SetTokenDirectoryFeatureIndex": {
		Name:        "SetTokenDirectoryFeatureIndex",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AddContractToTokenDirectory": {
		Name:        "AddContractToTokenDirectory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/RemoveContractFromTokenDirectory": {
		Name:        "RemoveContractFromTokenDirectory",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetContractInfoOverride": {
		Name:        "GetContractInfoOverride",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AddContractInfoOverride": {
		Name:        "AddContractInfoOverride",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/UpdateContractInfoOverride": {
		Name:        "UpdateContractInfoOverride",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/RemoveContractInfoOverride": {
		Name:        "RemoveContractInfoOverride",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/GetExtendedMarketplaceConfig": {
		Name:        "GetExtendedMarketplaceConfig",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminGetMarketplaceCollection": {
		Name:        "AdminGetMarketplaceCollection",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminListMarketplaceCollections": {
		Name:        "AdminListMarketplaceCollections",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/Builder/AdminUpdateMarketplaceCollection": {
		Name:        "AdminUpdateMarketplaceCollection",
		Service:     "Builder",
		Annotations: map[string]string{},
	},
	"/rpc/GasTank/GetBalance": {
		Name:        "GetBalance",
		Service:     "GasTank",
		Annotations: map[string]string{},
	},
	"/rpc/GasTank/AdjustProjectBalance": {
		Name:        "AdjustProjectBalance",
		Service:     "GasTank",
		Annotations: map[string]string{},
	},
	"/rpc/GasTank/SpendBalance": {
		Name:        "SpendBalance",
		Service:     "GasTank",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/CreateEcosystem": {
		Name:        "CreateEcosystem",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/GetEcosystem": {
		Name:        "GetEcosystem",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/FindEcosystem": {
		Name:        "FindEcosystem",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/UpdateEcosystem": {
		Name:        "UpdateEcosystem",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/ListEcosystems": {
		Name:        "ListEcosystems",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/SetEcosystemCollaborator": {
		Name:        "SetEcosystemCollaborator",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/GetEcosystemCollaborator": {
		Name:        "GetEcosystemCollaborator",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/ListEcosystemCollaborators": {
		Name:        "ListEcosystemCollaborators",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/CreateEcosystemLicense": {
		Name:        "CreateEcosystemLicense",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/GetEcosystemLicense": {
		Name:        "GetEcosystemLicense",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/UpdateEcosystemLicense": {
		Name:        "UpdateEcosystemLicense",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/ListEcosystemLicenses": {
		Name:        "ListEcosystemLicenses",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/DeleteEcosystemLicense": {
		Name:        "DeleteEcosystemLicense",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/GetEcosystemDefaultLicense": {
		Name:        "GetEcosystemDefaultLicense",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/SetEcosystemDefaultLicense": {
		Name:        "SetEcosystemDefaultLicense",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/AssignLicense": {
		Name:        "AssignLicense",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/UpdateEcosystemSettings": {
		Name:        "UpdateEcosystemSettings",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/SetProjectEcosystem": {
		Name:        "SetProjectEcosystem",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/ListEcosystemProjects": {
		Name:        "ListEcosystemProjects",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/GetEcosystemProject": {
		Name:        "GetEcosystemProject",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
	"/rpc/EcosystemManager/RestoreEcosystemProject": {
		Name:        "RestoreEcosystemProject",
		Service:     "EcosystemManager",
		Annotations: map[string]string{},
	},
}

func WebrpcMethods() map[string]method {
	res := make(map[string]method, len(methods))
	for k, v := range methods {
		res[k] = v
	}

	return res
}

var WebRPCServices = map[string][]string{
	"Analytics": {
		"TotalCompute",
		"ComputeByService",
		"DailyComputeByType",
		"DailyComputeByService",
		"GetOrderbookCollections",
		"CreditsPerDailyActiveUser",
		"CreditsPerMonthlyActiveUser",
		"WalletsTotal",
		"WalletsDaily",
		"WalletsMonthly",
		"WalletsByCountry",
		"WalletsByDevice",
		"WalletsByBrowser",
		"WalletsByOS",
		"WalletsByType",
		"WalletsTxnSentTotal",
		"WalletsTxnSentDaily",
		"WalletsTxnSentMonthly",
		"WalletsByOrigin",
		"ConnectionsByOrigin",
		"MarketTxnEventTotal",
		"MarketTxnEventDaily",
		"MarketTxnEventMonthly",
		"MarketWalletsTotal",
		"MarketWalletsDaily",
		"MarketWalletsMonthly",
		"TotalWalletTxnConversionRate",
		"DailyWalletTxnConversionRate",
		"MonthlyWalletTxnConversionRate",
		"DailyNewWallets",
		"MonthlyNewWallets",
		"TotalNewWallets",
		"AverageDAU",
		"RollingStickiness",
		"AverageStickiness",
		"D1RetentionByCohort",
		"D3RetentionByCohort",
		"D7RetentionByCohort",
		"D14RetentionByCohort",
		"D28RetentionByCohort",
		"AverageD1Retention",
		"AverageD3Retention",
		"AverageD7Retention",
		"AverageD14Retention",
		"AverageD28Retention",
		"MonthlyActiveWalletsBySegment",
		"MonthlyTransactingWalletsBySegment",
		"WeeklyActiveWallets",
		"TotalViews",
		"DailyViews",
		"ViewsByCountry",
		"ViewsByDevice",
		"ViewsByOS",
		"DailyUniqueVisitors",
		"MonthlyUniqueVisitors",
		"ActiveSessions",
		"UserEvents",
		"EcosystemTotalWallets",
		"EcosystemTotalProjects",
		"EcosystemTotalActiveProjects",
		"EcosystemTotalDevelopers",
		"EcosystemDailyActiveWallets",
		"EcosystemMonthlyActiveWallets",
		"EcosystemDailyNewProjects",
		"EcosystemMonthlyNewProjects",
		"EcosystemTotalContracts",
		"EcosystemMonthlyContracts",
		"EcosystemTopProjectsByWallets",
		"EcosystemTopProjectsByActiveWallets",
		"EcosystemTopProjectsByNewWallets",
		"EcosystemWalletsPerProject",
		"EcosystemMonthlyWalletsPerProject",
		"EcosystemDailyNewWallets",
		"EcosystemMonthlyNewWallets",
		"EcosystemTopProjectsByDeveloperActivity",
		"EcosystemTotalMarketplaces",
		"EcosystemMonthlyMarketplaces",
		"EcosystemActiveMarketplaces",
		"EcosystemWalletsByCountry",
		"EcosystemWalletsByDevice",
		"EcosystemWalletsByOS",
		"EcosystemWalletsByBrowser",
		"EcosystemWalletsByType",
	},
	"Builder": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"GetConfiguration",
		"GetCurrentUser",
		"GetCurrentUserSettings",
		"GetEmailPreferences",
		"UpdateEmailPreferences",
		"GetAuthToken",
		"CreateProject",
		"GetProject",
		"UpdateProject",
		"AddProjectChain",
		"RemoveProjectChain",
		"SetProjectChains",
		"DeleteProject",
		"ListProjects",
		"CountProjects",
		"GetResource",
		"SetCollaborator",
		"GetCollaborator",
		"ListCollaborators",
		"DeleteCollaborator",
		"AddServiceAccount",
		"GetServiceAccount",
		"CreateContract",
		"GetContract",
		"UpdateContract",
		"SetContractItemsAddress",
		"DeleteContract",
		"ListContracts",
		"ExploreContractLinks",
		"GetContractLinks",
		"CreateContractSource",
		"DeleteContractSource",
		"ListContractSources",
		"GetContractFactory",
		"GetContractSource",
		"SyncContracts",
		"GetContractTags",
		"CreateEmailTemplate",
		"GetEmailTemplate",
		"UpdateEmailTemplate",
		"GasTankStatus",
		"CreateBillingSession",
		"UpdateTopupSettings",
		"TopUpGasTank",
		"GetInvoices",
		"BuySubscriptionTier",
		"CancelSubscriptionDowngrade",
		"ChangeAccessQuotaLimit",
		"GetSubscriptionInfo",
		"GetSubscriptionPlans",
		"CreateProjectInvitation",
		"ListProjectInvitations",
		"DeleteProjectInvitation",
		"UseProjectInvitation",
		"GetMarketplaceConfig",
		"UpdateMarketplaceConfig",
		"DeleteMarketplaceConfig",
		"ListMarketplaceHostnames",
		"AddMarketplaceHostname",
		"DeleteMarkplaceHostname",
		"ChangeDefaultMarkplaceHostname",
		"ResetMarkplaceHostname",
		"SyncMarketplaceCollection",
		"AddOffchainInventory",
		"GetOffchainInventory",
		"ListOffchainInventories",
		"UpdateOffchainInventory",
		"DeleteOffchainInventory",
		"ListOffchainPayments",
		"GetWalletConfig",
		"UpdateWalletConfig",
		"ListProjectFiles",
		"DeleteProjectFile",
		"OnboardingMark",
		"OnboardingStatus",
		"GetWaasSettings",
		"CreateWaasSettings",
		"UpdateWaasSettings",
		"WaasWalletStatus",
		"DeployWaasWallet",
		"CloudCommerceConnect",
		"ListAudiences",
		"GetAudience",
		"CreateAudience",
		"UpdateAudience",
		"DeleteAudience",
		"GetAudienceContacts",
		"AddAudienceContacts",
		"RemoveAudienceContacts",
		"FindAudienceContacts",
		"RegisterAudienceContact",
		"GetRegisteredAudienceContact",
		"GetAudienceRegistrationPublicStatus",
		"IsAudienceContactRegistered",
		"GetTrial",
		"StartTrial",
		"AdminListUsers",
		"AdminGetUser",
		"AdminFindUsers",
		"AdminUpdateUser",
		"AdminGetProject",
		"AdminSetProjectOwner",
		"AdminListProjects",
		"AdminRestoreProject",
		"AdminGetEmailTemplate",
		"AdminUpdateEmailTemplate",
		"AdminCreateEmailTemplate",
		"AdminContractProjectLookup",
		"AdminCreateContractSource",
		"AdminUpdateContractSource",
		"AdminGetUserOverride",
		"AdminSetUserOverride",
		"AdminGetBillingSettings",
		"AdminSetBillingSettings",
		"AdminSetProjectSubscriptionTier",
		"AdminGetCreditBonus",
		"AdminSetCreditBonus",
		"AdminAddQuotaUsage",
		"AdminListPayments",
		"AdminListPaymentLogs",
		"AdminRelayerAddressGasSponsors",
		"AdminCloudCommerceEvent",
		"AdminListAuditLogs",
		"JobqueueListRunners",
		"JobqueueListTasks",
		"JobqueueGetTask",
		"JobqueueFindTask",
		"IsInTokenDirectory",
		"SetTokenDirectoryFeatureIndex",
		"AddContractToTokenDirectory",
		"RemoveContractFromTokenDirectory",
		"GetContractInfoOverride",
		"AddContractInfoOverride",
		"UpdateContractInfoOverride",
		"RemoveContractInfoOverride",
		"GetExtendedMarketplaceConfig",
		"AdminGetMarketplaceCollection",
		"AdminListMarketplaceCollections",
		"AdminUpdateMarketplaceCollection",
	},
	"GasTank": {
		"GetBalance",
		"AdjustProjectBalance",
		"SpendBalance",
	},
	"EcosystemManager": {
		"CreateEcosystem",
		"GetEcosystem",
		"FindEcosystem",
		"UpdateEcosystem",
		"ListEcosystems",
		"SetEcosystemCollaborator",
		"GetEcosystemCollaborator",
		"ListEcosystemCollaborators",
		"CreateEcosystemLicense",
		"GetEcosystemLicense",
		"UpdateEcosystemLicense",
		"ListEcosystemLicenses",
		"DeleteEcosystemLicense",
		"GetEcosystemDefaultLicense",
		"SetEcosystemDefaultLicense",
		"AssignLicense",
		"UpdateEcosystemSettings",
		"SetProjectEcosystem",
		"ListEcosystemProjects",
		"GetEcosystemProject",
		"RestoreEcosystemProject",
	},
}

//
// Server types
//

type Analytics interface {
	TotalCompute(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	ComputeByService(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	DailyComputeByType(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	DailyComputeByService(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error)
	GetOrderbookCollections(ctx context.Context, filter *QueryFilter) ([]*QueryResult, error)
	CreditsPerDailyActiveUser(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	CreditsPerMonthlyActiveUser(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	WalletsTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByBrowser(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByType(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsTxnSentTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsTxnSentDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsTxnSentMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsByOrigin(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	ConnectionsByOrigin(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	MarketTxnEventTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketTxnEventDaily(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	MarketTxnEventMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketWalletsTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketWalletsDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketWalletsMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	TotalWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	DailyWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MonthlyWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	DailyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MonthlyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	TotalNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageDAU(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	RollingStickiness(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageStickiness(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D1RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D3RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D7RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D14RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D28RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD1Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD3Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD7Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD14Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD28Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MonthlyActiveWalletsBySegment(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error)
	MonthlyTransactingWalletsBySegment(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error)
	WeeklyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	// Views Analytics
	TotalViews(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	DailyViews(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	ViewsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	ViewsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	ViewsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	// Visitors Analytics
	DailyUniqueVisitors(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	MonthlyUniqueVisitors(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	// Real-time Analytics
	ActiveSessions(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	UserEvents(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	// Ecosystem Analytics
	EcosystemTotalWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalActiveProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalDevelopers(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemDailyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemDailyNewProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyNewProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalContracts(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyContracts(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTopProjectsByWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemTopProjectsByActiveWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemTopProjectsByNewWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemWalletsPerProject(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyWalletsPerProject(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemDailyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTopProjectsByDeveloperActivity(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemTotalMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemActiveMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemWalletsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByBrowser(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByType(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
}

type Builder interface {
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	GetConfiguration(ctx context.Context, name *string, domain *string) (*Configuration, error)
	// Users
	GetCurrentUser(ctx context.Context) (*User, error)
	GetCurrentUserSettings(ctx context.Context) (*UserSettings, error)
	GetEmailPreferences(ctx context.Context) (map[string]bool, map[string]string, error)
	UpdateEmailPreferences(ctx context.Context, preferences map[string]bool) (bool, error)
	GetAuthToken(ctx context.Context, ethauthProof string, email *string) (bool, *AuthState, error)
	// Projects
	CreateProject(ctx context.Context, name string, options *CreateProjectOptions) (*Project, error)
	GetProject(ctx context.Context, id uint64) (*Project, error)
	UpdateProject(ctx context.Context, projectId uint64, project *Project) (bool, error)
	AddProjectChain(ctx context.Context, projectId uint64, chainId uint64) (bool, []uint64, error)
	RemoveProjectChain(ctx context.Context, projectId uint64, chainId uint64) (bool, []uint64, error)
	SetProjectChains(ctx context.Context, projectId uint64, chainIds []uint64) (bool, error)
	DeleteProject(ctx context.Context, projectId uint64) (bool, error)
	ListProjects(ctx context.Context, chainId *uint64, page *Page) (*Page, []*Project, error)
	CountProjects(ctx context.Context, chainId *uint64) (int64, error)
	// Project -> Resources
	GetResource(ctx context.Context, parentId *uint64, resourceType ResourceType, filter *ResourceFilter) (*Resource, error)
	// Project > Collaborators
	SetCollaborator(ctx context.Context, projectId uint64, userAddress string, access *CollaboratorAccess) (*Collaborator, error)
	GetCollaborator(ctx context.Context, projectId uint64, userAddress string) (*Collaborator, error)
	ListCollaborators(ctx context.Context, projectId uint64, collaboratorType *CollaboratorType, page *Page) (*Page, []*Collaborator, error)
	DeleteCollaborator(ctx context.Context, projectId uint64, userAddress string) (bool, error)
	AddServiceAccount(ctx context.Context, projectId uint64, access *CollaboratorAccess) (*Collaborator, string, error)
	GetServiceAccount(ctx context.Context, projectId uint64, address string) (*Collaborator, string, error)
	// Project > Contracts
	CreateContract(ctx context.Context, projectId uint64, contract *Contract) (*Contract, error)
	GetContract(ctx context.Context, id uint64) (*Contract, error)
	UpdateContract(ctx context.Context, id uint64, contract *Contract) (bool, error)
	SetContractItemsAddress(ctx context.Context, id uint64, address string) (*Contract, error)
	DeleteContract(ctx context.Context, id uint64) (bool, error)
	ListContracts(ctx context.Context, projectId uint64, filter *ContractFilter, page *Page) (*Page, []*Contract, error)
	ExploreContractLinks(ctx context.Context, contractAddress string, chainId *uint64, onlyLinked *bool, page *Page) (*Page, []*ContractLink, error)
	GetContractLinks(ctx context.Context, projectId uint64, id uint64) ([]*Contract, error)
	// Project > Contracts
	CreateContractSource(ctx context.Context, projectId uint64, contractSource *NewContractSource) (*ContractSource, error)
	DeleteContractSource(ctx context.Context, projectId uint64, uid string) (bool, error)
	ListContractSources(ctx context.Context, projectId *uint64, page *Page) (*Page, []*ContractSource, error)
	GetContractFactory(ctx context.Context, chainId uint64, uid string) (*ContractFactory, error)
	GetContractSource(ctx context.Context, uid string) (*ContractSource, error)
	SyncContracts(ctx context.Context, projectId uint64, chainId uint64, contractAddress string, sync *ContractSync) (bool, error)
	GetContractTags(ctx context.Context, projectId uint64) ([]*ContractTag, error)
	// Project > Email Templates
	CreateEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType, subject string, introText string, logoUrl string) (*EmailTemplate, error)
	GetEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType) (*EmailTemplate, error)
	UpdateEmailTemplate(ctx context.Context, update *EmailTemplate) (*EmailTemplate, error)
	// Payments
	GasTankStatus(ctx context.Context, projectId uint64) (*GasTankStatus, error)
	CreateBillingSession(ctx context.Context, projectId uint64, path string) (*Redirect, error)
	UpdateTopupSettings(ctx context.Context, projectId uint64, settings *TopUpSettings) (bool, error)
	TopUpGasTank(ctx context.Context, projectId uint64, amount float64) (bool, error)
	GetInvoices(ctx context.Context, projectId uint64, before *time.Time) (*InvoicesReturn, error)
	// Subscriptions
	BuySubscriptionTier(ctx context.Context, projectId uint64, tier SubscriptionTier) (*Redirect, error)
	CancelSubscriptionDowngrade(ctx context.Context, projectId uint64, tier SubscriptionTier) (bool, error)
	ChangeAccessQuotaLimit(ctx context.Context, projectId uint64, creditsOverageWarn *uint64, creditsOverageMax *uint64) (bool, error)
	GetSubscriptionInfo(ctx context.Context, projectId uint64) (*SubscriptionInfo, error)
	GetSubscriptionPlans(ctx context.Context) (*SubscriptionPlans, error)
	// ProjectInvitations
	CreateProjectInvitation(ctx context.Context, projectId uint64, access *CollaboratorAccess, expiresAt *time.Time, signupLimit *uint64) (*ProjectInvitation, error)
	ListProjectInvitations(ctx context.Context, projectId uint64) ([]*ProjectInvitation, error)
	DeleteProjectInvitation(ctx context.Context, invitationId uint64) (bool, error)
	UseProjectInvitation(ctx context.Context, invitationCode string) (bool, uint64, error)
	// Marketplace
	GetMarketplaceConfig(ctx context.Context, projectId uint64) (*MarketplaceConfig, error)
	UpdateMarketplaceConfig(ctx context.Context, projectId uint64, settings *MarketplaceConfig) (bool, error)
	DeleteMarketplaceConfig(ctx context.Context, projectId uint64) (bool, error)
	ListMarketplaceHostnames(ctx context.Context, projectId uint64) ([]*MarketplaceHostname, error)
	AddMarketplaceHostname(ctx context.Context, projectId uint64, domain string, custom bool) (uint64, error)
	DeleteMarkplaceHostname(ctx context.Context, projectId uint64, hostnameID uint64) (bool, error)
	ChangeDefaultMarkplaceHostname(ctx context.Context, projectId uint64) (uint64, error)
	ResetMarkplaceHostname(ctx context.Context, projectId uint64) (bool, error)
	SyncMarketplaceCollection(ctx context.Context, projectId uint64, contractAddress string, chainId uint64) (bool, error)
	// Inventory payments and management
	AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error)
	GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error)
	ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error)
	UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error
	DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error)
	ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error)
	// Wallet Config
	GetWalletConfig(ctx context.Context, projectId uint64, platform string) (*WalletConfig, error)
	UpdateWalletConfig(ctx context.Context, projectId uint64, platform string, config *WalletConfig) (bool, error)
	// ProjectFile
	ListProjectFiles(ctx context.Context, projectId uint64, scope *FileScope) ([]*ProjectFile, error)
	DeleteProjectFile(ctx context.Context, id uint64) (bool, error)
	// Onboarding
	OnboardingMark(ctx context.Context, projectId uint64, step OnboardingStep) (bool, error)
	OnboardingStatus(ctx context.Context, projectId uint64) ([]OnboardingStep, error)
	// WaaS
	GetWaasSettings(ctx context.Context, projectId uint64) (*WaasSettings, error)
	CreateWaasSettings(ctx context.Context, projectId uint64, recoveryAddress string, auth *WaasAuthConfig, oidcProviders []*OpenIdProvider, allowedOrigins []string, password *string) (*WaasSettings, error)
	UpdateWaasSettings(ctx context.Context, projectId uint64, updateCode string, auth *WaasAuthConfig, oidcProviders []*OpenIdProvider, allowedOrigins []string) (*WaasSettings, error)
	WaasWalletStatus(ctx context.Context, projectId uint64) ([]*WaasWalletStatus, error)
	DeployWaasWallet(ctx context.Context, projectId uint64, chainId uint64) (string, string, error)
	// Cloud Commerce
	CloudCommerceConnect(ctx context.Context, projectId uint64, accountId string) (bool, error)
	// Audience
	ListAudiences(ctx context.Context, projectId uint64) ([]*Audience, error)
	GetAudience(ctx context.Context, projectId uint64, audienceId uint64) (*Audience, []*Contract, error)
	CreateAudience(ctx context.Context, projectId uint64, name string) (*Audience, error)
	UpdateAudience(ctx context.Context, projectId uint64, audienceId uint64, name string) (*Audience, error)
	DeleteAudience(ctx context.Context, projectId uint64, audienceId uint64) (bool, error)
	// Audience Contacts
	GetAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, page *Page) (*Audience, []*AudienceContact, *Page, error)
	AddAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, contacts []*AudienceContact) (bool, error)
	RemoveAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, contactIds []uint64) (bool, error)
	FindAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, address *string, email *string) ([]*AudienceContact, error)
	// Audience Registration (public)
	RegisterAudienceContact(ctx context.Context, projectId uint64, audienceId uint64, contact *AudienceContact, walletProof *WalletProof) (bool, error)
	GetRegisteredAudienceContact(ctx context.Context, projectId uint64, audienceId uint64, walletProof *WalletProof) (*AudienceContact, error)
	GetAudienceRegistrationPublicStatus(ctx context.Context, projectId uint64, audienceId uint64) (*AudienceRegistrationStatus, error)
	IsAudienceContactRegistered(ctx context.Context, projectId uint64, audienceId uint64, walletAddress string) (bool, error)
	// Trials
	GetTrial(ctx context.Context, projectId uint64, trialType TrialType) (*Trial, error)
	StartTrial(ctx context.Context, projectId uint64, trialType TrialType) (*Trial, error)
	// TODO: - move those methods to separate service
	// service Admin
	// Users
	AdminListUsers(ctx context.Context, email *string, address *string, sysAdmin *bool, page *Page) (*Page, []*User, error)
	AdminGetUser(ctx context.Context, address string) (*User, error)
	AdminFindUsers(ctx context.Context, email string) ([]*User, error)
	AdminUpdateUser(ctx context.Context, address string, email *string, sysAdmin *bool) (*User, error)
	// Projects
	AdminGetProject(ctx context.Context, projectId uint64) (*Project, []*ProjectSubscription, error)
	AdminSetProjectOwner(ctx context.Context, projectId uint64, address string) (bool, error)
	AdminListProjects(ctx context.Context, ecosystemId *uint64, filter *ProjectListFilter, page *Page) (*Page, []*Project, error)
	AdminRestoreProject(ctx context.Context, projectId uint64) (bool, error)
	// Email Templates
	AdminGetEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType) (*EmailTemplate, error)
	AdminUpdateEmailTemplate(ctx context.Context, projectId uint64, update *EmailTemplate) (*EmailTemplate, error)
	AdminCreateEmailTemplate(ctx context.Context, projectId uint64, template *EmailTemplate) (*EmailTemplate, error)
	// Contracts
	AdminContractProjectLookup(ctx context.Context, chainId uint64, address string) ([]*Contract, error)
	AdminCreateContractSource(ctx context.Context, contractFactory *NewContractSource) (*ContractSource, error)
	AdminUpdateContractSource(ctx context.Context, uid string, contractSource *ContractSource) (bool, error)
	// User Settings
	AdminGetUserOverride(ctx context.Context, userAddress string) (*UserSettings, *UserOverride, error)
	AdminSetUserOverride(ctx context.Context, override *UserOverride) (*UserSettings, error)
	// Subscriptions
	AdminGetBillingSettings(ctx context.Context, projectId uint64) (*BillingOverride, error)
	AdminSetBillingSettings(ctx context.Context, projectId uint64, settings *BillingOverride) (bool, error)
	AdminSetProjectSubscriptionTier(ctx context.Context, projectId uint64, tier SubscriptionTier) (*Project, error)
	AdminGetCreditBonus(ctx context.Context, projectId uint64) (uint64, uint64, error)
	AdminSetCreditBonus(ctx context.Context, projectId uint64, amount uint64) (uint64, uint64, error)
	AdminAddQuotaUsage(ctx context.Context, projectId uint64, now *time.Time, service string, amount int64) (bool, error)
	AdminListPayments(ctx context.Context, page *Page, status *PaymentStatus, provider *PaymentProvider, projectID *uint64) ([]*Payment, error)
	AdminListPaymentLogs(ctx context.Context, paymentID uint64) ([]*PaymentLog, error)
	// Relayer Gas Tanks
	AdminRelayerAddressGasSponsors(ctx context.Context, chainId uint64, address string, page *Page) (*Page, []*RelayerGasSponsor, error)
	// Cloud Commerce
	AdminCloudCommerceEvent(ctx context.Context, eventId string, payload map[string]interface{}) (bool, error)
	// Audit
	AdminListAuditLogs(ctx context.Context, projectId *uint64, walletAddress *string, auditType *AuditType, email *string, page *Page) ([]*AuditLog, *Page, error)
	// JobQueue
	JobqueueListRunners(ctx context.Context, workGroup *string) ([]*TaskRunner, error)
	JobqueueListTasks(ctx context.Context, queue *string, status *TaskStatus, page *Page) (*Page, []*Task, error)
	JobqueueGetTask(ctx context.Context, id uint64) (*Task, error)
	JobqueueFindTask(ctx context.Context, queue string, hash string) (*Task, error)
	// Token Directory
	IsInTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, uint8, error)
	SetTokenDirectoryFeatureIndex(ctx context.Context, chainId uint64, address string, featureIndex uint8) (bool, error)
	AddContractToTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, error)
	RemoveContractFromTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, error)
	// Metadata info override
	GetContractInfoOverride(ctx context.Context, chainId uint64, address string) (*ContractInfoOverride, error)
	AddContractInfoOverride(ctx context.Context, chainId uint64, address string, contractInfoOverride *ContractInfoOverride) (bool, error)
	UpdateContractInfoOverride(ctx context.Context, chainId uint64, address string, contractInfoOverride *ContractInfoOverride) (bool, error)
	RemoveContractInfoOverride(ctx context.Context, chainId uint64, address string) (bool, error)
	// Marketplace
	GetExtendedMarketplaceConfig(ctx context.Context, hostname string) (*ExtendedMarketplaceConfig, error)
	// Marketplace Collection Management
	AdminGetMarketplaceCollection(ctx context.Context, projectId uint64, chainId uint64, contractAddress string) (*AdminMarketplaceCollection, error)
	AdminListMarketplaceCollections(ctx context.Context, projectId uint64, chainId uint64, page *Page) ([]*AdminMarketplaceCollection, *Page, error)
	AdminUpdateMarketplaceCollection(ctx context.Context, projectId uint64, collection *AdminMarketplaceCollection) (*AdminMarketplaceCollection, error)
}

type GasTank interface {
	GetBalance(ctx context.Context, projectId uint64) (bool, float64, float64, error)
	AdjustProjectBalance(ctx context.Context, projectId uint64, amount float64, identifier string) (float64, error)
	SpendBalance(ctx context.Context, projectId uint64, amount float64) (float64, error)
}

type EcosystemManager interface {
	// Ecosystems
	CreateEcosystem(ctx context.Context, ecosystem *Ecosystem) (*Ecosystem, error)
	GetEcosystem(ctx context.Context, id uint64) (*Ecosystem, error)
	FindEcosystem(ctx context.Context, name *string, domain *string) (*Ecosystem, error)
	UpdateEcosystem(ctx context.Context, id uint64, ecosystem *Ecosystem) (bool, error)
	ListEcosystems(ctx context.Context, query *string, ecosystemType *EcosystemType, page *Page) (*Page, []*Ecosystem, error)
	// Ecosystem > Collaborators
	SetEcosystemCollaborator(ctx context.Context, id uint64, userAddress string, access *EcosystemAccess) (bool, error)
	GetEcosystemCollaborator(ctx context.Context, id uint64, userAddress string) (*EcosystemCollaborator, error)
	ListEcosystemCollaborators(ctx context.Context, id uint64, page *Page) (*Page, []*EcosystemCollaborator, error)
	// Ecosystem > Licenses
	CreateEcosystemLicense(ctx context.Context, license *EcosystemLicense) (*EcosystemLicense, error)
	GetEcosystemLicense(ctx context.Context, id uint64) (*EcosystemLicense, error)
	UpdateEcosystemLicense(ctx context.Context, id uint64, license *EcosystemLicense) (bool, error)
	ListEcosystemLicenses(ctx context.Context, ecosystemId uint64, page *Page) (*Page, []*EcosystemLicense, error)
	DeleteEcosystemLicense(ctx context.Context, id uint64) (bool, error)
	GetEcosystemDefaultLicense(ctx context.Context, ecosystemId uint64) (*EcosystemLicense, error)
	SetEcosystemDefaultLicense(ctx context.Context, ecosystemId uint64, licenseId uint64) (bool, error)
	AssignLicense(ctx context.Context, licenseId uint64, projectId uint64) (bool, error)
	// EcosystemSettings
	UpdateEcosystemSettings(ctx context.Context, id uint64, settings *EcosystemSettings) (bool, error)
	// Ecosystem > Projects
	SetProjectEcosystem(ctx context.Context, projectId uint64, ecosystemId *uint64) (bool, error)
	ListEcosystemProjects(ctx context.Context, ecosystemId uint64, filter *ProjectListFilter, page *Page) (*Page, []*Project, error)
	GetEcosystemProject(ctx context.Context, ecosystemId uint64, projectId uint64) (*Project, error)
	RestoreEcosystemProject(ctx context.Context, ecosystemId uint64, projectId uint64) (bool, error)
}

//
// Client types
//

type AnalyticsClient interface {
	TotalCompute(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	ComputeByService(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	DailyComputeByType(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	DailyComputeByService(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error)
	GetOrderbookCollections(ctx context.Context, filter *QueryFilter) ([]*QueryResult, error)
	CreditsPerDailyActiveUser(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	CreditsPerMonthlyActiveUser(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	WalletsTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByBrowser(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsByType(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	WalletsTxnSentTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsTxnSentDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsTxnSentMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	WalletsByOrigin(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	ConnectionsByOrigin(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	MarketTxnEventTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketTxnEventDaily(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	MarketTxnEventMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketWalletsTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketWalletsDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MarketWalletsMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	TotalWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	DailyWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MonthlyWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	DailyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MonthlyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	TotalNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageDAU(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	RollingStickiness(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageStickiness(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D1RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D3RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D7RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D14RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	D28RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD1Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD3Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD7Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD14Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	AverageD28Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	MonthlyActiveWalletsBySegment(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error)
	MonthlyTransactingWalletsBySegment(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error)
	WeeklyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	// Views Analytics
	TotalViews(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	DailyViews(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	ViewsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	ViewsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	ViewsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	// Visitors Analytics
	DailyUniqueVisitors(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	MonthlyUniqueVisitors(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	// Real-time Analytics
	ActiveSessions(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	UserEvents(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	// Ecosystem Analytics
	EcosystemTotalWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalActiveProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalDevelopers(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemDailyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemDailyNewProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyNewProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTotalContracts(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyContracts(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTopProjectsByWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemTopProjectsByActiveWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemTopProjectsByNewWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemWalletsPerProject(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyWalletsPerProject(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemDailyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemTopProjectsByDeveloperActivity(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error)
	EcosystemTotalMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemMonthlyMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemActiveMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error)
	EcosystemWalletsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByBrowser(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
	EcosystemWalletsByType(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error)
}

type BuilderClient interface {
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	GetConfiguration(ctx context.Context, name *string, domain *string) (*Configuration, error)
	// Users
	GetCurrentUser(ctx context.Context) (*User, error)
	GetCurrentUserSettings(ctx context.Context) (*UserSettings, error)
	GetEmailPreferences(ctx context.Context) (map[string]bool, map[string]string, error)
	UpdateEmailPreferences(ctx context.Context, preferences map[string]bool) (bool, error)
	GetAuthToken(ctx context.Context, ethauthProof string, email *string) (bool, *AuthState, error)
	// Projects
	CreateProject(ctx context.Context, name string, options *CreateProjectOptions) (*Project, error)
	GetProject(ctx context.Context, id uint64) (*Project, error)
	UpdateProject(ctx context.Context, projectId uint64, project *Project) (bool, error)
	AddProjectChain(ctx context.Context, projectId uint64, chainId uint64) (bool, []uint64, error)
	RemoveProjectChain(ctx context.Context, projectId uint64, chainId uint64) (bool, []uint64, error)
	SetProjectChains(ctx context.Context, projectId uint64, chainIds []uint64) (bool, error)
	DeleteProject(ctx context.Context, projectId uint64) (bool, error)
	ListProjects(ctx context.Context, chainId *uint64, page *Page) (*Page, []*Project, error)
	CountProjects(ctx context.Context, chainId *uint64) (int64, error)
	// Project -> Resources
	GetResource(ctx context.Context, parentId *uint64, resourceType ResourceType, filter *ResourceFilter) (*Resource, error)
	// Project > Collaborators
	SetCollaborator(ctx context.Context, projectId uint64, userAddress string, access *CollaboratorAccess) (*Collaborator, error)
	GetCollaborator(ctx context.Context, projectId uint64, userAddress string) (*Collaborator, error)
	ListCollaborators(ctx context.Context, projectId uint64, collaboratorType *CollaboratorType, page *Page) (*Page, []*Collaborator, error)
	DeleteCollaborator(ctx context.Context, projectId uint64, userAddress string) (bool, error)
	AddServiceAccount(ctx context.Context, projectId uint64, access *CollaboratorAccess) (*Collaborator, string, error)
	GetServiceAccount(ctx context.Context, projectId uint64, address string) (*Collaborator, string, error)
	// Project > Contracts
	CreateContract(ctx context.Context, projectId uint64, contract *Contract) (*Contract, error)
	GetContract(ctx context.Context, id uint64) (*Contract, error)
	UpdateContract(ctx context.Context, id uint64, contract *Contract) (bool, error)
	SetContractItemsAddress(ctx context.Context, id uint64, address string) (*Contract, error)
	DeleteContract(ctx context.Context, id uint64) (bool, error)
	ListContracts(ctx context.Context, projectId uint64, filter *ContractFilter, page *Page) (*Page, []*Contract, error)
	ExploreContractLinks(ctx context.Context, contractAddress string, chainId *uint64, onlyLinked *bool, page *Page) (*Page, []*ContractLink, error)
	GetContractLinks(ctx context.Context, projectId uint64, id uint64) ([]*Contract, error)
	// Project > Contracts
	CreateContractSource(ctx context.Context, projectId uint64, contractSource *NewContractSource) (*ContractSource, error)
	DeleteContractSource(ctx context.Context, projectId uint64, uid string) (bool, error)
	ListContractSources(ctx context.Context, projectId *uint64, page *Page) (*Page, []*ContractSource, error)
	GetContractFactory(ctx context.Context, chainId uint64, uid string) (*ContractFactory, error)
	GetContractSource(ctx context.Context, uid string) (*ContractSource, error)
	SyncContracts(ctx context.Context, projectId uint64, chainId uint64, contractAddress string, sync *ContractSync) (bool, error)
	GetContractTags(ctx context.Context, projectId uint64) ([]*ContractTag, error)
	// Project > Email Templates
	CreateEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType, subject string, introText string, logoUrl string) (*EmailTemplate, error)
	GetEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType) (*EmailTemplate, error)
	UpdateEmailTemplate(ctx context.Context, update *EmailTemplate) (*EmailTemplate, error)
	// Payments
	GasTankStatus(ctx context.Context, projectId uint64) (*GasTankStatus, error)
	CreateBillingSession(ctx context.Context, projectId uint64, path string) (*Redirect, error)
	UpdateTopupSettings(ctx context.Context, projectId uint64, settings *TopUpSettings) (bool, error)
	TopUpGasTank(ctx context.Context, projectId uint64, amount float64) (bool, error)
	GetInvoices(ctx context.Context, projectId uint64, before *time.Time) (*InvoicesReturn, error)
	// Subscriptions
	BuySubscriptionTier(ctx context.Context, projectId uint64, tier SubscriptionTier) (*Redirect, error)
	CancelSubscriptionDowngrade(ctx context.Context, projectId uint64, tier SubscriptionTier) (bool, error)
	ChangeAccessQuotaLimit(ctx context.Context, projectId uint64, creditsOverageWarn *uint64, creditsOverageMax *uint64) (bool, error)
	GetSubscriptionInfo(ctx context.Context, projectId uint64) (*SubscriptionInfo, error)
	GetSubscriptionPlans(ctx context.Context) (*SubscriptionPlans, error)
	// ProjectInvitations
	CreateProjectInvitation(ctx context.Context, projectId uint64, access *CollaboratorAccess, expiresAt *time.Time, signupLimit *uint64) (*ProjectInvitation, error)
	ListProjectInvitations(ctx context.Context, projectId uint64) ([]*ProjectInvitation, error)
	DeleteProjectInvitation(ctx context.Context, invitationId uint64) (bool, error)
	UseProjectInvitation(ctx context.Context, invitationCode string) (bool, uint64, error)
	// Marketplace
	GetMarketplaceConfig(ctx context.Context, projectId uint64) (*MarketplaceConfig, error)
	UpdateMarketplaceConfig(ctx context.Context, projectId uint64, settings *MarketplaceConfig) (bool, error)
	DeleteMarketplaceConfig(ctx context.Context, projectId uint64) (bool, error)
	ListMarketplaceHostnames(ctx context.Context, projectId uint64) ([]*MarketplaceHostname, error)
	AddMarketplaceHostname(ctx context.Context, projectId uint64, domain string, custom bool) (uint64, error)
	DeleteMarkplaceHostname(ctx context.Context, projectId uint64, hostnameID uint64) (bool, error)
	ChangeDefaultMarkplaceHostname(ctx context.Context, projectId uint64) (uint64, error)
	ResetMarkplaceHostname(ctx context.Context, projectId uint64) (bool, error)
	SyncMarketplaceCollection(ctx context.Context, projectId uint64, contractAddress string, chainId uint64) (bool, error)
	// Inventory payments and management
	AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error)
	GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error)
	ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error)
	UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error
	DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error)
	ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error)
	// Wallet Config
	GetWalletConfig(ctx context.Context, projectId uint64, platform string) (*WalletConfig, error)
	UpdateWalletConfig(ctx context.Context, projectId uint64, platform string, config *WalletConfig) (bool, error)
	// ProjectFile
	ListProjectFiles(ctx context.Context, projectId uint64, scope *FileScope) ([]*ProjectFile, error)
	DeleteProjectFile(ctx context.Context, id uint64) (bool, error)
	// Onboarding
	OnboardingMark(ctx context.Context, projectId uint64, step OnboardingStep) (bool, error)
	OnboardingStatus(ctx context.Context, projectId uint64) ([]OnboardingStep, error)
	// WaaS
	GetWaasSettings(ctx context.Context, projectId uint64) (*WaasSettings, error)
	CreateWaasSettings(ctx context.Context, projectId uint64, recoveryAddress string, auth *WaasAuthConfig, oidcProviders []*OpenIdProvider, allowedOrigins []string, password *string) (*WaasSettings, error)
	UpdateWaasSettings(ctx context.Context, projectId uint64, updateCode string, auth *WaasAuthConfig, oidcProviders []*OpenIdProvider, allowedOrigins []string) (*WaasSettings, error)
	WaasWalletStatus(ctx context.Context, projectId uint64) ([]*WaasWalletStatus, error)
	DeployWaasWallet(ctx context.Context, projectId uint64, chainId uint64) (string, string, error)
	// Cloud Commerce
	CloudCommerceConnect(ctx context.Context, projectId uint64, accountId string) (bool, error)
	// Audience
	ListAudiences(ctx context.Context, projectId uint64) ([]*Audience, error)
	GetAudience(ctx context.Context, projectId uint64, audienceId uint64) (*Audience, []*Contract, error)
	CreateAudience(ctx context.Context, projectId uint64, name string) (*Audience, error)
	UpdateAudience(ctx context.Context, projectId uint64, audienceId uint64, name string) (*Audience, error)
	DeleteAudience(ctx context.Context, projectId uint64, audienceId uint64) (bool, error)
	// Audience Contacts
	GetAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, page *Page) (*Audience, []*AudienceContact, *Page, error)
	AddAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, contacts []*AudienceContact) (bool, error)
	RemoveAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, contactIds []uint64) (bool, error)
	FindAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, address *string, email *string) ([]*AudienceContact, error)
	// Audience Registration (public)
	RegisterAudienceContact(ctx context.Context, projectId uint64, audienceId uint64, contact *AudienceContact, walletProof *WalletProof) (bool, error)
	GetRegisteredAudienceContact(ctx context.Context, projectId uint64, audienceId uint64, walletProof *WalletProof) (*AudienceContact, error)
	GetAudienceRegistrationPublicStatus(ctx context.Context, projectId uint64, audienceId uint64) (*AudienceRegistrationStatus, error)
	IsAudienceContactRegistered(ctx context.Context, projectId uint64, audienceId uint64, walletAddress string) (bool, error)
	// Trials
	GetTrial(ctx context.Context, projectId uint64, trialType TrialType) (*Trial, error)
	StartTrial(ctx context.Context, projectId uint64, trialType TrialType) (*Trial, error)
	// TODO: - move those methods to separate service
	// service Admin
	// Users
	AdminListUsers(ctx context.Context, email *string, address *string, sysAdmin *bool, page *Page) (*Page, []*User, error)
	AdminGetUser(ctx context.Context, address string) (*User, error)
	AdminFindUsers(ctx context.Context, email string) ([]*User, error)
	AdminUpdateUser(ctx context.Context, address string, email *string, sysAdmin *bool) (*User, error)
	// Projects
	AdminGetProject(ctx context.Context, projectId uint64) (*Project, []*ProjectSubscription, error)
	AdminSetProjectOwner(ctx context.Context, projectId uint64, address string) (bool, error)
	AdminListProjects(ctx context.Context, ecosystemId *uint64, filter *ProjectListFilter, page *Page) (*Page, []*Project, error)
	AdminRestoreProject(ctx context.Context, projectId uint64) (bool, error)
	// Email Templates
	AdminGetEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType) (*EmailTemplate, error)
	AdminUpdateEmailTemplate(ctx context.Context, projectId uint64, update *EmailTemplate) (*EmailTemplate, error)
	AdminCreateEmailTemplate(ctx context.Context, projectId uint64, template *EmailTemplate) (*EmailTemplate, error)
	// Contracts
	AdminContractProjectLookup(ctx context.Context, chainId uint64, address string) ([]*Contract, error)
	AdminCreateContractSource(ctx context.Context, contractFactory *NewContractSource) (*ContractSource, error)
	AdminUpdateContractSource(ctx context.Context, uid string, contractSource *ContractSource) (bool, error)
	// User Settings
	AdminGetUserOverride(ctx context.Context, userAddress string) (*UserSettings, *UserOverride, error)
	AdminSetUserOverride(ctx context.Context, override *UserOverride) (*UserSettings, error)
	// Subscriptions
	AdminGetBillingSettings(ctx context.Context, projectId uint64) (*BillingOverride, error)
	AdminSetBillingSettings(ctx context.Context, projectId uint64, settings *BillingOverride) (bool, error)
	AdminSetProjectSubscriptionTier(ctx context.Context, projectId uint64, tier SubscriptionTier) (*Project, error)
	AdminGetCreditBonus(ctx context.Context, projectId uint64) (uint64, uint64, error)
	AdminSetCreditBonus(ctx context.Context, projectId uint64, amount uint64) (uint64, uint64, error)
	AdminAddQuotaUsage(ctx context.Context, projectId uint64, now *time.Time, service string, amount int64) (bool, error)
	AdminListPayments(ctx context.Context, page *Page, status *PaymentStatus, provider *PaymentProvider, projectID *uint64) ([]*Payment, error)
	AdminListPaymentLogs(ctx context.Context, paymentID uint64) ([]*PaymentLog, error)
	// Relayer Gas Tanks
	AdminRelayerAddressGasSponsors(ctx context.Context, chainId uint64, address string, page *Page) (*Page, []*RelayerGasSponsor, error)
	// Cloud Commerce
	AdminCloudCommerceEvent(ctx context.Context, eventId string, payload map[string]interface{}) (bool, error)
	// Audit
	AdminListAuditLogs(ctx context.Context, projectId *uint64, walletAddress *string, auditType *AuditType, email *string, page *Page) ([]*AuditLog, *Page, error)
	// JobQueue
	JobqueueListRunners(ctx context.Context, workGroup *string) ([]*TaskRunner, error)
	JobqueueListTasks(ctx context.Context, queue *string, status *TaskStatus, page *Page) (*Page, []*Task, error)
	JobqueueGetTask(ctx context.Context, id uint64) (*Task, error)
	JobqueueFindTask(ctx context.Context, queue string, hash string) (*Task, error)
	// Token Directory
	IsInTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, uint8, error)
	SetTokenDirectoryFeatureIndex(ctx context.Context, chainId uint64, address string, featureIndex uint8) (bool, error)
	AddContractToTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, error)
	RemoveContractFromTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, error)
	// Metadata info override
	GetContractInfoOverride(ctx context.Context, chainId uint64, address string) (*ContractInfoOverride, error)
	AddContractInfoOverride(ctx context.Context, chainId uint64, address string, contractInfoOverride *ContractInfoOverride) (bool, error)
	UpdateContractInfoOverride(ctx context.Context, chainId uint64, address string, contractInfoOverride *ContractInfoOverride) (bool, error)
	RemoveContractInfoOverride(ctx context.Context, chainId uint64, address string) (bool, error)
	// Marketplace
	GetExtendedMarketplaceConfig(ctx context.Context, hostname string) (*ExtendedMarketplaceConfig, error)
	// Marketplace Collection Management
	AdminGetMarketplaceCollection(ctx context.Context, projectId uint64, chainId uint64, contractAddress string) (*AdminMarketplaceCollection, error)
	AdminListMarketplaceCollections(ctx context.Context, projectId uint64, chainId uint64, page *Page) ([]*AdminMarketplaceCollection, *Page, error)
	AdminUpdateMarketplaceCollection(ctx context.Context, projectId uint64, collection *AdminMarketplaceCollection) (*AdminMarketplaceCollection, error)
}

type GasTankClient interface {
	GetBalance(ctx context.Context, projectId uint64) (bool, float64, float64, error)
	AdjustProjectBalance(ctx context.Context, projectId uint64, amount float64, identifier string) (float64, error)
	SpendBalance(ctx context.Context, projectId uint64, amount float64) (float64, error)
}

type EcosystemManagerClient interface {
	// Ecosystems
	CreateEcosystem(ctx context.Context, ecosystem *Ecosystem) (*Ecosystem, error)
	GetEcosystem(ctx context.Context, id uint64) (*Ecosystem, error)
	FindEcosystem(ctx context.Context, name *string, domain *string) (*Ecosystem, error)
	UpdateEcosystem(ctx context.Context, id uint64, ecosystem *Ecosystem) (bool, error)
	ListEcosystems(ctx context.Context, query *string, ecosystemType *EcosystemType, page *Page) (*Page, []*Ecosystem, error)
	// Ecosystem > Collaborators
	SetEcosystemCollaborator(ctx context.Context, id uint64, userAddress string, access *EcosystemAccess) (bool, error)
	GetEcosystemCollaborator(ctx context.Context, id uint64, userAddress string) (*EcosystemCollaborator, error)
	ListEcosystemCollaborators(ctx context.Context, id uint64, page *Page) (*Page, []*EcosystemCollaborator, error)
	// Ecosystem > Licenses
	CreateEcosystemLicense(ctx context.Context, license *EcosystemLicense) (*EcosystemLicense, error)
	GetEcosystemLicense(ctx context.Context, id uint64) (*EcosystemLicense, error)
	UpdateEcosystemLicense(ctx context.Context, id uint64, license *EcosystemLicense) (bool, error)
	ListEcosystemLicenses(ctx context.Context, ecosystemId uint64, page *Page) (*Page, []*EcosystemLicense, error)
	DeleteEcosystemLicense(ctx context.Context, id uint64) (bool, error)
	GetEcosystemDefaultLicense(ctx context.Context, ecosystemId uint64) (*EcosystemLicense, error)
	SetEcosystemDefaultLicense(ctx context.Context, ecosystemId uint64, licenseId uint64) (bool, error)
	AssignLicense(ctx context.Context, licenseId uint64, projectId uint64) (bool, error)
	// EcosystemSettings
	UpdateEcosystemSettings(ctx context.Context, id uint64, settings *EcosystemSettings) (bool, error)
	// Ecosystem > Projects
	SetProjectEcosystem(ctx context.Context, projectId uint64, ecosystemId *uint64) (bool, error)
	ListEcosystemProjects(ctx context.Context, ecosystemId uint64, filter *ProjectListFilter, page *Page) (*Page, []*Project, error)
	GetEcosystemProject(ctx context.Context, ecosystemId uint64, projectId uint64) (*Project, error)
	RestoreEcosystemProject(ctx context.Context, ecosystemId uint64, projectId uint64) (bool, error)
}

//
// Client
//

const AnalyticsPathPrefix = "/rpc/Analytics/"
const BuilderPathPrefix = "/rpc/Builder/"
const GasTankPathPrefix = "/rpc/GasTank/"
const EcosystemManagerPathPrefix = "/rpc/EcosystemManager/"

type analyticsClient struct {
	client HTTPClient
	urls   [83]string
}

func NewAnalyticsClient(addr string, client HTTPClient) AnalyticsClient {
	prefix := urlBase(addr) + AnalyticsPathPrefix
	urls := [83]string{
		prefix + "TotalCompute",
		prefix + "ComputeByService",
		prefix + "DailyComputeByType",
		prefix + "DailyComputeByService",
		prefix + "GetOrderbookCollections",
		prefix + "CreditsPerDailyActiveUser",
		prefix + "CreditsPerMonthlyActiveUser",
		prefix + "WalletsTotal",
		prefix + "WalletsDaily",
		prefix + "WalletsMonthly",
		prefix + "WalletsByCountry",
		prefix + "WalletsByDevice",
		prefix + "WalletsByBrowser",
		prefix + "WalletsByOS",
		prefix + "WalletsByType",
		prefix + "WalletsTxnSentTotal",
		prefix + "WalletsTxnSentDaily",
		prefix + "WalletsTxnSentMonthly",
		prefix + "WalletsByOrigin",
		prefix + "ConnectionsByOrigin",
		prefix + "MarketTxnEventTotal",
		prefix + "MarketTxnEventDaily",
		prefix + "MarketTxnEventMonthly",
		prefix + "MarketWalletsTotal",
		prefix + "MarketWalletsDaily",
		prefix + "MarketWalletsMonthly",
		prefix + "TotalWalletTxnConversionRate",
		prefix + "DailyWalletTxnConversionRate",
		prefix + "MonthlyWalletTxnConversionRate",
		prefix + "DailyNewWallets",
		prefix + "MonthlyNewWallets",
		prefix + "TotalNewWallets",
		prefix + "AverageDAU",
		prefix + "RollingStickiness",
		prefix + "AverageStickiness",
		prefix + "D1RetentionByCohort",
		prefix + "D3RetentionByCohort",
		prefix + "D7RetentionByCohort",
		prefix + "D14RetentionByCohort",
		prefix + "D28RetentionByCohort",
		prefix + "AverageD1Retention",
		prefix + "AverageD3Retention",
		prefix + "AverageD7Retention",
		prefix + "AverageD14Retention",
		prefix + "AverageD28Retention",
		prefix + "MonthlyActiveWalletsBySegment",
		prefix + "MonthlyTransactingWalletsBySegment",
		prefix + "WeeklyActiveWallets",
		prefix + "TotalViews",
		prefix + "DailyViews",
		prefix + "ViewsByCountry",
		prefix + "ViewsByDevice",
		prefix + "ViewsByOS",
		prefix + "DailyUniqueVisitors",
		prefix + "MonthlyUniqueVisitors",
		prefix + "ActiveSessions",
		prefix + "UserEvents",
		prefix + "EcosystemTotalWallets",
		prefix + "EcosystemTotalProjects",
		prefix + "EcosystemTotalActiveProjects",
		prefix + "EcosystemTotalDevelopers",
		prefix + "EcosystemDailyActiveWallets",
		prefix + "EcosystemMonthlyActiveWallets",
		prefix + "EcosystemDailyNewProjects",
		prefix + "EcosystemMonthlyNewProjects",
		prefix + "EcosystemTotalContracts",
		prefix + "EcosystemMonthlyContracts",
		prefix + "EcosystemTopProjectsByWallets",
		prefix + "EcosystemTopProjectsByActiveWallets",
		prefix + "EcosystemTopProjectsByNewWallets",
		prefix + "EcosystemWalletsPerProject",
		prefix + "EcosystemMonthlyWalletsPerProject",
		prefix + "EcosystemDailyNewWallets",
		prefix + "EcosystemMonthlyNewWallets",
		prefix + "EcosystemTopProjectsByDeveloperActivity",
		prefix + "EcosystemTotalMarketplaces",
		prefix + "EcosystemMonthlyMarketplaces",
		prefix + "EcosystemActiveMarketplaces",
		prefix + "EcosystemWalletsByCountry",
		prefix + "EcosystemWalletsByDevice",
		prefix + "EcosystemWalletsByOS",
		prefix + "EcosystemWalletsByBrowser",
		prefix + "EcosystemWalletsByType",
	}
	return &analyticsClient{
		client: client,
		urls:   urls,
	}
}

func (c *analyticsClient) TotalCompute(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"computeStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) ComputeByService(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"computeStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) DailyComputeByType(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"computeStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) DailyComputeByService(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 map[string][]*Chart `json:"computeStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) GetOrderbookCollections(ctx context.Context, filter *QueryFilter) ([]*QueryResult, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*QueryResult `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) CreditsPerDailyActiveUser(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) CreditsPerMonthlyActiveUser(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsByBrowser(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsByType(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsTxnSentTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsTxnSentDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsTxnSentMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WalletsByOrigin(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) ConnectionsByOrigin(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"walletStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MarketTxnEventTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MarketTxnEventDaily(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MarketTxnEventMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MarketWalletsTotal(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MarketWalletsDaily(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MarketWalletsMonthly(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) TotalWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) DailyWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MonthlyWalletTxnConversionRate(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"marketStats"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) DailyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MonthlyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) TotalNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) AverageDAU(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) RollingStickiness(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[33], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) AverageStickiness(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[34], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) D1RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[35], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) D3RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[36], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) D7RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[37], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) D14RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[38], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) D28RetentionByCohort(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[39], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) AverageD1Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[40], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) AverageD3Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[41], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) AverageD7Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[42], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) AverageD14Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[43], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) AverageD28Retention(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[44], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MonthlyActiveWalletsBySegment(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 map[string][]*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[45], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MonthlyTransactingWalletsBySegment(ctx context.Context, filter *QueryFilter) (map[string][]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 map[string][]*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[46], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) WeeklyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[47], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) TotalViews(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[48], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) DailyViews(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[49], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) ViewsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[50], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) ViewsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[51], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) ViewsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[52], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) DailyUniqueVisitors(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[53], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) MonthlyUniqueVisitors(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[54], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) ActiveSessions(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[55], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) UserEvents(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[56], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTotalWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[57], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTotalProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[58], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTotalActiveProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[59], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTotalDevelopers(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[60], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemDailyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[61], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemMonthlyActiveWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[62], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemDailyNewProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[63], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemMonthlyNewProjects(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[64], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTotalContracts(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[65], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemMonthlyContracts(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[66], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTopProjectsByWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[67], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTopProjectsByActiveWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[68], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTopProjectsByNewWallets(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[69], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemWalletsPerProject(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[70], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemMonthlyWalletsPerProject(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[71], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemDailyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[72], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemMonthlyNewWallets(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[73], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTopProjectsByDeveloperActivity(ctx context.Context, filter *QueryFilter) ([]*MultiValueChart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*MultiValueChart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[74], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemTotalMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[75], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemMonthlyMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[76], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemActiveMarketplaces(ctx context.Context, filter *QueryFilter) ([]*Chart, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*Chart `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[77], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemWalletsByCountry(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[78], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemWalletsByDevice(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[79], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemWalletsByOS(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[80], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemWalletsByBrowser(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[81], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *analyticsClient) EcosystemWalletsByType(ctx context.Context, filter *QueryFilter) ([]*ChartWithPercentage, error) {
	in := struct {
		Arg0 *QueryFilter `json:"filter"`
	}{filter}
	out := struct {
		Ret0 []*ChartWithPercentage `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[82], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

type builderClient struct {
	client HTTPClient
	urls   [142]string
}

func NewBuilderClient(addr string, client HTTPClient) BuilderClient {
	prefix := urlBase(addr) + BuilderPathPrefix
	urls := [142]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "GetConfiguration",
		prefix + "GetCurrentUser",
		prefix + "GetCurrentUserSettings",
		prefix + "GetEmailPreferences",
		prefix + "UpdateEmailPreferences",
		prefix + "GetAuthToken",
		prefix + "CreateProject",
		prefix + "GetProject",
		prefix + "UpdateProject",
		prefix + "AddProjectChain",
		prefix + "RemoveProjectChain",
		prefix + "SetProjectChains",
		prefix + "DeleteProject",
		prefix + "ListProjects",
		prefix + "CountProjects",
		prefix + "GetResource",
		prefix + "SetCollaborator",
		prefix + "GetCollaborator",
		prefix + "ListCollaborators",
		prefix + "DeleteCollaborator",
		prefix + "AddServiceAccount",
		prefix + "GetServiceAccount",
		prefix + "CreateContract",
		prefix + "GetContract",
		prefix + "UpdateContract",
		prefix + "SetContractItemsAddress",
		prefix + "DeleteContract",
		prefix + "ListContracts",
		prefix + "ExploreContractLinks",
		prefix + "GetContractLinks",
		prefix + "CreateContractSource",
		prefix + "DeleteContractSource",
		prefix + "ListContractSources",
		prefix + "GetContractFactory",
		prefix + "GetContractSource",
		prefix + "SyncContracts",
		prefix + "GetContractTags",
		prefix + "CreateEmailTemplate",
		prefix + "GetEmailTemplate",
		prefix + "UpdateEmailTemplate",
		prefix + "GasTankStatus",
		prefix + "CreateBillingSession",
		prefix + "UpdateTopupSettings",
		prefix + "TopUpGasTank",
		prefix + "GetInvoices",
		prefix + "BuySubscriptionTier",
		prefix + "CancelSubscriptionDowngrade",
		prefix + "ChangeAccessQuotaLimit",
		prefix + "GetSubscriptionInfo",
		prefix + "GetSubscriptionPlans",
		prefix + "CreateProjectInvitation",
		prefix + "ListProjectInvitations",
		prefix + "DeleteProjectInvitation",
		prefix + "UseProjectInvitation",
		prefix + "GetMarketplaceConfig",
		prefix + "UpdateMarketplaceConfig",
		prefix + "DeleteMarketplaceConfig",
		prefix + "ListMarketplaceHostnames",
		prefix + "AddMarketplaceHostname",
		prefix + "DeleteMarkplaceHostname",
		prefix + "ChangeDefaultMarkplaceHostname",
		prefix + "ResetMarkplaceHostname",
		prefix + "SyncMarketplaceCollection",
		prefix + "AddOffchainInventory",
		prefix + "GetOffchainInventory",
		prefix + "ListOffchainInventories",
		prefix + "UpdateOffchainInventory",
		prefix + "DeleteOffchainInventory",
		prefix + "ListOffchainPayments",
		prefix + "GetWalletConfig",
		prefix + "UpdateWalletConfig",
		prefix + "ListProjectFiles",
		prefix + "DeleteProjectFile",
		prefix + "OnboardingMark",
		prefix + "OnboardingStatus",
		prefix + "GetWaasSettings",
		prefix + "CreateWaasSettings",
		prefix + "UpdateWaasSettings",
		prefix + "WaasWalletStatus",
		prefix + "DeployWaasWallet",
		prefix + "CloudCommerceConnect",
		prefix + "ListAudiences",
		prefix + "GetAudience",
		prefix + "CreateAudience",
		prefix + "UpdateAudience",
		prefix + "DeleteAudience",
		prefix + "GetAudienceContacts",
		prefix + "AddAudienceContacts",
		prefix + "RemoveAudienceContacts",
		prefix + "FindAudienceContacts",
		prefix + "RegisterAudienceContact",
		prefix + "GetRegisteredAudienceContact",
		prefix + "GetAudienceRegistrationPublicStatus",
		prefix + "IsAudienceContactRegistered",
		prefix + "GetTrial",
		prefix + "StartTrial",
		prefix + "AdminListUsers",
		prefix + "AdminGetUser",
		prefix + "AdminFindUsers",
		prefix + "AdminUpdateUser",
		prefix + "AdminGetProject",
		prefix + "AdminSetProjectOwner",
		prefix + "AdminListProjects",
		prefix + "AdminRestoreProject",
		prefix + "AdminGetEmailTemplate",
		prefix + "AdminUpdateEmailTemplate",
		prefix + "AdminCreateEmailTemplate",
		prefix + "AdminContractProjectLookup",
		prefix + "AdminCreateContractSource",
		prefix + "AdminUpdateContractSource",
		prefix + "AdminGetUserOverride",
		prefix + "AdminSetUserOverride",
		prefix + "AdminGetBillingSettings",
		prefix + "AdminSetBillingSettings",
		prefix + "AdminSetProjectSubscriptionTier",
		prefix + "AdminGetCreditBonus",
		prefix + "AdminSetCreditBonus",
		prefix + "AdminAddQuotaUsage",
		prefix + "AdminListPayments",
		prefix + "AdminListPaymentLogs",
		prefix + "AdminRelayerAddressGasSponsors",
		prefix + "AdminCloudCommerceEvent",
		prefix + "AdminListAuditLogs",
		prefix + "JobqueueListRunners",
		prefix + "JobqueueListTasks",
		prefix + "JobqueueGetTask",
		prefix + "JobqueueFindTask",
		prefix + "IsInTokenDirectory",
		prefix + "SetTokenDirectoryFeatureIndex",
		prefix + "AddContractToTokenDirectory",
		prefix + "RemoveContractFromTokenDirectory",
		prefix + "GetContractInfoOverride",
		prefix + "AddContractInfoOverride",
		prefix + "UpdateContractInfoOverride",
		prefix + "RemoveContractInfoOverride",
		prefix + "GetExtendedMarketplaceConfig",
		prefix + "AdminGetMarketplaceCollection",
		prefix + "AdminListMarketplaceCollections",
		prefix + "AdminUpdateMarketplaceCollection",
	}
	return &builderClient{
		client: client,
		urls:   urls,
	}
}

func (c *builderClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetConfiguration(ctx context.Context, name *string, domain *string) (*Configuration, error) {
	in := struct {
		Arg0 *string `json:"name"`
		Arg1 *string `json:"domain"`
	}{name, domain}
	out := struct {
		Ret0 *Configuration `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetCurrentUser(ctx context.Context) (*User, error) {
	out := struct {
		Ret0 *User `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetCurrentUserSettings(ctx context.Context) (*UserSettings, error) {
	out := struct {
		Ret0 *UserSettings `json:"settings"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetEmailPreferences(ctx context.Context) (map[string]bool, map[string]string, error) {
	out := struct {
		Ret0 map[string]bool   `json:"preferences"`
		Ret1 map[string]string `json:"labels"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) UpdateEmailPreferences(ctx context.Context, preferences map[string]bool) (bool, error) {
	in := struct {
		Arg0 map[string]bool `json:"preferences"`
	}{preferences}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetAuthToken(ctx context.Context, ethauthProof string, email *string) (bool, *AuthState, error) {
	in := struct {
		Arg0 string  `json:"ethauthProof"`
		Arg1 *string `json:"email"`
	}{ethauthProof, email}
	out := struct {
		Ret0 bool       `json:"ok"`
		Ret1 *AuthState `json:"auth"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) CreateProject(ctx context.Context, name string, options *CreateProjectOptions) (*Project, error) {
	in := struct {
		Arg0 string                `json:"name"`
		Arg1 *CreateProjectOptions `json:"options"`
	}{name, options}
	out := struct {
		Ret0 *Project `json:"project"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetProject(ctx context.Context, id uint64) (*Project, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 *Project `json:"project"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateProject(ctx context.Context, projectId uint64, project *Project) (bool, error) {
	in := struct {
		Arg0 uint64   `json:"projectId"`
		Arg1 *Project `json:"project"`
	}{projectId, project}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AddProjectChain(ctx context.Context, projectId uint64, chainId uint64) (bool, []uint64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"chainId"`
	}{projectId, chainId}
	out := struct {
		Ret0 bool     `json:"ok"`
		Ret1 []uint64 `json:"chainIds"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) RemoveProjectChain(ctx context.Context, projectId uint64, chainId uint64) (bool, []uint64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"chainId"`
	}{projectId, chainId}
	out := struct {
		Ret0 bool     `json:"ok"`
		Ret1 []uint64 `json:"chainIds"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) SetProjectChains(ctx context.Context, projectId uint64, chainIds []uint64) (bool, error) {
	in := struct {
		Arg0 uint64   `json:"projectId"`
		Arg1 []uint64 `json:"chainIds"`
	}{projectId, chainIds}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteProject(ctx context.Context, projectId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListProjects(ctx context.Context, chainId *uint64, page *Page) (*Page, []*Project, error) {
	in := struct {
		Arg0 *uint64 `json:"chainId"`
		Arg1 *Page   `json:"page"`
	}{chainId, page}
	out := struct {
		Ret0 *Page      `json:"page"`
		Ret1 []*Project `json:"projects"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) CountProjects(ctx context.Context, chainId *uint64) (int64, error) {
	in := struct {
		Arg0 *uint64 `json:"chainId"`
	}{chainId}
	out := struct {
		Ret0 int64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetResource(ctx context.Context, parentId *uint64, resourceType ResourceType, filter *ResourceFilter) (*Resource, error) {
	in := struct {
		Arg0 *uint64         `json:"parentId"`
		Arg1 ResourceType    `json:"resourceType"`
		Arg2 *ResourceFilter `json:"filter"`
	}{parentId, resourceType, filter}
	out := struct {
		Ret0 *Resource `json:"resource"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) SetCollaborator(ctx context.Context, projectId uint64, userAddress string, access *CollaboratorAccess) (*Collaborator, error) {
	in := struct {
		Arg0 uint64              `json:"projectId"`
		Arg1 string              `json:"userAddress"`
		Arg2 *CollaboratorAccess `json:"access"`
	}{projectId, userAddress, access}
	out := struct {
		Ret0 *Collaborator `json:"collaborator"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetCollaborator(ctx context.Context, projectId uint64, userAddress string) (*Collaborator, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"userAddress"`
	}{projectId, userAddress}
	out := struct {
		Ret0 *Collaborator `json:"collaborator"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListCollaborators(ctx context.Context, projectId uint64, collaboratorType *CollaboratorType, page *Page) (*Page, []*Collaborator, error) {
	in := struct {
		Arg0 uint64            `json:"projectId"`
		Arg1 *CollaboratorType `json:"collaboratorType"`
		Arg2 *Page             `json:"page"`
	}{projectId, collaboratorType, page}
	out := struct {
		Ret0 *Page           `json:"page"`
		Ret1 []*Collaborator `json:"collaborators"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) DeleteCollaborator(ctx context.Context, projectId uint64, userAddress string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"userAddress"`
	}{projectId, userAddress}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AddServiceAccount(ctx context.Context, projectId uint64, access *CollaboratorAccess) (*Collaborator, string, error) {
	in := struct {
		Arg0 uint64              `json:"projectId"`
		Arg1 *CollaboratorAccess `json:"access"`
	}{projectId, access}
	out := struct {
		Ret0 *Collaborator `json:"collaborator"`
		Ret1 string        `json:"jwtToken"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) GetServiceAccount(ctx context.Context, projectId uint64, address string) (*Collaborator, string, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"address"`
	}{projectId, address}
	out := struct {
		Ret0 *Collaborator `json:"collaborator"`
		Ret1 string        `json:"jwtToken"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) CreateContract(ctx context.Context, projectId uint64, contract *Contract) (*Contract, error) {
	in := struct {
		Arg0 uint64    `json:"projectId"`
		Arg1 *Contract `json:"contract"`
	}{projectId, contract}
	out := struct {
		Ret0 *Contract `json:"contract"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetContract(ctx context.Context, id uint64) (*Contract, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 *Contract `json:"contract"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateContract(ctx context.Context, id uint64, contract *Contract) (bool, error) {
	in := struct {
		Arg0 uint64    `json:"id"`
		Arg1 *Contract `json:"contract"`
	}{id, contract}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) SetContractItemsAddress(ctx context.Context, id uint64, address string) (*Contract, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
		Arg1 string `json:"address"`
	}{id, address}
	out := struct {
		Ret0 *Contract `json:"contract"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteContract(ctx context.Context, id uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListContracts(ctx context.Context, projectId uint64, filter *ContractFilter, page *Page) (*Page, []*Contract, error) {
	in := struct {
		Arg0 uint64          `json:"projectId"`
		Arg1 *ContractFilter `json:"filter"`
		Arg2 *Page           `json:"page"`
	}{projectId, filter, page}
	out := struct {
		Ret0 *Page       `json:"page"`
		Ret1 []*Contract `json:"contracts"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) ExploreContractLinks(ctx context.Context, contractAddress string, chainId *uint64, onlyLinked *bool, page *Page) (*Page, []*ContractLink, error) {
	in := struct {
		Arg0 string  `json:"contractAddress"`
		Arg1 *uint64 `json:"chainId"`
		Arg2 *bool   `json:"onlyLinked"`
		Arg3 *Page   `json:"page"`
	}{contractAddress, chainId, onlyLinked, page}
	out := struct {
		Ret0 *Page           `json:"page"`
		Ret1 []*ContractLink `json:"links"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) GetContractLinks(ctx context.Context, projectId uint64, id uint64) ([]*Contract, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"id"`
	}{projectId, id}
	out := struct {
		Ret0 []*Contract `json:"contracts"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) CreateContractSource(ctx context.Context, projectId uint64, contractSource *NewContractSource) (*ContractSource, error) {
	in := struct {
		Arg0 uint64             `json:"projectId"`
		Arg1 *NewContractSource `json:"contractSource"`
	}{projectId, contractSource}
	out := struct {
		Ret0 *ContractSource `json:"contractSource"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[33], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteContractSource(ctx context.Context, projectId uint64, uid string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"uid"`
	}{projectId, uid}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[34], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListContractSources(ctx context.Context, projectId *uint64, page *Page) (*Page, []*ContractSource, error) {
	in := struct {
		Arg0 *uint64 `json:"projectId"`
		Arg1 *Page   `json:"page"`
	}{projectId, page}
	out := struct {
		Ret0 *Page             `json:"page"`
		Ret1 []*ContractSource `json:"contractSources"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[35], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) GetContractFactory(ctx context.Context, chainId uint64, uid string) (*ContractFactory, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"uid"`
	}{chainId, uid}
	out := struct {
		Ret0 *ContractFactory `json:"contractFactory"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[36], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetContractSource(ctx context.Context, uid string) (*ContractSource, error) {
	in := struct {
		Arg0 string `json:"uid"`
	}{uid}
	out := struct {
		Ret0 *ContractSource `json:"contractSource"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[37], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) SyncContracts(ctx context.Context, projectId uint64, chainId uint64, contractAddress string, sync *ContractSync) (bool, error) {
	in := struct {
		Arg0 uint64        `json:"projectId"`
		Arg1 uint64        `json:"chainId"`
		Arg2 string        `json:"contractAddress"`
		Arg3 *ContractSync `json:"sync"`
	}{projectId, chainId, contractAddress, sync}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[38], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetContractTags(ctx context.Context, projectId uint64) ([]*ContractTag, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*ContractTag `json:"tags"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[39], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) CreateEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType, subject string, introText string, logoUrl string) (*EmailTemplate, error) {
	in := struct {
		Arg0 uint64             `json:"projectId"`
		Arg1 *EmailTemplateType `json:"templateType"`
		Arg2 string             `json:"subject"`
		Arg3 string             `json:"introText"`
		Arg4 string             `json:"logoUrl"`
	}{projectId, templateType, subject, introText, logoUrl}
	out := struct {
		Ret0 *EmailTemplate `json:"emailTemplate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[40], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType) (*EmailTemplate, error) {
	in := struct {
		Arg0 uint64             `json:"projectId"`
		Arg1 *EmailTemplateType `json:"templateType"`
	}{projectId, templateType}
	out := struct {
		Ret0 *EmailTemplate `json:"emailTemplate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[41], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateEmailTemplate(ctx context.Context, update *EmailTemplate) (*EmailTemplate, error) {
	in := struct {
		Arg0 *EmailTemplate `json:"update"`
	}{update}
	out := struct {
		Ret0 *EmailTemplate `json:"emailTemplate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[42], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GasTankStatus(ctx context.Context, projectId uint64) (*GasTankStatus, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 *GasTankStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[43], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) CreateBillingSession(ctx context.Context, projectId uint64, path string) (*Redirect, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"path"`
	}{projectId, path}
	out := struct {
		Ret0 *Redirect `json:"session"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[44], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateTopupSettings(ctx context.Context, projectId uint64, settings *TopUpSettings) (bool, error) {
	in := struct {
		Arg0 uint64         `json:"projectId"`
		Arg1 *TopUpSettings `json:"settings"`
	}{projectId, settings}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[45], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) TopUpGasTank(ctx context.Context, projectId uint64, amount float64) (bool, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 float64 `json:"amount"`
	}{projectId, amount}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[46], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetInvoices(ctx context.Context, projectId uint64, before *time.Time) (*InvoicesReturn, error) {
	in := struct {
		Arg0 uint64     `json:"projectId"`
		Arg1 *time.Time `json:"before"`
	}{projectId, before}
	out := struct {
		Ret0 *InvoicesReturn `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[47], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) BuySubscriptionTier(ctx context.Context, projectId uint64, tier SubscriptionTier) (*Redirect, error) {
	in := struct {
		Arg0 uint64           `json:"projectId"`
		Arg1 SubscriptionTier `json:"tier"`
	}{projectId, tier}
	out := struct {
		Ret0 *Redirect `json:"checkout"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[48], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) CancelSubscriptionDowngrade(ctx context.Context, projectId uint64, tier SubscriptionTier) (bool, error) {
	in := struct {
		Arg0 uint64           `json:"projectId"`
		Arg1 SubscriptionTier `json:"tier"`
	}{projectId, tier}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[49], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ChangeAccessQuotaLimit(ctx context.Context, projectId uint64, creditsOverageWarn *uint64, creditsOverageMax *uint64) (bool, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 *uint64 `json:"creditsOverageWarn"`
		Arg2 *uint64 `json:"creditsOverageMax"`
	}{projectId, creditsOverageWarn, creditsOverageMax}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[50], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetSubscriptionInfo(ctx context.Context, projectId uint64) (*SubscriptionInfo, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 *SubscriptionInfo `json:"subscription"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[51], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetSubscriptionPlans(ctx context.Context) (*SubscriptionPlans, error) {
	out := struct {
		Ret0 *SubscriptionPlans `json:"configs"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[52], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) CreateProjectInvitation(ctx context.Context, projectId uint64, access *CollaboratorAccess, expiresAt *time.Time, signupLimit *uint64) (*ProjectInvitation, error) {
	in := struct {
		Arg0 uint64              `json:"projectId"`
		Arg1 *CollaboratorAccess `json:"access"`
		Arg2 *time.Time          `json:"expiresAt"`
		Arg3 *uint64             `json:"signupLimit"`
	}{projectId, access, expiresAt, signupLimit}
	out := struct {
		Ret0 *ProjectInvitation `json:"invitation"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[53], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListProjectInvitations(ctx context.Context, projectId uint64) ([]*ProjectInvitation, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*ProjectInvitation `json:"invitations"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[54], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteProjectInvitation(ctx context.Context, invitationId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"invitationId"`
	}{invitationId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[55], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UseProjectInvitation(ctx context.Context, invitationCode string) (bool, uint64, error) {
	in := struct {
		Arg0 string `json:"invitationCode"`
	}{invitationCode}
	out := struct {
		Ret0 bool   `json:"ok"`
		Ret1 uint64 `json:"projectId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[56], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) GetMarketplaceConfig(ctx context.Context, projectId uint64) (*MarketplaceConfig, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 *MarketplaceConfig `json:"settings"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[57], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateMarketplaceConfig(ctx context.Context, projectId uint64, settings *MarketplaceConfig) (bool, error) {
	in := struct {
		Arg0 uint64             `json:"projectId"`
		Arg1 *MarketplaceConfig `json:"settings"`
	}{projectId, settings}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[58], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteMarketplaceConfig(ctx context.Context, projectId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[59], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListMarketplaceHostnames(ctx context.Context, projectId uint64) ([]*MarketplaceHostname, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*MarketplaceHostname `json:"domains"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[60], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AddMarketplaceHostname(ctx context.Context, projectId uint64, domain string, custom bool) (uint64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"domain"`
		Arg2 bool   `json:"custom"`
	}{projectId, domain, custom}
	out := struct {
		Ret0 uint64 `json:"id"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[61], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteMarkplaceHostname(ctx context.Context, projectId uint64, hostnameID uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"hostnameID"`
	}{projectId, hostnameID}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[62], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ChangeDefaultMarkplaceHostname(ctx context.Context, projectId uint64) (uint64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 uint64 `json:"id"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[63], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ResetMarkplaceHostname(ctx context.Context, projectId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[64], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) SyncMarketplaceCollection(ctx context.Context, projectId uint64, contractAddress string, chainId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"contractAddress"`
		Arg2 uint64 `json:"chainId"`
	}{projectId, contractAddress, chainId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[65], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error) {
	in := struct {
		Arg0 *OffchainInventory `json:"inventory"`
	}{inventory}
	out := struct {
		Ret0 uint64 `json:"inventoryId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[66], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
	}{inventoryId}
	out := struct {
		Ret0 *OffchainInventory `json:"inventory"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[67], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*OffchainInventory `json:"inventories"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[68], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error {
	in := struct {
		Arg0 *OffchainInventory `json:"inventory"`
	}{inventory}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[69], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *builderClient) DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
	}{inventoryId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[70], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
		Arg1 *Page  `json:"page"`
	}{inventoryId, page}
	out := struct {
		Ret0 *Page              `json:"page"`
		Ret1 []*OffchainPayment `json:"payments"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[71], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) GetWalletConfig(ctx context.Context, projectId uint64, platform string) (*WalletConfig, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"platform"`
	}{projectId, platform}
	out := struct {
		Ret0 *WalletConfig `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[72], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateWalletConfig(ctx context.Context, projectId uint64, platform string, config *WalletConfig) (bool, error) {
	in := struct {
		Arg0 uint64        `json:"projectId"`
		Arg1 string        `json:"platform"`
		Arg2 *WalletConfig `json:"config"`
	}{projectId, platform, config}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[73], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListProjectFiles(ctx context.Context, projectId uint64, scope *FileScope) ([]*ProjectFile, error) {
	in := struct {
		Arg0 uint64     `json:"projectId"`
		Arg1 *FileScope `json:"scope"`
	}{projectId, scope}
	out := struct {
		Ret0 []*ProjectFile `json:"files"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[74], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteProjectFile(ctx context.Context, id uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[75], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) OnboardingMark(ctx context.Context, projectId uint64, step OnboardingStep) (bool, error) {
	in := struct {
		Arg0 uint64         `json:"projectId"`
		Arg1 OnboardingStep `json:"step"`
	}{projectId, step}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[76], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) OnboardingStatus(ctx context.Context, projectId uint64) ([]OnboardingStep, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []OnboardingStep `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[77], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetWaasSettings(ctx context.Context, projectId uint64) (*WaasSettings, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 *WaasSettings `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[78], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) CreateWaasSettings(ctx context.Context, projectId uint64, recoveryAddress string, auth *WaasAuthConfig, oidcProviders []*OpenIdProvider, allowedOrigins []string, password *string) (*WaasSettings, error) {
	in := struct {
		Arg0 uint64            `json:"projectId"`
		Arg1 string            `json:"recoveryAddress"`
		Arg2 *WaasAuthConfig   `json:"auth"`
		Arg3 []*OpenIdProvider `json:"oidcProviders"`
		Arg4 []string          `json:"allowedOrigins"`
		Arg5 *string           `json:"password"`
	}{projectId, recoveryAddress, auth, oidcProviders, allowedOrigins, password}
	out := struct {
		Ret0 *WaasSettings `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[79], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateWaasSettings(ctx context.Context, projectId uint64, updateCode string, auth *WaasAuthConfig, oidcProviders []*OpenIdProvider, allowedOrigins []string) (*WaasSettings, error) {
	in := struct {
		Arg0 uint64            `json:"projectId"`
		Arg1 string            `json:"updateCode"`
		Arg2 *WaasAuthConfig   `json:"auth"`
		Arg3 []*OpenIdProvider `json:"oidcProviders"`
		Arg4 []string          `json:"allowedOrigins"`
	}{projectId, updateCode, auth, oidcProviders, allowedOrigins}
	out := struct {
		Ret0 *WaasSettings `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[80], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) WaasWalletStatus(ctx context.Context, projectId uint64) ([]*WaasWalletStatus, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*WaasWalletStatus `json:"walletStatus"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[81], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeployWaasWallet(ctx context.Context, projectId uint64, chainId uint64) (string, string, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"chainId"`
	}{projectId, chainId}
	out := struct {
		Ret0 string `json:"address"`
		Ret1 string `json:"txnHash"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[82], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) CloudCommerceConnect(ctx context.Context, projectId uint64, accountId string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"accountId"`
	}{projectId, accountId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[83], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) ListAudiences(ctx context.Context, projectId uint64) ([]*Audience, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*Audience `json:"audiences"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[84], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetAudience(ctx context.Context, projectId uint64, audienceId uint64) (*Audience, []*Contract, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"audienceId"`
	}{projectId, audienceId}
	out := struct {
		Ret0 *Audience   `json:"audience"`
		Ret1 []*Contract `json:"contracts"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[85], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) CreateAudience(ctx context.Context, projectId uint64, name string) (*Audience, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"name"`
	}{projectId, name}
	out := struct {
		Ret0 *Audience `json:"audience"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[86], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateAudience(ctx context.Context, projectId uint64, audienceId uint64, name string) (*Audience, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"audienceId"`
		Arg2 string `json:"name"`
	}{projectId, audienceId, name}
	out := struct {
		Ret0 *Audience `json:"audience"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[87], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) DeleteAudience(ctx context.Context, projectId uint64, audienceId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"audienceId"`
	}{projectId, audienceId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[88], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, page *Page) (*Audience, []*AudienceContact, *Page, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"audienceId"`
		Arg2 *Page  `json:"page"`
	}{projectId, audienceId, page}
	out := struct {
		Ret0 *Audience          `json:"audience"`
		Ret1 []*AudienceContact `json:"contacts"`
		Ret2 *Page              `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[89], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, err
}

func (c *builderClient) AddAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, contacts []*AudienceContact) (bool, error) {
	in := struct {
		Arg0 uint64             `json:"projectId"`
		Arg1 uint64             `json:"audienceId"`
		Arg2 []*AudienceContact `json:"contacts"`
	}{projectId, audienceId, contacts}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[90], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) RemoveAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, contactIds []uint64) (bool, error) {
	in := struct {
		Arg0 uint64   `json:"projectId"`
		Arg1 uint64   `json:"audienceId"`
		Arg2 []uint64 `json:"contactIds"`
	}{projectId, audienceId, contactIds}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[91], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) FindAudienceContacts(ctx context.Context, projectId uint64, audienceId uint64, address *string, email *string) ([]*AudienceContact, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 uint64  `json:"audienceId"`
		Arg2 *string `json:"address"`
		Arg3 *string `json:"email"`
	}{projectId, audienceId, address, email}
	out := struct {
		Ret0 []*AudienceContact `json:"contact"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[92], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) RegisterAudienceContact(ctx context.Context, projectId uint64, audienceId uint64, contact *AudienceContact, walletProof *WalletProof) (bool, error) {
	in := struct {
		Arg0 uint64           `json:"projectId"`
		Arg1 uint64           `json:"audienceId"`
		Arg2 *AudienceContact `json:"contact"`
		Arg3 *WalletProof     `json:"walletProof"`
	}{projectId, audienceId, contact, walletProof}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[93], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetRegisteredAudienceContact(ctx context.Context, projectId uint64, audienceId uint64, walletProof *WalletProof) (*AudienceContact, error) {
	in := struct {
		Arg0 uint64       `json:"projectId"`
		Arg1 uint64       `json:"audienceId"`
		Arg2 *WalletProof `json:"walletProof"`
	}{projectId, audienceId, walletProof}
	out := struct {
		Ret0 *AudienceContact `json:"contact"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[94], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetAudienceRegistrationPublicStatus(ctx context.Context, projectId uint64, audienceId uint64) (*AudienceRegistrationStatus, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"audienceId"`
	}{projectId, audienceId}
	out := struct {
		Ret0 *AudienceRegistrationStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[95], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) IsAudienceContactRegistered(ctx context.Context, projectId uint64, audienceId uint64, walletAddress string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"audienceId"`
		Arg2 string `json:"walletAddress"`
	}{projectId, audienceId, walletAddress}
	out := struct {
		Ret0 bool `json:"registered"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[96], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetTrial(ctx context.Context, projectId uint64, trialType TrialType) (*Trial, error) {
	in := struct {
		Arg0 uint64    `json:"projectId"`
		Arg1 TrialType `json:"trialType"`
	}{projectId, trialType}
	out := struct {
		Ret0 *Trial `json:"trial"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[97], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) StartTrial(ctx context.Context, projectId uint64, trialType TrialType) (*Trial, error) {
	in := struct {
		Arg0 uint64    `json:"projectId"`
		Arg1 TrialType `json:"trialType"`
	}{projectId, trialType}
	out := struct {
		Ret0 *Trial `json:"trial"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[98], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminListUsers(ctx context.Context, email *string, address *string, sysAdmin *bool, page *Page) (*Page, []*User, error) {
	in := struct {
		Arg0 *string `json:"email"`
		Arg1 *string `json:"address"`
		Arg2 *bool   `json:"sysAdmin"`
		Arg3 *Page   `json:"page"`
	}{email, address, sysAdmin, page}
	out := struct {
		Ret0 *Page   `json:"page"`
		Ret1 []*User `json:"users"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[99], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminGetUser(ctx context.Context, address string) (*User, error) {
	in := struct {
		Arg0 string `json:"address"`
	}{address}
	out := struct {
		Ret0 *User `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[100], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminFindUsers(ctx context.Context, email string) ([]*User, error) {
	in := struct {
		Arg0 string `json:"email"`
	}{email}
	out := struct {
		Ret0 []*User `json:"users"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[101], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminUpdateUser(ctx context.Context, address string, email *string, sysAdmin *bool) (*User, error) {
	in := struct {
		Arg0 string  `json:"address"`
		Arg1 *string `json:"email"`
		Arg2 *bool   `json:"sysAdmin"`
	}{address, email, sysAdmin}
	out := struct {
		Ret0 *User `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[102], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminGetProject(ctx context.Context, projectId uint64) (*Project, []*ProjectSubscription, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 *Project               `json:"project"`
		Ret1 []*ProjectSubscription `json:"history"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[103], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminSetProjectOwner(ctx context.Context, projectId uint64, address string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"address"`
	}{projectId, address}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[104], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminListProjects(ctx context.Context, ecosystemId *uint64, filter *ProjectListFilter, page *Page) (*Page, []*Project, error) {
	in := struct {
		Arg0 *uint64            `json:"ecosystemId"`
		Arg1 *ProjectListFilter `json:"filter"`
		Arg2 *Page              `json:"page"`
	}{ecosystemId, filter, page}
	out := struct {
		Ret0 *Page      `json:"page"`
		Ret1 []*Project `json:"projects"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[105], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminRestoreProject(ctx context.Context, projectId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[106], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminGetEmailTemplate(ctx context.Context, projectId uint64, templateType *EmailTemplateType) (*EmailTemplate, error) {
	in := struct {
		Arg0 uint64             `json:"projectId"`
		Arg1 *EmailTemplateType `json:"templateType"`
	}{projectId, templateType}
	out := struct {
		Ret0 *EmailTemplate `json:"emailTemplate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[107], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminUpdateEmailTemplate(ctx context.Context, projectId uint64, update *EmailTemplate) (*EmailTemplate, error) {
	in := struct {
		Arg0 uint64         `json:"projectId"`
		Arg1 *EmailTemplate `json:"update"`
	}{projectId, update}
	out := struct {
		Ret0 *EmailTemplate `json:"emailTemplate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[108], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminCreateEmailTemplate(ctx context.Context, projectId uint64, template *EmailTemplate) (*EmailTemplate, error) {
	in := struct {
		Arg0 uint64         `json:"projectId"`
		Arg1 *EmailTemplate `json:"template"`
	}{projectId, template}
	out := struct {
		Ret0 *EmailTemplate `json:"emailTemplate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[109], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminContractProjectLookup(ctx context.Context, chainId uint64, address string) ([]*Contract, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
	}{chainId, address}
	out := struct {
		Ret0 []*Contract `json:"contracts"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[110], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminCreateContractSource(ctx context.Context, contractFactory *NewContractSource) (*ContractSource, error) {
	in := struct {
		Arg0 *NewContractSource `json:"contractFactory"`
	}{contractFactory}
	out := struct {
		Ret0 *ContractSource `json:"contractSource"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[111], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminUpdateContractSource(ctx context.Context, uid string, contractSource *ContractSource) (bool, error) {
	in := struct {
		Arg0 string          `json:"uid"`
		Arg1 *ContractSource `json:"contractSource"`
	}{uid, contractSource}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[112], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminGetUserOverride(ctx context.Context, userAddress string) (*UserSettings, *UserOverride, error) {
	in := struct {
		Arg0 string `json:"userAddress"`
	}{userAddress}
	out := struct {
		Ret0 *UserSettings `json:"settings"`
		Ret1 *UserOverride `json:"override"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[113], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminSetUserOverride(ctx context.Context, override *UserOverride) (*UserSettings, error) {
	in := struct {
		Arg0 *UserOverride `json:"override"`
	}{override}
	out := struct {
		Ret0 *UserSettings `json:"settings"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[114], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminGetBillingSettings(ctx context.Context, projectId uint64) (*BillingOverride, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 *BillingOverride `json:"settings"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[115], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminSetBillingSettings(ctx context.Context, projectId uint64, settings *BillingOverride) (bool, error) {
	in := struct {
		Arg0 uint64           `json:"projectId"`
		Arg1 *BillingOverride `json:"settings"`
	}{projectId, settings}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[116], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminSetProjectSubscriptionTier(ctx context.Context, projectId uint64, tier SubscriptionTier) (*Project, error) {
	in := struct {
		Arg0 uint64           `json:"projectId"`
		Arg1 SubscriptionTier `json:"tier"`
	}{projectId, tier}
	out := struct {
		Ret0 *Project `json:"project"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[117], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminGetCreditBonus(ctx context.Context, projectId uint64) (uint64, uint64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 uint64 `json:"amount"`
		Ret1 uint64 `json:"balance"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[118], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminSetCreditBonus(ctx context.Context, projectId uint64, amount uint64) (uint64, uint64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"amount"`
	}{projectId, amount}
	out := struct {
		Ret0 uint64 `json:"amount"`
		Ret1 uint64 `json:"balance"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[119], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminAddQuotaUsage(ctx context.Context, projectId uint64, now *time.Time, service string, amount int64) (bool, error) {
	in := struct {
		Arg0 uint64     `json:"projectId"`
		Arg1 *time.Time `json:"now"`
		Arg2 string     `json:"service"`
		Arg3 int64      `json:"amount"`
	}{projectId, now, service, amount}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[120], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminListPayments(ctx context.Context, page *Page, status *PaymentStatus, provider *PaymentProvider, projectID *uint64) ([]*Payment, error) {
	in := struct {
		Arg0 *Page            `json:"page"`
		Arg1 *PaymentStatus   `json:"status"`
		Arg2 *PaymentProvider `json:"provider"`
		Arg3 *uint64          `json:"projectID"`
	}{page, status, provider, projectID}
	out := struct {
		Ret0 []*Payment `json:"payments"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[121], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminListPaymentLogs(ctx context.Context, paymentID uint64) ([]*PaymentLog, error) {
	in := struct {
		Arg0 uint64 `json:"paymentID"`
	}{paymentID}
	out := struct {
		Ret0 []*PaymentLog `json:"logs"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[122], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminRelayerAddressGasSponsors(ctx context.Context, chainId uint64, address string, page *Page) (*Page, []*RelayerGasSponsor, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
		Arg2 *Page  `json:"page"`
	}{chainId, address, page}
	out := struct {
		Ret0 *Page                `json:"page"`
		Ret1 []*RelayerGasSponsor `json:"gasSponsors"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[123], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminCloudCommerceEvent(ctx context.Context, eventId string, payload map[string]interface{}) (bool, error) {
	in := struct {
		Arg0 string                 `json:"eventId"`
		Arg1 map[string]interface{} `json:"payload"`
	}{eventId, payload}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[124], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminListAuditLogs(ctx context.Context, projectId *uint64, walletAddress *string, auditType *AuditType, email *string, page *Page) ([]*AuditLog, *Page, error) {
	in := struct {
		Arg0 *uint64    `json:"projectId"`
		Arg1 *string    `json:"walletAddress"`
		Arg2 *AuditType `json:"auditType"`
		Arg3 *string    `json:"email"`
		Arg4 *Page      `json:"page"`
	}{projectId, walletAddress, auditType, email, page}
	out := struct {
		Ret0 []*AuditLog `json:"logs"`
		Ret1 *Page       `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[125], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) JobqueueListRunners(ctx context.Context, workGroup *string) ([]*TaskRunner, error) {
	in := struct {
		Arg0 *string `json:"workGroup"`
	}{workGroup}
	out := struct {
		Ret0 []*TaskRunner `json:"runners"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[126], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) JobqueueListTasks(ctx context.Context, queue *string, status *TaskStatus, page *Page) (*Page, []*Task, error) {
	in := struct {
		Arg0 *string     `json:"queue"`
		Arg1 *TaskStatus `json:"status"`
		Arg2 *Page       `json:"page"`
	}{queue, status, page}
	out := struct {
		Ret0 *Page   `json:"page"`
		Ret1 []*Task `json:"tasks"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[127], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) JobqueueGetTask(ctx context.Context, id uint64) (*Task, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 *Task `json:"task"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[128], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) JobqueueFindTask(ctx context.Context, queue string, hash string) (*Task, error) {
	in := struct {
		Arg0 string `json:"queue"`
		Arg1 string `json:"hash"`
	}{queue, hash}
	out := struct {
		Ret0 *Task `json:"task"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[129], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) IsInTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, uint8, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
	}{chainId, address}
	out := struct {
		Ret0 bool  `json:"ok"`
		Ret1 uint8 `json:"featureIndex"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[130], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) SetTokenDirectoryFeatureIndex(ctx context.Context, chainId uint64, address string, featureIndex uint8) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
		Arg2 uint8  `json:"featureIndex"`
	}{chainId, address, featureIndex}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[131], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AddContractToTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
	}{chainId, address}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[132], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) RemoveContractFromTokenDirectory(ctx context.Context, chainId uint64, address string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
	}{chainId, address}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[133], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetContractInfoOverride(ctx context.Context, chainId uint64, address string) (*ContractInfoOverride, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
	}{chainId, address}
	out := struct {
		Ret0 *ContractInfoOverride `json:"contractInfoOverride"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[134], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AddContractInfoOverride(ctx context.Context, chainId uint64, address string, contractInfoOverride *ContractInfoOverride) (bool, error) {
	in := struct {
		Arg0 uint64                `json:"chainId"`
		Arg1 string                `json:"address"`
		Arg2 *ContractInfoOverride `json:"contractInfoOverride"`
	}{chainId, address, contractInfoOverride}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[135], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) UpdateContractInfoOverride(ctx context.Context, chainId uint64, address string, contractInfoOverride *ContractInfoOverride) (bool, error) {
	in := struct {
		Arg0 uint64                `json:"chainId"`
		Arg1 string                `json:"address"`
		Arg2 *ContractInfoOverride `json:"contractInfoOverride"`
	}{chainId, address, contractInfoOverride}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[136], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) RemoveContractInfoOverride(ctx context.Context, chainId uint64, address string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"address"`
	}{chainId, address}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[137], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) GetExtendedMarketplaceConfig(ctx context.Context, hostname string) (*ExtendedMarketplaceConfig, error) {
	in := struct {
		Arg0 string `json:"hostname"`
	}{hostname}
	out := struct {
		Ret0 *ExtendedMarketplaceConfig `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[138], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminGetMarketplaceCollection(ctx context.Context, projectId uint64, chainId uint64, contractAddress string) (*AdminMarketplaceCollection, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"chainId"`
		Arg2 string `json:"contractAddress"`
	}{projectId, chainId, contractAddress}
	out := struct {
		Ret0 *AdminMarketplaceCollection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[139], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *builderClient) AdminListMarketplaceCollections(ctx context.Context, projectId uint64, chainId uint64, page *Page) ([]*AdminMarketplaceCollection, *Page, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"chainId"`
		Arg2 *Page  `json:"page"`
	}{projectId, chainId, page}
	out := struct {
		Ret0 []*AdminMarketplaceCollection `json:"collections"`
		Ret1 *Page                         `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[140], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *builderClient) AdminUpdateMarketplaceCollection(ctx context.Context, projectId uint64, collection *AdminMarketplaceCollection) (*AdminMarketplaceCollection, error) {
	in := struct {
		Arg0 uint64                      `json:"projectId"`
		Arg1 *AdminMarketplaceCollection `json:"collection"`
	}{projectId, collection}
	out := struct {
		Ret0 *AdminMarketplaceCollection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[141], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

type gasTankClient struct {
	client HTTPClient
	urls   [3]string
}

func NewGasTankClient(addr string, client HTTPClient) GasTankClient {
	prefix := urlBase(addr) + GasTankPathPrefix
	urls := [3]string{
		prefix + "GetBalance",
		prefix + "AdjustProjectBalance",
		prefix + "SpendBalance",
	}
	return &gasTankClient{
		client: client,
		urls:   urls,
	}
}

func (c *gasTankClient) GetBalance(ctx context.Context, projectId uint64) (bool, float64, float64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 bool    `json:"ok"`
		Ret1 float64 `json:"balance"`
		Ret2 float64 `json:"markupFactor"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, err
}

func (c *gasTankClient) AdjustProjectBalance(ctx context.Context, projectId uint64, amount float64, identifier string) (float64, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 float64 `json:"amount"`
		Arg2 string  `json:"identifier"`
	}{projectId, amount, identifier}
	out := struct {
		Ret0 float64 `json:"balance"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *gasTankClient) SpendBalance(ctx context.Context, projectId uint64, amount float64) (float64, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 float64 `json:"amount"`
	}{projectId, amount}
	out := struct {
		Ret0 float64 `json:"balance"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

type ecosystemManagerClient struct {
	client HTTPClient
	urls   [21]string
}

func NewEcosystemManagerClient(addr string, client HTTPClient) EcosystemManagerClient {
	prefix := urlBase(addr) + EcosystemManagerPathPrefix
	urls := [21]string{
		prefix + "CreateEcosystem",
		prefix + "GetEcosystem",
		prefix + "FindEcosystem",
		prefix + "UpdateEcosystem",
		prefix + "ListEcosystems",
		prefix + "SetEcosystemCollaborator",
		prefix + "GetEcosystemCollaborator",
		prefix + "ListEcosystemCollaborators",
		prefix + "CreateEcosystemLicense",
		prefix + "GetEcosystemLicense",
		prefix + "UpdateEcosystemLicense",
		prefix + "ListEcosystemLicenses",
		prefix + "DeleteEcosystemLicense",
		prefix + "GetEcosystemDefaultLicense",
		prefix + "SetEcosystemDefaultLicense",
		prefix + "AssignLicense",
		prefix + "UpdateEcosystemSettings",
		prefix + "SetProjectEcosystem",
		prefix + "ListEcosystemProjects",
		prefix + "GetEcosystemProject",
		prefix + "RestoreEcosystemProject",
	}
	return &ecosystemManagerClient{
		client: client,
		urls:   urls,
	}
}

func (c *ecosystemManagerClient) CreateEcosystem(ctx context.Context, ecosystem *Ecosystem) (*Ecosystem, error) {
	in := struct {
		Arg0 *Ecosystem `json:"ecosystem"`
	}{ecosystem}
	out := struct {
		Ret0 *Ecosystem `json:"ecosystem"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) GetEcosystem(ctx context.Context, id uint64) (*Ecosystem, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 *Ecosystem `json:"ecosystem"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) FindEcosystem(ctx context.Context, name *string, domain *string) (*Ecosystem, error) {
	in := struct {
		Arg0 *string `json:"name"`
		Arg1 *string `json:"domain"`
	}{name, domain}
	out := struct {
		Ret0 *Ecosystem `json:"ecosystem"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) UpdateEcosystem(ctx context.Context, id uint64, ecosystem *Ecosystem) (bool, error) {
	in := struct {
		Arg0 uint64     `json:"id"`
		Arg1 *Ecosystem `json:"ecosystem"`
	}{id, ecosystem}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) ListEcosystems(ctx context.Context, query *string, ecosystemType *EcosystemType, page *Page) (*Page, []*Ecosystem, error) {
	in := struct {
		Arg0 *string        `json:"query"`
		Arg1 *EcosystemType `json:"ecosystemType"`
		Arg2 *Page          `json:"page"`
	}{query, ecosystemType, page}
	out := struct {
		Ret0 *Page        `json:"page"`
		Ret1 []*Ecosystem `json:"ecosystems"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *ecosystemManagerClient) SetEcosystemCollaborator(ctx context.Context, id uint64, userAddress string, access *EcosystemAccess) (bool, error) {
	in := struct {
		Arg0 uint64           `json:"id"`
		Arg1 string           `json:"userAddress"`
		Arg2 *EcosystemAccess `json:"access"`
	}{id, userAddress, access}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) GetEcosystemCollaborator(ctx context.Context, id uint64, userAddress string) (*EcosystemCollaborator, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
		Arg1 string `json:"userAddress"`
	}{id, userAddress}
	out := struct {
		Ret0 *EcosystemCollaborator `json:"level"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) ListEcosystemCollaborators(ctx context.Context, id uint64, page *Page) (*Page, []*EcosystemCollaborator, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
		Arg1 *Page  `json:"page"`
	}{id, page}
	out := struct {
		Ret0 *Page                    `json:"page"`
		Ret1 []*EcosystemCollaborator `json:"collaborators"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *ecosystemManagerClient) CreateEcosystemLicense(ctx context.Context, license *EcosystemLicense) (*EcosystemLicense, error) {
	in := struct {
		Arg0 *EcosystemLicense `json:"license"`
	}{license}
	out := struct {
		Ret0 *EcosystemLicense `json:"license"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) GetEcosystemLicense(ctx context.Context, id uint64) (*EcosystemLicense, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 *EcosystemLicense `json:"license"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) UpdateEcosystemLicense(ctx context.Context, id uint64, license *EcosystemLicense) (bool, error) {
	in := struct {
		Arg0 uint64            `json:"id"`
		Arg1 *EcosystemLicense `json:"license"`
	}{id, license}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) ListEcosystemLicenses(ctx context.Context, ecosystemId uint64, page *Page) (*Page, []*EcosystemLicense, error) {
	in := struct {
		Arg0 uint64 `json:"ecosystemId"`
		Arg1 *Page  `json:"page"`
	}{ecosystemId, page}
	out := struct {
		Ret0 *Page               `json:"page"`
		Ret1 []*EcosystemLicense `json:"licenses"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *ecosystemManagerClient) DeleteEcosystemLicense(ctx context.Context, id uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) GetEcosystemDefaultLicense(ctx context.Context, ecosystemId uint64) (*EcosystemLicense, error) {
	in := struct {
		Arg0 uint64 `json:"ecosystemId"`
	}{ecosystemId}
	out := struct {
		Ret0 *EcosystemLicense `json:"license"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) SetEcosystemDefaultLicense(ctx context.Context, ecosystemId uint64, licenseId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"ecosystemId"`
		Arg1 uint64 `json:"licenseId"`
	}{ecosystemId, licenseId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) AssignLicense(ctx context.Context, licenseId uint64, projectId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"licenseId"`
		Arg1 uint64 `json:"projectId"`
	}{licenseId, projectId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) UpdateEcosystemSettings(ctx context.Context, id uint64, settings *EcosystemSettings) (bool, error) {
	in := struct {
		Arg0 uint64             `json:"id"`
		Arg1 *EcosystemSettings `json:"settings"`
	}{id, settings}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) SetProjectEcosystem(ctx context.Context, projectId uint64, ecosystemId *uint64) (bool, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 *uint64 `json:"ecosystemId"`
	}{projectId, ecosystemId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) ListEcosystemProjects(ctx context.Context, ecosystemId uint64, filter *ProjectListFilter, page *Page) (*Page, []*Project, error) {
	in := struct {
		Arg0 uint64             `json:"ecosystemId"`
		Arg1 *ProjectListFilter `json:"filter"`
		Arg2 *Page              `json:"page"`
	}{ecosystemId, filter, page}
	out := struct {
		Ret0 *Page      `json:"page"`
		Ret1 []*Project `json:"projects"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *ecosystemManagerClient) GetEcosystemProject(ctx context.Context, ecosystemId uint64, projectId uint64) (*Project, error) {
	in := struct {
		Arg0 uint64 `json:"ecosystemId"`
		Arg1 uint64 `json:"projectId"`
	}{ecosystemId, projectId}
	out := struct {
		Ret0 *Project `json:"project"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *ecosystemManagerClient) RestoreEcosystemProject(ctx context.Context, ecosystemId uint64, projectId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"ecosystemId"`
		Arg1 uint64 `json:"projectId"`
	}{ecosystemId, projectId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := jsonCfg.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := jsonCfg.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = jsonCfg.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type method struct {
	Name        string
	Service     string
	Annotations map[string]string
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

func MethodCtx(ctx context.Context) (method, bool) {
	req := RequestFromContext(ctx)
	if req == nil {
		return method{}, false
	}

	m, ok := methods[req.URL.Path]
	if !ok {
		return method{}, false
	}

	return m, true
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint           = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed      = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute           = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod          = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest         = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse        = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic        = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError      = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientDisconnected = WebRPCError{Code: -8, Name: "WebrpcClientDisconnected", Message: "client disconnected", HTTPStatus: 400}
	ErrWebrpcStreamLost         = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished     = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized        = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied    = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired      = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound      = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrRequestConflict     = WebRPCError{Code: 1004, Name: "RequestConflict", Message: "Conflict with target resource", HTTPStatus: 409}
	ErrServiceDisabled     = WebRPCError{Code: 1005, Name: "ServiceDisabled", Message: "Service disabled", HTTPStatus: 404}
	ErrTimeout             = WebRPCError{Code: 2000, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrInvalidArgument     = WebRPCError{Code: 2001, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrNotFound            = WebRPCError{Code: 3000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 422}
	ErrUserNotFound        = WebRPCError{Code: 3001, Name: "UserNotFound", Message: "User not found", HTTPStatus: 422}
	ErrProjectNotFound     = WebRPCError{Code: 3002, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 422}
	ErrInvalidTier         = WebRPCError{Code: 3003, Name: "InvalidTier", Message: "Invalid subscription tier", HTTPStatus: 422}
	ErrEmailTemplateExists = WebRPCError{Code: 3004, Name: "EmailTemplateExists", Message: "Email Template exists", HTTPStatus: 409}
	ErrSubscriptionLimit   = WebRPCError{Code: 3005, Name: "SubscriptionLimit", Message: "Subscription limit reached", HTTPStatus: 402}
	ErrFeatureNotIncluded  = WebRPCError{Code: 3006, Name: "FeatureNotIncluded", Message: "Feature not included", HTTPStatus: 402}
	ErrInvalidNetwork      = WebRPCError{Code: 3007, Name: "InvalidNetwork", Message: "Invalid network", HTTPStatus: 422}
	ErrInvitationExpired   = WebRPCError{Code: 4000, Name: "InvitationExpired", Message: "Invitation code is expired", HTTPStatus: 422}
	ErrAlreadyCollaborator = WebRPCError{Code: 4001, Name: "AlreadyCollaborator", Message: "Already a collaborator", HTTPStatus: 409}
)
