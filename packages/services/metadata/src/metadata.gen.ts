/* eslint-disable */
// sequence-metadata v0.4.0 673a5fa528008c7f9558810fbb24aad978ed7a84
// --
// Code generated by Webrpc-gen@v0.31.0 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=metadata.ridl -target=typescript -client -ignore=@deprecated -compat -out=./clients/metadata.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = 'v1'

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = '673a5fa528008c7f9558810fbb24aad978ed7a84'

//
// Client interface
//

export interface MetadataClient {
  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>

  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>

  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>

  getTask(req: GetTaskArgs, headers?: object, signal?: AbortSignal): Promise<GetTaskReturn>

  getTaskStatus(req: GetTaskStatusArgs, headers?: object, signal?: AbortSignal): Promise<GetTaskStatusReturn>

  /**
   * Contract Info -- returns contract meta-info for contracts found in registered chain's token-lists
   */
  getContractInfo(req: GetContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<GetContractInfoReturn>

  getContractInfoBatch(
    req: GetContractInfoBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractInfoBatchReturn>

  /**
   * Find Contract Info across all chains token-lists. Similar to GetContractInfo above,
   * but it will traverse all chains and results from all.
   */
  findContractInfo(req: FindContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<FindContractInfoReturn>

  /**
   * map of contractAddress :: []ContractInfo
   */
  findContractInfoBatch(
    req: FindContractInfoBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FindContractInfoBatchReturn>

  /**
   * Refresh Contract Info -- refresh contract meta-info
   */
  refreshContractInfo(
    req: RefreshContractInfoArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshContractInfoReturn>

  refreshContractInfoBatch(
    req: RefreshContractInfoBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshContractInfoBatchReturn>

  /**
   * Search for contract infos using a query string
   */
  searchContractsByQuery(
    req: SearchContractsByQueryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchContractsByQueryReturn>

  /**
   * GetTokenMetadata - fetch token metadata for a particular contract and respective tokenIDs
   */
  getTokenMetadata(req: GetTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenMetadataReturn>

  /**
   * GetTokenMetadataBatch allows you to query the token metadata of a batch of contracts and respective tokenIDs
   * where map is contractAddress::[]tokenID => contractAddress::[]TokenMetadata
   *
   * Note, we limit each request to 50 contracts max and 50 tokens max per contract.
   */
  getTokenMetadataBatch(
    req: GetTokenMetadataBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenMetadataBatchReturn>

  /**
   * RefreshTokenMetadata allows you to refresh a contract metadata for contract-level and token-level metadata.
   */
  refreshTokenMetadata(
    req: RefreshTokenMetadataArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshTokenMetadataReturn>

  /**
   * Search ERC721 & ERC1155 token metadata by query string 'q'
   */
  searchTokenMetadataByQuery(
    req: SearchTokenMetadataByQueryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenMetadataByQueryReturn>

  /**
   * Search ERC721 & ERC1155 token metadata by filter object 'filter'
   * which allows to search by text or properties.
   */
  searchTokenMetadata(
    req: SearchTokenMetadataArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenMetadataReturn>

  /**
   * Search ERC721 & ERC1155 for token IDs by filter object 'filter'
   * which allows to search by text or properties.
   */
  searchTokenMetadataTokenIDs(
    req: SearchTokenMetadataTokenIDsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenMetadataTokenIDsReturn>

  /**
   * Get token metadata property filters for a contract address
   */
  getTokenMetadataPropertyFilters(
    req: GetTokenMetadataPropertyFiltersArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenMetadataPropertyFiltersReturn>

  /**
   * Gets Token Directory supported networks
   */
  getTokenDirectoryNetworks(
    req: GetTokenDirectoryNetworksArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenDirectoryNetworksReturn>

  /**
   * Gets Token Directory entries
   */
  getTokenDirectory(
    req: GetTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenDirectoryReturn>

  /**
   * Search in Token Directory
   */
  searchTokenDirectory(
    req: SearchTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenDirectoryReturn>

  /**
   * Niftyswap querying data
   */
  getNiftyswapTokenQuantity(
    req: GetNiftyswapTokenQuantityArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetNiftyswapTokenQuantityReturn>

  /**
   * map of tokenID :: quantity
   */
  getNiftyswapUnitPrices(
    req: GetNiftyswapUnitPricesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetNiftyswapUnitPricesReturn>

  /**
   * map of tokenID :: price
   */
  getNiftyswapUnitPricesWithQuantities(
    req: GetNiftyswapUnitPricesWithQuantitiesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn>
}
export interface CollectionsClient {
  createCollection(req: CreateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<CreateCollectionReturn>

  getCollection(req: GetCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionReturn>

  listCollections(req: ListCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectionsReturn>

  updateCollection(req: UpdateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionReturn>

  deleteCollection(req: DeleteCollectionArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionReturn>

  publishCollection(
    req: PublishCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PublishCollectionReturn>

  unpublishCollection(
    req: UnpublishCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UnpublishCollectionReturn>

  createContractCollection(
    req: CreateContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CreateContractCollectionReturn>

  getContractCollection(
    req: GetContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractCollectionReturn>

  listContractCollections(
    req: ListContractCollectionsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListContractCollectionsReturn>

  updateContractCollection(
    req: UpdateContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateContractCollectionReturn>

  deleteContractCollection(
    req: DeleteContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DeleteContractCollectionReturn>

  createToken(req: CreateTokenArgs, headers?: object, signal?: AbortSignal): Promise<CreateTokenReturn>

  getToken(req: GetTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenReturn>

  listTokens(req: ListTokensArgs, headers?: object, signal?: AbortSignal): Promise<ListTokensReturn>

  updateToken(req: UpdateTokenArgs, headers?: object, signal?: AbortSignal): Promise<UpdateTokenReturn>

  deleteToken(req: DeleteTokenArgs, headers?: object, signal?: AbortSignal): Promise<DeleteTokenReturn>

  createAsset(req: CreateAssetArgs, headers?: object, signal?: AbortSignal): Promise<CreateAssetReturn>

  getAsset(req: GetAssetArgs, headers?: object, signal?: AbortSignal): Promise<GetAssetReturn>

  updateAsset(req: UpdateAssetArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAssetReturn>

  deleteAsset(req: DeleteAssetArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAssetReturn>
}
export interface AdminClient {
  /**
   * ContractInfo
   */
  refreshContractInfoUpdatedBefore(
    req: RefreshContractInfoUpdatedBeforeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshContractInfoUpdatedBeforeReturn>

  /**
   * TokenMetadata
   */
  refreshTokenMetadataUpdatedBefore(
    req: RefreshTokenMetadataUpdatedBeforeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshTokenMetadataUpdatedBeforeReturn>

  /**
   * Contract Info Overrides
   */
  getContractInfoOverride(
    req: GetContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractInfoOverrideReturn>

  getContractInfoOverrides(
    req: GetContractInfoOverridesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractInfoOverridesReturn>

  addContractInfoOverride(
    req: AddContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddContractInfoOverrideReturn>

  updateContractInfoOverride(
    req: UpdateContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateContractInfoOverrideReturn>

  removeContractInfoOverride(
    req: RemoveContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveContractInfoOverrideReturn>

  /**
   * Token Directory
   */
  isInTokenDirectory(
    req: IsInTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsInTokenDirectoryReturn>

  setTokenDirectoryFeatureIndex(
    req: SetTokenDirectoryFeatureIndexArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SetTokenDirectoryFeatureIndexReturn>

  addContractToTokenDirectory(
    req: AddContractToTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddContractToTokenDirectoryReturn>

  removeContractFromTokenDirectory(
    req: RemoveContractFromTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveContractFromTokenDirectoryReturn>

  refreshTokenDirectory(headers?: object, signal?: AbortSignal): Promise<RefreshTokenDirectoryReturn>
}

//
// Schema types
//

export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155',
  ERC6909 = 'ERC6909',
  MISC = 'MISC',
}

export enum Source {
  UNKNOWN = 'UNKNOWN',
  FETCHER = 'FETCHER',
  FETCHER_OPENSEA_API = 'FETCHER_OPENSEA_API',
  FETCHER_ENS_API = 'FETCHER_ENS_API',
  FETCHER_ON_CHAIN_ERC20_INTERFACE = 'FETCHER_ON_CHAIN_ERC20_INTERFACE',
  FETCHER_ON_CHAIN_TOKEN_URI = 'FETCHER_ON_CHAIN_TOKEN_URI',
  FETCHER_ON_CHAIN_CONTRACT_URI = 'FETCHER_ON_CHAIN_CONTRACT_URI',
  FETCHER_TOKEN_DIRECTORY_ADMIN = 'FETCHER_TOKEN_DIRECTORY_ADMIN',
  TOKEN_DIRECTORY = 'TOKEN_DIRECTORY',
  TOKEN_DIRECTORY_PUBLIC_TOKEN_LIST = 'TOKEN_DIRECTORY_PUBLIC_TOKEN_LIST',
  TOKEN_DIRECTORY_3RD_PARTY = 'TOKEN_DIRECTORY_3RD_PARTY',
  TOKEN_DIRECTORY_SEQUENCE_GITHUB = 'TOKEN_DIRECTORY_SEQUENCE_GITHUB',
  TOKEN_DIRECTORY_SEQUENCE_BUILDER = 'TOKEN_DIRECTORY_SEQUENCE_BUILDER',
  SEQUENCE_BUILDER = 'SEQUENCE_BUILDER',
  SEQUENCE_BUILDER_DEPLOYED = 'SEQUENCE_BUILDER_DEPLOYED',
  SEQUENCE_BUILDER_COLLECTIONS = 'SEQUENCE_BUILDER_COLLECTIONS',
  SEQUENCE_BUILDER_ADMIN = 'SEQUENCE_BUILDER_ADMIN',
}

export enum ResourceStatus {
  NOT_AVAILABLE = 'NOT_AVAILABLE',
  REFRESHING = 'REFRESHING',
  AVAILABLE = 'AVAILABLE',
}

export enum PropertyType {
  INT = 'INT',
  STRING = 'STRING',
  ARRAY = 'ARRAY',
  GENERIC = 'GENERIC',
}

export enum SwapType {
  UNKNOWN = 'UNKNOWN',
  BUY = 'BUY',
  SELL = 'SELL',
}

export enum TaskStatus {
  QUEUED = 'QUEUED',
  PAUSED = 'PAUSED',
  FAILED = 'FAILED',
  DONE = 'DONE',
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  uptimeString: string
  ver: string
  branch: string
  commitHash: string
  runnable: { [key: string]: RunnableStatus }
}

export interface RunnableStatus {
  running: boolean
  restarts: number
  startTime: string
  endTime?: string
  lastError: any
}

export interface ContractIndex {
  chainId: number
  address: string
  type: ContractType
  source: Source
  metadata: { [key: string]: any }
  contentHash: number
  deployed: boolean
  bytecodeHash: string
  notFound: boolean
  updatedAt: string
  queuedAt?: string
  status: ResourceStatus
}

export interface TokenIndex {
  chainId: number
  contractAddress: string
  tokenId: string
  source: Source
  metadata: { [key: string]: any }
  notFound?: boolean
  lastFetched?: string
  fetchCount?: number
  updatedAt: string
  queuedAt?: string
}

export interface ContractInfo {
  chainId: number
  address: string
  source: string
  name: string
  type: string
  symbol: string
  decimals?: number
  logoURI: string
  deployed: boolean
  bytecodeHash: string
  extensions: ContractInfoExtensions
  updatedAt: string
  queuedAt?: string
  status: ResourceStatus
}

export interface ContractInfoExtensions {
  link?: string
  description?: string
  categories?: Array<string>
  bridgeInfo?: { [key: string]: ContractInfoExtensionBridgeInfo }
  ogImage?: string
  ogName?: string
  originChainId?: number
  originAddress?: string
  blacklist?: boolean
  verified?: boolean
  verifiedBy?: string
  featured?: boolean
  featureIndex?: number
}

export interface ContractInfoExtensionBridgeInfo {
  tokenAddress: string
}

export interface ContractInfoOverride {
  name?: string
  type?: string
  symbol?: string
  decimals?: number
  logoURI?: string
  extensions: ContractInfoExtensionsOverride
}

export interface ContractInfoExtensionsOverride {
  link?: string
  description?: string
  categories?: Array<string>
  ogImage?: string
  ogName?: string
  originChainId?: number
  originAddress?: string
  blacklist?: boolean
  verified?: boolean
  verifiedBy?: string
  featureIndex?: number
}

export interface TokenMetadata {
  chainId?: number
  contractAddress?: string
  tokenId: string
  source: string
  name: string
  description?: string
  image?: string
  video?: string
  audio?: string
  properties?: { [key: string]: any }
  attributes: Array<{ [key: string]: any }>
  image_data?: string
  external_url?: string
  background_color?: string
  animation_url?: string
  decimals?: number
  updatedAt?: string
  assets?: Array<Asset>
  status: ResourceStatus
  queuedAt?: string
  lastFetched?: string
}

export interface PropertyFilter {
  name: string
  type: PropertyType
  min?: number
  max?: number
  values?: Array<any>
}

export interface Filter {
  text?: string
  properties?: Array<PropertyFilter>
}

export interface Collection {
  id: number
  projectId: number
  metadata: CollectionMetadata
  private: boolean
  revealKey?: string
  tokenCount?: number
  createdAt?: string
  updatedAt?: string
  deletedAt?: string
  baseURIs?: CollectionBaseURIs
  assets?: Array<Asset>
}

export interface CollectionMetadata {
  name: string
  description?: string
  image?: string
  external_link?: string
  properties?: { [key: string]: any }
  attributes?: Array<{ [key: string]: any }>
}

export interface CollectionBaseURIs {
  contractMetadataURI: string
  tokenMetadataURI: string
}

export interface ContractCollection {
  id: number
  chainId: number
  contractAddress: string
  collectionId: number
}

export interface Asset {
  id: number
  collectionId: number
  tokenId?: string
  url?: string
  metadataField: string
  name?: string
  filesize?: number
  mimeType?: string
  width?: number
  height?: number
  updatedAt?: string
}

export interface Token {
  collectionId: number
  tokenId: string
  metadata: TokenMetadata
  private: boolean
  updatedAt?: string
}

export interface GetNiftyswapUnitPricesRequest {
  swapType: SwapType
  ids: Array<string>
  amounts: Array<string>
}

export interface GetNiftyswapUnitPricesResponse {
  unitPrice: string
  unitAmount: string
  availableAmount: string
}

export interface Page {
  page?: number
  column?: string
  before?: any
  after?: any
  pageSize?: number
  more?: boolean
}

export interface Task {
  id: number
  queue: string
  status: TaskStatus
  try: number
  runAt?: string
  lastRanAt?: string
  createdAt?: string
  payload: Array<string>
  result: Array<string>
}

export interface PingArgs {}

export interface PingReturn {
  status: boolean
}

export interface VersionArgs {}

export interface VersionReturn {
  version: Version
}

export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: RuntimeStatus
}

export interface GetTaskArgs {
  taskId: number
}

export interface GetTaskReturn {
  task: Task
}

export interface GetTaskStatusArgs {
  taskId: number
}

export interface GetTaskStatusReturn {
  status?: TaskStatus
}

export interface GetContractInfoArgs {
  chainID: string
  contractAddress: string
}

export interface GetContractInfoReturn {
  contractInfo: ContractInfo
  taskID?: number
}

export interface GetContractInfoBatchArgs {
  chainID: string
  contractAddresses: Array<string>
}

export interface GetContractInfoBatchReturn {
  contractInfoMap: { [key: string]: ContractInfo }
  taskID?: number
}

export interface FindContractInfoArgs {
  contractAddress: string
}

export interface FindContractInfoReturn {
  contractInfoList: Array<ContractInfo>
}

export interface FindContractInfoBatchArgs {
  contractAddresses: Array<string>
}

export interface FindContractInfoBatchReturn {
  contractInfoByChain: { [key: string]: Array<ContractInfo> }
}

export interface RefreshContractInfoArgs {
  chainID: string
  contractAddress: string
}

export interface RefreshContractInfoReturn {
  taskID?: number
}

export interface RefreshContractInfoBatchArgs {
  chainID: string
  contractAddresses: Array<string>
}

export interface RefreshContractInfoBatchReturn {
  taskID?: number
}

export interface SearchContractsByQueryArgs {
  q: string
  chainID?: string
  chainIDs?: Array<string>
  types?: Array<ContractType>
  page?: Page
}

export interface SearchContractsByQueryReturn {
  contractInfo: Array<ContractInfo>
  nextPage: Page
}

export interface GetTokenMetadataArgs {
  chainID: string
  contractAddress: string
  tokenIDs: Array<string>
}

export interface GetTokenMetadataReturn {
  tokenMetadata: Array<TokenMetadata>
  taskID?: number
}

export interface GetTokenMetadataBatchArgs {
  chainID: string
  contractTokenMap: { [key: string]: Array<string> }
}

export interface GetTokenMetadataBatchReturn {
  contractTokenMetadata: { [key: string]: Array<TokenMetadata> }
  taskID?: number
}

export interface RefreshTokenMetadataArgs {
  chainID: string
  contractAddress: string
  tokenIDs?: Array<string>
  newMints?: boolean
}

export interface RefreshTokenMetadataReturn {
  taskID: number
}

export interface SearchTokenMetadataByQueryArgs {
  q: string
  chainID?: string
  contractAddress?: string
  page?: Page
}

export interface SearchTokenMetadataByQueryReturn {
  tokenMetadata: Array<TokenMetadata>
  nextPage: Page
}

export interface SearchTokenMetadataArgs {
  chainID: string
  contractAddress: string
  filter: Filter
  page?: Page
}

export interface SearchTokenMetadataReturn {
  page: Page
  tokenMetadata: Array<TokenMetadata>
}

export interface SearchTokenMetadataTokenIDsArgs {
  chainID: string
  contractAddress: string
  filter: Filter
  page?: Page
}

export interface SearchTokenMetadataTokenIDsReturn {
  page: Page
  tokenIDs: Array<string>
}

export interface GetTokenMetadataPropertyFiltersArgs {
  chainID: string
  contractAddress: string
  excludeProperties: Array<string>
  excludePropertyValues?: boolean
}

export interface GetTokenMetadataPropertyFiltersReturn {
  filters: Array<PropertyFilter>
}

export interface GetTokenDirectoryNetworksArgs {
  includeTestnets?: boolean
  onlyFeatured?: boolean
}

export interface GetTokenDirectoryNetworksReturn {
  chainIDs: Array<number>
  networks: Array<string>
}

export interface GetTokenDirectoryArgs {
  chainID?: string
  includeTestnets?: boolean
  onlyFeatured?: boolean
  page?: Page
}

export interface GetTokenDirectoryReturn {
  contracts: Array<ContractInfo>
  page: Page
}

export interface SearchTokenDirectoryArgs {
  query: string
  chainID?: number
  includeTestnets?: boolean
  onlyFeatured?: boolean
  page?: Page
}

export interface SearchTokenDirectoryReturn {
  contracts: Array<ContractInfo>
  page: Page
}

export interface GetNiftyswapTokenQuantityArgs {
  chainID: string
  contractAddress: string
  tokenIDs: Array<string>
}

export interface GetNiftyswapTokenQuantityReturn {
  quantity: { [key: string]: string }
}

export interface GetNiftyswapUnitPricesArgs {
  chainID: string
  contractAddress: string
  req: GetNiftyswapUnitPricesRequest
  fresh: boolean
}

export interface GetNiftyswapUnitPricesReturn {
  prices: { [key: string]: string }
}

export interface GetNiftyswapUnitPricesWithQuantitiesArgs {
  chainID: string
  contractAddress: string
  req: GetNiftyswapUnitPricesRequest
  fresh: boolean
}

export interface GetNiftyswapUnitPricesWithQuantitiesReturn {
  prices: { [key: string]: GetNiftyswapUnitPricesResponse }
}

export interface CreateCollectionArgs {
  projectId?: number
  collection: Collection
}

export interface CreateCollectionReturn {
  collection: Collection
}

export interface GetCollectionArgs {
  projectId?: number
  collectionId: number
}

export interface GetCollectionReturn {
  collection: Collection
}

export interface ListCollectionsArgs {
  projectId?: number
  page?: Page
}

export interface ListCollectionsReturn {
  page: Page
  collections: Array<Collection>
}

export interface UpdateCollectionArgs {
  projectId?: number
  collection: Collection
}

export interface UpdateCollectionReturn {
  collection: Collection
}

export interface DeleteCollectionArgs {
  projectId?: number
  collectionId: number
}

export interface DeleteCollectionReturn {
  status: boolean
}

export interface PublishCollectionArgs {
  projectId?: number
  collectionId: number
  recursive?: boolean
}

export interface PublishCollectionReturn {
  collection: Collection
}

export interface UnpublishCollectionArgs {
  projectId?: number
  collectionId: number
}

export interface UnpublishCollectionReturn {
  collection: Collection
}

export interface CreateContractCollectionArgs {
  projectId: number
  contractCollection: ContractCollection
}

export interface CreateContractCollectionReturn {
  contractCollection: ContractCollection
}

export interface GetContractCollectionArgs {
  projectId: number
  chainId: number
  contractAddress: string
}

export interface GetContractCollectionReturn {
  contractCollection: ContractCollection
}

export interface ListContractCollectionsArgs {
  projectId: number
  collectionId?: number
  page?: Page
}

export interface ListContractCollectionsReturn {
  contractCollections: Array<ContractCollection>
  collections: Array<Collection>
  page: Page
}

export interface UpdateContractCollectionArgs {
  projectId: number
  contractCollection: ContractCollection
}

export interface UpdateContractCollectionReturn {
  ok: boolean
}

export interface DeleteContractCollectionArgs {
  projectId: number
  chainId: number
  contractAddress: string
}

export interface DeleteContractCollectionReturn {
  ok: boolean
}

export interface CreateTokenArgs {
  projectId?: number
  collectionId: number
  token: TokenMetadata
  private?: boolean
}

export interface CreateTokenReturn {
  token: TokenMetadata
  assets: Array<Asset>
}

export interface GetTokenArgs {
  projectId?: number
  collectionId: number
  tokenId: string
}

export interface GetTokenReturn {
  token: TokenMetadata
  assets: Array<Asset>
}

export interface ListTokensArgs {
  projectId?: number
  collectionId: number
  page?: Page
}

export interface ListTokensReturn {
  page: Page
  tokens: Array<TokenMetadata>
}

export interface UpdateTokenArgs {
  projectId?: number
  collectionId: number
  tokenId: string
  token: TokenMetadata
  private?: boolean
}

export interface UpdateTokenReturn {
  token: TokenMetadata
}

export interface DeleteTokenArgs {
  projectId?: number
  collectionId: number
  tokenId: string
}

export interface DeleteTokenReturn {
  status: boolean
}

export interface CreateAssetArgs {
  projectId?: number
  asset: Asset
}

export interface CreateAssetReturn {
  asset: Asset
}

export interface GetAssetArgs {
  projectId?: number
  assetId: number
}

export interface GetAssetReturn {
  asset: Asset
}

export interface UpdateAssetArgs {
  projectId?: number
  asset: Asset
}

export interface UpdateAssetReturn {
  asset: Asset
}

export interface DeleteAssetArgs {
  projectId?: number
  assetId: number
}

export interface DeleteAssetReturn {
  status: boolean
}

export interface RefreshContractInfoUpdatedBeforeArgs {
  before: string
  maxContractNumber: number
}

export interface RefreshContractInfoUpdatedBeforeReturn {
  taskIDs: Array<number>
}

export interface RefreshTokenMetadataUpdatedBeforeArgs {
  before: string
  maxTokenNumber: number
}

export interface RefreshTokenMetadataUpdatedBeforeReturn {
  taskIDs: Array<number>
}

export interface GetContractInfoOverrideArgs {
  chainID: string
  contractAddress: string
}

export interface GetContractInfoOverrideReturn {
  contractInfoOverride: ContractInfoOverride
}

export interface GetContractInfoOverridesArgs {
  chainID?: string
  page?: Page
}

export interface GetContractInfoOverridesReturn {
  contractInfoOverrides: Array<ContractInfoOverride>
  page: Page
}

export interface AddContractInfoOverrideArgs {
  chainID: string
  contractAddress: string
  contractInfoOverride: ContractInfoOverride
}

export interface AddContractInfoOverrideReturn {
  ok: boolean
}

export interface UpdateContractInfoOverrideArgs {
  chainID: string
  contractAddress: string
  contractInfoOverride: ContractInfoOverride
}

export interface UpdateContractInfoOverrideReturn {
  ok: boolean
}

export interface RemoveContractInfoOverrideArgs {
  chainID: string
  contractAddress: string
}

export interface RemoveContractInfoOverrideReturn {
  ok: boolean
}

export interface IsInTokenDirectoryArgs {
  chainID: string
  contractAddress: string
}

export interface IsInTokenDirectoryReturn {
  ok: boolean
  featureIndex: number
}

export interface SetTokenDirectoryFeatureIndexArgs {
  chainID: string
  contractAddress: string
  featureIndex: number
}

export interface SetTokenDirectoryFeatureIndexReturn {
  ok: boolean
}

export interface AddContractToTokenDirectoryArgs {
  chainID: string
  contractAddress: string
}

export interface AddContractToTokenDirectoryReturn {
  ok: boolean
}

export interface RemoveContractFromTokenDirectoryArgs {
  chainID: string
  contractAddress: string
}

export interface RemoveContractFromTokenDirectoryReturn {
  ok: boolean
}

export interface RefreshTokenDirectoryArgs {}

export interface RefreshTokenDirectoryReturn {
  taskID: number
}

//
// Client
//

export class Metadata implements MetadataClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Metadata/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  queryKey = {
    ping: () => ['Metadata', 'ping'] as const,
    version: () => ['Metadata', 'version'] as const,
    runtimeStatus: () => ['Metadata', 'runtimeStatus'] as const,
    getTask: (req: GetTaskArgs) => ['Metadata', 'getTask', req] as const,
    getTaskStatus: (req: GetTaskStatusArgs) => ['Metadata', 'getTaskStatus', req] as const,
    getContractInfo: (req: GetContractInfoArgs) => ['Metadata', 'getContractInfo', req] as const,
    getContractInfoBatch: (req: GetContractInfoBatchArgs) => ['Metadata', 'getContractInfoBatch', req] as const,
    findContractInfo: (req: FindContractInfoArgs) => ['Metadata', 'findContractInfo', req] as const,
    findContractInfoBatch: (req: FindContractInfoBatchArgs) => ['Metadata', 'findContractInfoBatch', req] as const,
    refreshContractInfo: (req: RefreshContractInfoArgs) => ['Metadata', 'refreshContractInfo', req] as const,
    refreshContractInfoBatch: (req: RefreshContractInfoBatchArgs) =>
      ['Metadata', 'refreshContractInfoBatch', req] as const,
    searchContractsByQuery: (req: SearchContractsByQueryArgs) => ['Metadata', 'searchContractsByQuery', req] as const,
    getTokenMetadata: (req: GetTokenMetadataArgs) => ['Metadata', 'getTokenMetadata', req] as const,
    getTokenMetadataBatch: (req: GetTokenMetadataBatchArgs) => ['Metadata', 'getTokenMetadataBatch', req] as const,
    refreshTokenMetadata: (req: RefreshTokenMetadataArgs) => ['Metadata', 'refreshTokenMetadata', req] as const,
    searchTokenMetadataByQuery: (req: SearchTokenMetadataByQueryArgs) =>
      ['Metadata', 'searchTokenMetadataByQuery', req] as const,
    searchTokenMetadata: (req: SearchTokenMetadataArgs) => ['Metadata', 'searchTokenMetadata', req] as const,
    searchTokenMetadataTokenIDs: (req: SearchTokenMetadataTokenIDsArgs) =>
      ['Metadata', 'searchTokenMetadataTokenIDs', req] as const,
    getTokenMetadataPropertyFilters: (req: GetTokenMetadataPropertyFiltersArgs) =>
      ['Metadata', 'getTokenMetadataPropertyFilters', req] as const,
    getTokenDirectoryNetworks: (req: GetTokenDirectoryNetworksArgs) =>
      ['Metadata', 'getTokenDirectoryNetworks', req] as const,
    getTokenDirectory: (req: GetTokenDirectoryArgs) => ['Metadata', 'getTokenDirectory', req] as const,
    searchTokenDirectory: (req: SearchTokenDirectoryArgs) => ['Metadata', 'searchTokenDirectory', req] as const,
    getNiftyswapTokenQuantity: (req: GetNiftyswapTokenQuantityArgs) =>
      ['Metadata', 'getNiftyswapTokenQuantity', req] as const,
    getNiftyswapUnitPrices: (req: GetNiftyswapUnitPricesArgs) => ['Metadata', 'getNiftyswapUnitPrices', req] as const,
    getNiftyswapUnitPricesWithQuantities: (req: GetNiftyswapUnitPricesWithQuantitiesArgs) =>
      ['Metadata', 'getNiftyswapUnitPricesWithQuantities', req] as const,
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<PingReturn>(_data, 'PingReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {
    return this.fetch(this.url('Version'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<VersionReturn>(_data, 'VersionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {
    return this.fetch(this.url('RuntimeStatus'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RuntimeStatusReturn>(_data, 'RuntimeStatusReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getTask = (req: GetTaskArgs, headers?: object, signal?: AbortSignal): Promise<GetTaskReturn> => {
    return this.fetch(this.url('GetTask'), createHttpRequest(JsonEncode(req, 'GetTaskArgs'), headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTaskReturn>(_data, 'GetTaskReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getTaskStatus = (req: GetTaskStatusArgs, headers?: object, signal?: AbortSignal): Promise<GetTaskStatusReturn> => {
    return this.fetch(
      this.url('GetTaskStatus'),
      createHttpRequest(JsonEncode(req, 'GetTaskStatusArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTaskStatusReturn>(_data, 'GetTaskStatusReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getContractInfo = (
    req: GetContractInfoArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractInfoReturn> => {
    return this.fetch(
      this.url('GetContractInfo'),
      createHttpRequest(JsonEncode(req, 'GetContractInfoArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetContractInfoReturn>(_data, 'GetContractInfoReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getContractInfoBatch = (
    req: GetContractInfoBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractInfoBatchReturn> => {
    return this.fetch(
      this.url('GetContractInfoBatch'),
      createHttpRequest(JsonEncode(req, 'GetContractInfoBatchArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetContractInfoBatchReturn>(_data, 'GetContractInfoBatchReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  findContractInfo = (
    req: FindContractInfoArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FindContractInfoReturn> => {
    return this.fetch(
      this.url('FindContractInfo'),
      createHttpRequest(JsonEncode(req, 'FindContractInfoArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<FindContractInfoReturn>(_data, 'FindContractInfoReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  findContractInfoBatch = (
    req: FindContractInfoBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<FindContractInfoBatchReturn> => {
    return this.fetch(
      this.url('FindContractInfoBatch'),
      createHttpRequest(JsonEncode(req, 'FindContractInfoBatchArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<FindContractInfoBatchReturn>(_data, 'FindContractInfoBatchReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  refreshContractInfo = (
    req: RefreshContractInfoArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshContractInfoReturn> => {
    return this.fetch(
      this.url('RefreshContractInfo'),
      createHttpRequest(JsonEncode(req, 'RefreshContractInfoArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RefreshContractInfoReturn>(_data, 'RefreshContractInfoReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  refreshContractInfoBatch = (
    req: RefreshContractInfoBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshContractInfoBatchReturn> => {
    return this.fetch(
      this.url('RefreshContractInfoBatch'),
      createHttpRequest(JsonEncode(req, 'RefreshContractInfoBatchArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RefreshContractInfoBatchReturn>(_data, 'RefreshContractInfoBatchReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  searchContractsByQuery = (
    req: SearchContractsByQueryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchContractsByQueryReturn> => {
    return this.fetch(
      this.url('SearchContractsByQuery'),
      createHttpRequest(JsonEncode(req, 'SearchContractsByQueryArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SearchContractsByQueryReturn>(_data, 'SearchContractsByQueryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getTokenMetadata = (
    req: GetTokenMetadataArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenMetadataReturn> => {
    return this.fetch(
      this.url('GetTokenMetadata'),
      createHttpRequest(JsonEncode(req, 'GetTokenMetadataArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTokenMetadataReturn>(_data, 'GetTokenMetadataReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getTokenMetadataBatch = (
    req: GetTokenMetadataBatchArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenMetadataBatchReturn> => {
    return this.fetch(
      this.url('GetTokenMetadataBatch'),
      createHttpRequest(JsonEncode(req, 'GetTokenMetadataBatchArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTokenMetadataBatchReturn>(_data, 'GetTokenMetadataBatchReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  refreshTokenMetadata = (
    req: RefreshTokenMetadataArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshTokenMetadataReturn> => {
    return this.fetch(
      this.url('RefreshTokenMetadata'),
      createHttpRequest(JsonEncode(req, 'RefreshTokenMetadataArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RefreshTokenMetadataReturn>(_data, 'RefreshTokenMetadataReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  searchTokenMetadataByQuery = (
    req: SearchTokenMetadataByQueryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenMetadataByQueryReturn> => {
    return this.fetch(
      this.url('SearchTokenMetadataByQuery'),
      createHttpRequest(JsonEncode(req, 'SearchTokenMetadataByQueryArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SearchTokenMetadataByQueryReturn>(_data, 'SearchTokenMetadataByQueryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  searchTokenMetadata = (
    req: SearchTokenMetadataArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenMetadataReturn> => {
    return this.fetch(
      this.url('SearchTokenMetadata'),
      createHttpRequest(JsonEncode(req, 'SearchTokenMetadataArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SearchTokenMetadataReturn>(_data, 'SearchTokenMetadataReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  searchTokenMetadataTokenIDs = (
    req: SearchTokenMetadataTokenIDsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenMetadataTokenIDsReturn> => {
    return this.fetch(
      this.url('SearchTokenMetadataTokenIDs'),
      createHttpRequest(JsonEncode(req, 'SearchTokenMetadataTokenIDsArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SearchTokenMetadataTokenIDsReturn>(_data, 'SearchTokenMetadataTokenIDsReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getTokenMetadataPropertyFilters = (
    req: GetTokenMetadataPropertyFiltersArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenMetadataPropertyFiltersReturn> => {
    return this.fetch(
      this.url('GetTokenMetadataPropertyFilters'),
      createHttpRequest(JsonEncode(req, 'GetTokenMetadataPropertyFiltersArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTokenMetadataPropertyFiltersReturn>(_data, 'GetTokenMetadataPropertyFiltersReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getTokenDirectoryNetworks = (
    req: GetTokenDirectoryNetworksArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenDirectoryNetworksReturn> => {
    return this.fetch(
      this.url('GetTokenDirectoryNetworks'),
      createHttpRequest(JsonEncode(req, 'GetTokenDirectoryNetworksArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTokenDirectoryNetworksReturn>(_data, 'GetTokenDirectoryNetworksReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getTokenDirectory = (
    req: GetTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetTokenDirectoryReturn> => {
    return this.fetch(
      this.url('GetTokenDirectory'),
      createHttpRequest(JsonEncode(req, 'GetTokenDirectoryArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTokenDirectoryReturn>(_data, 'GetTokenDirectoryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  searchTokenDirectory = (
    req: SearchTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SearchTokenDirectoryReturn> => {
    return this.fetch(
      this.url('SearchTokenDirectory'),
      createHttpRequest(JsonEncode(req, 'SearchTokenDirectoryArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SearchTokenDirectoryReturn>(_data, 'SearchTokenDirectoryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getNiftyswapTokenQuantity = (
    req: GetNiftyswapTokenQuantityArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetNiftyswapTokenQuantityReturn> => {
    return this.fetch(
      this.url('GetNiftyswapTokenQuantity'),
      createHttpRequest(JsonEncode(req, 'GetNiftyswapTokenQuantityArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetNiftyswapTokenQuantityReturn>(_data, 'GetNiftyswapTokenQuantityReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getNiftyswapUnitPrices = (
    req: GetNiftyswapUnitPricesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetNiftyswapUnitPricesReturn> => {
    return this.fetch(
      this.url('GetNiftyswapUnitPrices'),
      createHttpRequest(JsonEncode(req, 'GetNiftyswapUnitPricesArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetNiftyswapUnitPricesReturn>(_data, 'GetNiftyswapUnitPricesReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getNiftyswapUnitPricesWithQuantities = (
    req: GetNiftyswapUnitPricesWithQuantitiesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn> => {
    return this.fetch(
      this.url('GetNiftyswapUnitPricesWithQuantities'),
      createHttpRequest(JsonEncode(req, 'GetNiftyswapUnitPricesWithQuantitiesArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetNiftyswapUnitPricesWithQuantitiesReturn>(
            _data,
            'GetNiftyswapUnitPricesWithQuantitiesReturn',
          )
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }
}
export class Collections implements CollectionsClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Collections/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  queryKey = {
    createCollection: (req: CreateCollectionArgs) => ['Collections', 'createCollection', req] as const,
    getCollection: (req: GetCollectionArgs) => ['Collections', 'getCollection', req] as const,
    listCollections: (req: ListCollectionsArgs) => ['Collections', 'listCollections', req] as const,
    updateCollection: (req: UpdateCollectionArgs) => ['Collections', 'updateCollection', req] as const,
    deleteCollection: (req: DeleteCollectionArgs) => ['Collections', 'deleteCollection', req] as const,
    publishCollection: (req: PublishCollectionArgs) => ['Collections', 'publishCollection', req] as const,
    unpublishCollection: (req: UnpublishCollectionArgs) => ['Collections', 'unpublishCollection', req] as const,
    createContractCollection: (req: CreateContractCollectionArgs) =>
      ['Collections', 'createContractCollection', req] as const,
    getContractCollection: (req: GetContractCollectionArgs) => ['Collections', 'getContractCollection', req] as const,
    listContractCollections: (req: ListContractCollectionsArgs) =>
      ['Collections', 'listContractCollections', req] as const,
    updateContractCollection: (req: UpdateContractCollectionArgs) =>
      ['Collections', 'updateContractCollection', req] as const,
    deleteContractCollection: (req: DeleteContractCollectionArgs) =>
      ['Collections', 'deleteContractCollection', req] as const,
    createToken: (req: CreateTokenArgs) => ['Collections', 'createToken', req] as const,
    getToken: (req: GetTokenArgs) => ['Collections', 'getToken', req] as const,
    listTokens: (req: ListTokensArgs) => ['Collections', 'listTokens', req] as const,
    updateToken: (req: UpdateTokenArgs) => ['Collections', 'updateToken', req] as const,
    deleteToken: (req: DeleteTokenArgs) => ['Collections', 'deleteToken', req] as const,
    createAsset: (req: CreateAssetArgs) => ['Collections', 'createAsset', req] as const,
    getAsset: (req: GetAssetArgs) => ['Collections', 'getAsset', req] as const,
    updateAsset: (req: UpdateAssetArgs) => ['Collections', 'updateAsset', req] as const,
    deleteAsset: (req: DeleteAssetArgs) => ['Collections', 'deleteAsset', req] as const,
  }

  createCollection = (
    req: CreateCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CreateCollectionReturn> => {
    return this.fetch(
      this.url('CreateCollection'),
      createHttpRequest(JsonEncode(req, 'CreateCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CreateCollectionReturn>(_data, 'CreateCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getCollection = (req: GetCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionReturn> => {
    return this.fetch(
      this.url('GetCollection'),
      createHttpRequest(JsonEncode(req, 'GetCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetCollectionReturn>(_data, 'GetCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  listCollections = (
    req: ListCollectionsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListCollectionsReturn> => {
    return this.fetch(
      this.url('ListCollections'),
      createHttpRequest(JsonEncode(req, 'ListCollectionsArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListCollectionsReturn>(_data, 'ListCollectionsReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  updateCollection = (
    req: UpdateCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateCollectionReturn> => {
    return this.fetch(
      this.url('UpdateCollection'),
      createHttpRequest(JsonEncode(req, 'UpdateCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdateCollectionReturn>(_data, 'UpdateCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  deleteCollection = (
    req: DeleteCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DeleteCollectionReturn> => {
    return this.fetch(
      this.url('DeleteCollection'),
      createHttpRequest(JsonEncode(req, 'DeleteCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<DeleteCollectionReturn>(_data, 'DeleteCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  publishCollection = (
    req: PublishCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<PublishCollectionReturn> => {
    return this.fetch(
      this.url('PublishCollection'),
      createHttpRequest(JsonEncode(req, 'PublishCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<PublishCollectionReturn>(_data, 'PublishCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  unpublishCollection = (
    req: UnpublishCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UnpublishCollectionReturn> => {
    return this.fetch(
      this.url('UnpublishCollection'),
      createHttpRequest(JsonEncode(req, 'UnpublishCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UnpublishCollectionReturn>(_data, 'UnpublishCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  createContractCollection = (
    req: CreateContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<CreateContractCollectionReturn> => {
    return this.fetch(
      this.url('CreateContractCollection'),
      createHttpRequest(JsonEncode(req, 'CreateContractCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CreateContractCollectionReturn>(_data, 'CreateContractCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getContractCollection = (
    req: GetContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractCollectionReturn> => {
    return this.fetch(
      this.url('GetContractCollection'),
      createHttpRequest(JsonEncode(req, 'GetContractCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetContractCollectionReturn>(_data, 'GetContractCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  listContractCollections = (
    req: ListContractCollectionsArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<ListContractCollectionsReturn> => {
    return this.fetch(
      this.url('ListContractCollections'),
      createHttpRequest(JsonEncode(req, 'ListContractCollectionsArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListContractCollectionsReturn>(_data, 'ListContractCollectionsReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  updateContractCollection = (
    req: UpdateContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateContractCollectionReturn> => {
    return this.fetch(
      this.url('UpdateContractCollection'),
      createHttpRequest(JsonEncode(req, 'UpdateContractCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdateContractCollectionReturn>(_data, 'UpdateContractCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  deleteContractCollection = (
    req: DeleteContractCollectionArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<DeleteContractCollectionReturn> => {
    return this.fetch(
      this.url('DeleteContractCollection'),
      createHttpRequest(JsonEncode(req, 'DeleteContractCollectionArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<DeleteContractCollectionReturn>(_data, 'DeleteContractCollectionReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  createToken = (req: CreateTokenArgs, headers?: object, signal?: AbortSignal): Promise<CreateTokenReturn> => {
    return this.fetch(
      this.url('CreateToken'),
      createHttpRequest(JsonEncode(req, 'CreateTokenArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CreateTokenReturn>(_data, 'CreateTokenReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getToken = (req: GetTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenReturn> => {
    return this.fetch(this.url('GetToken'), createHttpRequest(JsonEncode(req, 'GetTokenArgs'), headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetTokenReturn>(_data, 'GetTokenReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  listTokens = (req: ListTokensArgs, headers?: object, signal?: AbortSignal): Promise<ListTokensReturn> => {
    return this.fetch(
      this.url('ListTokens'),
      createHttpRequest(JsonEncode(req, 'ListTokensArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<ListTokensReturn>(_data, 'ListTokensReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  updateToken = (req: UpdateTokenArgs, headers?: object, signal?: AbortSignal): Promise<UpdateTokenReturn> => {
    return this.fetch(
      this.url('UpdateToken'),
      createHttpRequest(JsonEncode(req, 'UpdateTokenArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdateTokenReturn>(_data, 'UpdateTokenReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  deleteToken = (req: DeleteTokenArgs, headers?: object, signal?: AbortSignal): Promise<DeleteTokenReturn> => {
    return this.fetch(
      this.url('DeleteToken'),
      createHttpRequest(JsonEncode(req, 'DeleteTokenArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<DeleteTokenReturn>(_data, 'DeleteTokenReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  createAsset = (req: CreateAssetArgs, headers?: object, signal?: AbortSignal): Promise<CreateAssetReturn> => {
    return this.fetch(
      this.url('CreateAsset'),
      createHttpRequest(JsonEncode(req, 'CreateAssetArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<CreateAssetReturn>(_data, 'CreateAssetReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getAsset = (req: GetAssetArgs, headers?: object, signal?: AbortSignal): Promise<GetAssetReturn> => {
    return this.fetch(this.url('GetAsset'), createHttpRequest(JsonEncode(req, 'GetAssetArgs'), headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetAssetReturn>(_data, 'GetAssetReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  updateAsset = (req: UpdateAssetArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAssetReturn> => {
    return this.fetch(
      this.url('UpdateAsset'),
      createHttpRequest(JsonEncode(req, 'UpdateAssetArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdateAssetReturn>(_data, 'UpdateAssetReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  deleteAsset = (req: DeleteAssetArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAssetReturn> => {
    return this.fetch(
      this.url('DeleteAsset'),
      createHttpRequest(JsonEncode(req, 'DeleteAssetArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<DeleteAssetReturn>(_data, 'DeleteAssetReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }
}
export class Admin implements AdminClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Admin/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  queryKey = {
    refreshContractInfoUpdatedBefore: (req: RefreshContractInfoUpdatedBeforeArgs) =>
      ['Admin', 'refreshContractInfoUpdatedBefore', req] as const,
    refreshTokenMetadataUpdatedBefore: (req: RefreshTokenMetadataUpdatedBeforeArgs) =>
      ['Admin', 'refreshTokenMetadataUpdatedBefore', req] as const,
    getContractInfoOverride: (req: GetContractInfoOverrideArgs) => ['Admin', 'getContractInfoOverride', req] as const,
    getContractInfoOverrides: (req: GetContractInfoOverridesArgs) =>
      ['Admin', 'getContractInfoOverrides', req] as const,
    addContractInfoOverride: (req: AddContractInfoOverrideArgs) => ['Admin', 'addContractInfoOverride', req] as const,
    updateContractInfoOverride: (req: UpdateContractInfoOverrideArgs) =>
      ['Admin', 'updateContractInfoOverride', req] as const,
    removeContractInfoOverride: (req: RemoveContractInfoOverrideArgs) =>
      ['Admin', 'removeContractInfoOverride', req] as const,
    isInTokenDirectory: (req: IsInTokenDirectoryArgs) => ['Admin', 'isInTokenDirectory', req] as const,
    setTokenDirectoryFeatureIndex: (req: SetTokenDirectoryFeatureIndexArgs) =>
      ['Admin', 'setTokenDirectoryFeatureIndex', req] as const,
    addContractToTokenDirectory: (req: AddContractToTokenDirectoryArgs) =>
      ['Admin', 'addContractToTokenDirectory', req] as const,
    removeContractFromTokenDirectory: (req: RemoveContractFromTokenDirectoryArgs) =>
      ['Admin', 'removeContractFromTokenDirectory', req] as const,
    refreshTokenDirectory: () => ['Admin', 'refreshTokenDirectory'] as const,
  }

  refreshContractInfoUpdatedBefore = (
    req: RefreshContractInfoUpdatedBeforeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshContractInfoUpdatedBeforeReturn> => {
    return this.fetch(
      this.url('RefreshContractInfoUpdatedBefore'),
      createHttpRequest(JsonEncode(req, 'RefreshContractInfoUpdatedBeforeArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RefreshContractInfoUpdatedBeforeReturn>(_data, 'RefreshContractInfoUpdatedBeforeReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  refreshTokenMetadataUpdatedBefore = (
    req: RefreshTokenMetadataUpdatedBeforeArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RefreshTokenMetadataUpdatedBeforeReturn> => {
    return this.fetch(
      this.url('RefreshTokenMetadataUpdatedBefore'),
      createHttpRequest(JsonEncode(req, 'RefreshTokenMetadataUpdatedBeforeArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RefreshTokenMetadataUpdatedBeforeReturn>(_data, 'RefreshTokenMetadataUpdatedBeforeReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getContractInfoOverride = (
    req: GetContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractInfoOverrideReturn> => {
    return this.fetch(
      this.url('GetContractInfoOverride'),
      createHttpRequest(JsonEncode(req, 'GetContractInfoOverrideArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetContractInfoOverrideReturn>(_data, 'GetContractInfoOverrideReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  getContractInfoOverrides = (
    req: GetContractInfoOverridesArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<GetContractInfoOverridesReturn> => {
    return this.fetch(
      this.url('GetContractInfoOverrides'),
      createHttpRequest(JsonEncode(req, 'GetContractInfoOverridesArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<GetContractInfoOverridesReturn>(_data, 'GetContractInfoOverridesReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  addContractInfoOverride = (
    req: AddContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddContractInfoOverrideReturn> => {
    return this.fetch(
      this.url('AddContractInfoOverride'),
      createHttpRequest(JsonEncode(req, 'AddContractInfoOverrideArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<AddContractInfoOverrideReturn>(_data, 'AddContractInfoOverrideReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  updateContractInfoOverride = (
    req: UpdateContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<UpdateContractInfoOverrideReturn> => {
    return this.fetch(
      this.url('UpdateContractInfoOverride'),
      createHttpRequest(JsonEncode(req, 'UpdateContractInfoOverrideArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<UpdateContractInfoOverrideReturn>(_data, 'UpdateContractInfoOverrideReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  removeContractInfoOverride = (
    req: RemoveContractInfoOverrideArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveContractInfoOverrideReturn> => {
    return this.fetch(
      this.url('RemoveContractInfoOverride'),
      createHttpRequest(JsonEncode(req, 'RemoveContractInfoOverrideArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RemoveContractInfoOverrideReturn>(_data, 'RemoveContractInfoOverrideReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  isInTokenDirectory = (
    req: IsInTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<IsInTokenDirectoryReturn> => {
    return this.fetch(
      this.url('IsInTokenDirectory'),
      createHttpRequest(JsonEncode(req, 'IsInTokenDirectoryArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<IsInTokenDirectoryReturn>(_data, 'IsInTokenDirectoryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  setTokenDirectoryFeatureIndex = (
    req: SetTokenDirectoryFeatureIndexArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<SetTokenDirectoryFeatureIndexReturn> => {
    return this.fetch(
      this.url('SetTokenDirectoryFeatureIndex'),
      createHttpRequest(JsonEncode(req, 'SetTokenDirectoryFeatureIndexArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<SetTokenDirectoryFeatureIndexReturn>(_data, 'SetTokenDirectoryFeatureIndexReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  addContractToTokenDirectory = (
    req: AddContractToTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<AddContractToTokenDirectoryReturn> => {
    return this.fetch(
      this.url('AddContractToTokenDirectory'),
      createHttpRequest(JsonEncode(req, 'AddContractToTokenDirectoryArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<AddContractToTokenDirectoryReturn>(_data, 'AddContractToTokenDirectoryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  removeContractFromTokenDirectory = (
    req: RemoveContractFromTokenDirectoryArgs,
    headers?: object,
    signal?: AbortSignal,
  ): Promise<RemoveContractFromTokenDirectoryReturn> => {
    return this.fetch(
      this.url('RemoveContractFromTokenDirectory'),
      createHttpRequest(JsonEncode(req, 'RemoveContractFromTokenDirectoryArgs'), headers, signal),
    ).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RemoveContractFromTokenDirectoryReturn>(_data, 'RemoveContractFromTokenDirectoryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }

  refreshTokenDirectory = (headers?: object, signal?: AbortSignal): Promise<RefreshTokenDirectoryReturn> => {
    return this.fetch(this.url('RefreshTokenDirectory'), createHttpRequest('{}', headers, signal)).then(
      (res) => {
        return buildResponse(res).then((_data) => {
          return JsonDecode<RefreshTokenDirectoryReturn>(_data, 'RefreshTokenDirectoryReturn')
        })
      },
      (error) => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error instanceof Error ? error.message : String(error)}`,
        })
      },
    )
  }
}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = {
    ...headers,
    'Content-Type': 'application/json',
    [WebrpcHeader]: WebrpcHeaderValue,
  }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then((text) => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`,
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>

export const JsonEncode = <T = any>(obj: T, _typ: string = ''): string => {
  return JSON.stringify(obj)
}

export const JsonDecode = <T = any>(data: string | any, _typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try {
      parsed = JSON.parse(data)
    } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return parsed as T
}

//
// Errors
//

type WebrpcErrorParams = { name?: string; code?: number; message?: string; status?: number; cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}

export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class FailError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Fail'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request Failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, FailError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class TaskFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'TaskFailed'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Task failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TaskFailedError.prototype)
  }
}

export class DeprecatedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Deprecated'
    this.code = typeof error.code === 'number' ? error.code : 1008
    this.message = error.message || `RPC method is deprecated`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, DeprecatedError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 2000
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidArgument'
    this.code = typeof error.code === 'number' ? error.code : 2001
    this.message = error.message || `Invalid argument`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class RequiredArgumentError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequiredArgument'
    this.code = typeof error.code === 'number' ? error.code : 2002
    this.message = error.message || `Required argument missing`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequiredArgumentError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QueryFailed'
    this.code = typeof error.code === 'number' ? error.code : 2003
    this.message = error.message || `Query failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class ValidationFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ValidationFailed'
    this.code = typeof error.code === 'number' ? error.code : 2004
    this.message = error.message || `Validation failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ValidationFailedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 2005
    this.message = error.message || `Rate limited`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotFound'
    this.code = typeof error.code === 'number' ? error.code : 3000
    this.message = error.message || `Resource not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 3002
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class ChainNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ChainNotFound'
    this.code = typeof error.code === 'number' ? error.code : 3003
    this.message = error.message || `Chain not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ChainNotFoundError.prototype)
  }
}

export class TokenDirectoryDisabledError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'TokenDirectoryDisabled'
    this.code = typeof error.code === 'number' ? error.code : 4001
    this.message = error.message || `Token Directory is disabled`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TokenDirectoryDisabledError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Fail = 'Fail',
  Geoblocked = 'Geoblocked',
  TaskFailed = 'TaskFailed',
  Deprecated = 'Deprecated',
  Timeout = 'Timeout',
  InvalidArgument = 'InvalidArgument',
  RequiredArgument = 'RequiredArgument',
  QueryFailed = 'QueryFailed',
  ValidationFailed = 'ValidationFailed',
  RateLimited = 'RateLimited',
  NotFound = 'NotFound',
  ProjectNotFound = 'ProjectNotFound',
  ChainNotFound = 'ChainNotFound',
  TokenDirectoryDisabled = 'TokenDirectoryDisabled',
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Fail = 1005,
  Geoblocked = 1006,
  TaskFailed = 1007,
  Deprecated = 1008,
  Timeout = 2000,
  InvalidArgument = 2001,
  RequiredArgument = 2002,
  QueryFailed = 2003,
  ValidationFailed = 2004,
  RateLimited = 2005,
  NotFound = 3000,
  ProjectNotFound = 3002,
  ChainNotFound = 3003,
  TokenDirectoryDisabled = 4001,
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: FailError,
  [1006]: GeoblockedError,
  [1007]: TaskFailedError,
  [1008]: DeprecatedError,
  [2000]: TimeoutError,
  [2001]: InvalidArgumentError,
  [2002]: RequiredArgumentError,
  [2003]: QueryFailedError,
  [2004]: ValidationFailedError,
  [2005]: RateLimitedError,
  [3000]: NotFoundError,
  [3002]: ProjectNotFoundError,
  [3003]: ChainNotFoundError,
  [4001]: TokenDirectoryDisabledError,
}

//
// Webrpc
//

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.31.0;gen-typescript@v0.22.5;sequence-metadata@v0.4.0'

type WebrpcGenVersions = {
  WebrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: '',
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: '',
    }
  }

  const [_, WebrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? '',
  }
}
