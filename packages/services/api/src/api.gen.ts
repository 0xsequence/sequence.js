/* eslint-disable */
// sequence-api v0.4.0 3c15fa79614e43a5321cd2ac0c080e80af291bd1
// --
// Code generated by Webrpc-gen@v0.31.0 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=typescript -client -out=./clients/api.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = 'v1'

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = '3c15fa79614e43a5321cd2ac0c080e80af291bd1'

//
// Client interface
//

export interface APIClient {
  /**
   *
   * Runtime
   *
   */
  ping(headers?: object, signal?: AbortSignal): Promise<PingResponse>

  version(headers?: object, signal?: AbortSignal): Promise<VersionResponse>

  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse>

  clock(headers?: object, signal?: AbortSignal): Promise<ClockResponse>

  getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextResponse>

  /**
   *
   * Auth
   *
   * TODO: rename 'ewtString' arg to 'ethauthProof'
   */
  getAuthToken(req: GetAuthTokenRequest, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenResponse>

  getAuthToken2(req: GetAuthToken2Request, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Response>

  sendPasswordlessLink(
    req: SendPasswordlessLinkRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SendPasswordlessLinkResponse>

  registerPublicKey(req: RegisterPublicKeyRequest, headers?: object, signal?: AbortSignal): Promise<RegisterPublicKeyResponse>

  getPublicKey(req: GetPublicKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetPublicKeyResponse>

  /**
   *
   * Contacts / Friends
   *
   */
  friendList(req: FriendListRequest, headers?: object, signal?: AbortSignal): Promise<FriendListResponse>

  getFriendByAddress(req: GetFriendByAddressRequest, headers?: object, signal?: AbortSignal): Promise<GetFriendByAddressResponse>

  searchFriends(req: SearchFriendsRequest, headers?: object, signal?: AbortSignal): Promise<SearchFriendsResponse>

  addFriend(req: AddFriendRequest, headers?: object, signal?: AbortSignal): Promise<AddFriendResponse>

  updateFriendNickname(
    req: UpdateFriendNicknameRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateFriendNicknameResponse>

  removeFriend(req: RemoveFriendRequest, headers?: object, signal?: AbortSignal): Promise<RemoveFriendResponse>

  /**
   *
   * Chain-Utils
   *
   */
  contractCall(req: ContractCallRequest, headers?: object, signal?: AbortSignal): Promise<ContractCallResponse>

  decodeContractCall(req: DecodeContractCallRequest, headers?: object, signal?: AbortSignal): Promise<DecodeContractCallResponse>

  lookupContractCallSelectors(
    req: LookupContractCallSelectorsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<LookupContractCallSelectorsResponse>

  /**
   *
   * User Storage
   *
   */
  userStorageFetch(req: UserStorageFetchRequest, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchResponse>

  userStorageSave(req: UserStorageSaveRequest, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveResponse>

  userStorageDelete(req: UserStorageDeleteRequest, headers?: object, signal?: AbortSignal): Promise<UserStorageDeleteResponse>

  userStorageFetchAll(
    req: UserStorageFetchAllRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UserStorageFetchAllResponse>

  /**
   *
   * Wallet utils
   *
   */
  getMoonpayLink(req: GetMoonpayLinkRequest, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkResponse>

  /**
   * - IsUsingGoogleMail(domain: string) => (yes: bool)
   */
  resolveENSAddress(req: ResolveENSAddressRequest, headers?: object, signal?: AbortSignal): Promise<ResolveENSAddressResponse>

  /**
   * TODO: we can add walletContext optional in the future when we need it
   * NOTE: chainId can be either a number or canonical name
   */
  isValidSignature(req: IsValidSignatureRequest, headers?: object, signal?: AbortSignal): Promise<IsValidSignatureResponse>

  isValidMessageSignature(
    req: IsValidMessageSignatureRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidMessageSignatureResponse>

  isValidTypedDataSignature(
    req: IsValidTypedDataSignatureRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidTypedDataSignatureResponse>

  isValidETHAuthProof(
    req: IsValidETHAuthProofRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidETHAuthProofResponse>

  getOnRampURL(req: GetOnRampURLRequest, headers?: object, signal?: AbortSignal): Promise<GetOnRampURLResponse>

  transakGetCountries(headers?: object, signal?: AbortSignal): Promise<TransakGetCountriesResponse>

  transakGetCryptoCurrencies(headers?: object, signal?: AbortSignal): Promise<TransakGetCryptoCurrenciesResponse>

  transakGetFiatCurrencies(headers?: object, signal?: AbortSignal): Promise<TransakGetFiatCurrenciesResponse>

  transakGetPrice(req: TransakGetPriceRequest, headers?: object, signal?: AbortSignal): Promise<TransakGetPriceResponse>

  transakGetSupportedNFTCheckoutChains(
    headers?: object,
    signal?: AbortSignal
  ): Promise<TransakGetSupportedNFTCheckoutChainsResponse>

  transakGetWidgetURL(
    req: TransakGetWidgetURLRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TransakGetWidgetURLResponse>

  /**
   *
   * Price Feed
   *
   */
  getCoinPrices(req: GetCoinPricesRequest, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesResponse>

  getCollectiblePrices(
    req: GetCollectiblePricesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectiblePricesResponse>

  /**
   *
   * Price Feed utils
   *
   */
  getExchangeRate(req: GetExchangeRateRequest, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateResponse>

  /**
   *
   * Util / misc
   *
   */
  memoryStore(req: MemoryStoreRequest, headers?: object, signal?: AbortSignal): Promise<MemoryStoreResponse>

  memoryLoad(req: MemoryLoadRequest, headers?: object, signal?: AbortSignal): Promise<MemoryLoadResponse>

  /**
   *
   * Legacy
   *
   */
  getInviteInfo(headers?: object, signal?: AbortSignal): Promise<GetInviteInfoResponse>

  /**
   * NOTE: we're still using this from SW-API to Sequence-API to claim invite code
   */
  isValidAccessCode(req: IsValidAccessCodeRequest, headers?: object, signal?: AbortSignal): Promise<IsValidAccessCodeResponse>

  internalClaimAccessCode(
    req: InternalClaimAccessCodeRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<InternalClaimAccessCodeResponse>

  /**
   * Utils
   */
  blockNumberAtTime(req: BlockNumberAtTimeRequest, headers?: object, signal?: AbortSignal): Promise<BlockNumberAtTimeResponse>

  /**
   *
   * Paper
   * TODO: deprecate in the future
   *
   */
  paperSessionSecret(req: PaperSessionSecretRequest, headers?: object, signal?: AbortSignal): Promise<PaperSessionSecretResponse>

  paperSessionSecret2(
    req: PaperSessionSecret2Request,
    headers?: object,
    signal?: AbortSignal
  ): Promise<PaperSessionSecret2Response>

  /**
   *
   * Linked wallets (v0 -- simple support)
   *
   */
  linkWallet(req: LinkWalletRequest, headers?: object, signal?: AbortSignal): Promise<LinkWalletResponse>

  getLinkedWallets(req: GetLinkedWalletsRequest, headers?: object, signal?: AbortSignal): Promise<GetLinkedWalletsResponse>

  removeLinkedWallet(req: RemoveLinkedWalletRequest, headers?: object, signal?: AbortSignal): Promise<RemoveLinkedWalletResponse>

  /**
   * NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
   * to be clear, they are not necessary for our linked wallets.
   */
  generateWaaSVerificationURL(
    req: GenerateWaaSVerificationURLRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateWaaSVerificationURLResponse>

  validateWaaSVerificationNonce(
    req: ValidateWaaSVerificationNonceRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ValidateWaaSVerificationNonceResponse>

  /**
   *
   *
   * WaaS child wallet adoption
   *
   */
  listAdoptedWallets(req: ListAdoptedWalletsRequest, headers?: object, signal?: AbortSignal): Promise<ListAdoptedWalletsResponse>

  getLifiChains(headers?: object, signal?: AbortSignal): Promise<GetLifiChainsResponse>

  getLifiTokens(req: GetLifiTokensRequest, headers?: object, signal?: AbortSignal): Promise<GetLifiTokensResponse>

  /**
   * All parameters except `params` are deprecated.
   * Use only the `params` object to pass values.
   */
  getLifiSwapRoutes(req: GetLifiSwapRoutesRequest, headers?: object, signal?: AbortSignal): Promise<GetLifiSwapRoutesResponse>

  getLifiSwapQuote(req: GetLifiSwapQuoteRequest, headers?: object, signal?: AbortSignal): Promise<GetLifiSwapQuoteResponse>

  /**
   *
   * Inventory, payments and management
   *
   */
  listCurrencyGroups(headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsResponse>

  addOffchainInventory(
    req: AddOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddOffchainInventoryResponse>

  getOffchainInventory(
    req: GetOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetOffchainInventoryResponse>

  listOffchainInventories(
    req: ListOffchainInventoriesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainInventoriesResponse>

  updateOffchainInventory(
    req: UpdateOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateOffchainInventoryResponse>

  deleteOffchainInventory(
    req: DeleteOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteOffchainInventoryResponse>

  requestOffchainPayment(
    req: RequestOffchainPaymentRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RequestOffchainPaymentResponse>

  listOffchainPayments(
    req: ListOffchainPaymentsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainPaymentsResponse>

  /**
   *
   * Packs
   *
   */
  savePack(req: SavePackRequest, headers?: object, signal?: AbortSignal): Promise<SavePackResponse>

  getPack(req: GetPackRequest, headers?: object, signal?: AbortSignal): Promise<GetPackResponse>

  getPackIds(req: GetPackIdsRequest, headers?: object, signal?: AbortSignal): Promise<GetPackIdsResponse>

  deletePack(req: DeletePackRequest, headers?: object, signal?: AbortSignal): Promise<DeletePackResponse>

  updatePackContent(req: UpdatePackContentRequest, headers?: object, signal?: AbortSignal): Promise<UpdatePackContentResponse>

  getRevealTxData(req: GetRevealTxDataRequest, headers?: object, signal?: AbortSignal): Promise<GetRevealTxDataResponse>

  checkoutOptionsPrimary(
    req: CheckoutOptionsPrimaryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsPrimaryResponse>

  checkoutOptionsSecondary(
    req: CheckoutOptionsSecondaryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsSecondaryResponse>

  checkoutOptionsGetTransakContractID(
    req: CheckoutOptionsGetTransakContractIDRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsGetTransakContractIDResponse>

  fortePayCreateIntent(
    req: FortePayCreateIntentRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FortePayCreateIntentResponse>

  fortePayGetPaymentStatuses(
    req: FortePayGetPaymentStatusesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FortePayGetPaymentStatusesResponse>
}

//
// Schema types
//

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export enum GetLifiSwapRouteDirection {
  to = 'to',
  from = 'from'
}

export enum TokenType {
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155'
}

export enum TransakBuySell {
  UNKNOWN = 'UNKNOWN',
  BUY = 'BUY',
  SELL = 'SELL'
}

export enum TradeType {
  EXACT_INPUT = 'EXACT_INPUT',
  EXACT_OUTPUT = 'EXACT_OUTPUT'
}

export enum CheckoutOptionCrypto {
  none = 'none',
  partially = 'partially',
  all = 'all'
}

export enum CheckoutOptionNFTCheckoutProvider {
  unknown = 'unknown',
  transak = 'transak'
}

export enum CheckoutOptionOnRampProvider {
  unknown = 'unknown',
  transak = 'transak'
}

export enum CheckoutOptionSwapProvider {
  unknown = 'unknown',
  lifi = 'lifi'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  checks: RuntimeChecks
  numTxnsRelayed: { [key: string]: NumTxnsRelayed }
}

export interface NumTxnsRelayed {
  chainID: number
  prev: number
  current: number
  period: number
}

export interface RuntimeChecks {}

export interface SequenceContext {
  factory: string
  mainModule: string
  mainModuleUpgradable: string
  guestModule: string
  utils: string
}

export interface PublicKey {
  id: string
  x: string
  y: string
}

export interface User {
  address: string
  username: string
  avatar: string
  bio: string
  location: string
  locale: string
  backup?: boolean
  backupConfirmed?: boolean
  maxInvites?: number
  updatedAt?: string
  createdAt?: string
}

export interface WalletBackup {
  accountAddress: string
  secretHash: string
  encryptedWallet: string
  userConfirmed: boolean
  updatedAt?: string
  createdAt?: string
}

export interface Friend {
  id: number
  userAddress: string
  friendAddress: string
  nickname: string
  user?: User
  createdAt?: string
}

export interface MetaTxn {
  id: string
  chainId: string
  walletAddress: string
  contract: string
  input: string
}

export interface MetaTxnReceipt {
  metaTxID: string
  status: string
  txnReceipt?: string
  revertReason?: string
}

export interface InviteCode {
  usesLeft: number
  ownerAccount: string
  email?: string
  url: string
  createdAt?: string
  expiresAt?: string
}

export interface InviteCodeAccount {
  claimedByUserAddress: string
  claimedAt?: string
}

export interface InviteInfo {
  expiryInHours: number
  max: number
  invites: Array<InviteCode>
}

export interface ContractCall {
  signature: string
  function: string
  args: Array<TupleComponent>
}

export interface TupleComponent {
  name?: string
  type: string
  value: any
}

export interface UserStorage {
  userAddress: string
  key: string
  value: any
}

export interface Token {
  chainId: number
  contractAddress: string
  tokenId?: string
}

export interface Price {
  value: number
  currency: string
}

export interface TokenPrice {
  token: Token
  price?: Price
  price24hChange?: Price
  price24hVol?: Price
  floorPrice: Price
  buyPrice: Price
  sellPrice: Price
  updatedAt: string
}

export interface ExchangeRate {
  name: string
  symbol: string
  value: number
  vsCurrency: string
  currencyType: string
}

export interface LinkedWallet {
  id: number
  walletType?: string
  walletAddress: string
  linkedWalletAddress: string
  createdAt?: string
}

export interface Page {
  pageSize?: number
  page?: number
  totalRecords?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
  more?: boolean
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface LifiToken {
  chainId: number
  address: string
  symbol: string
  name: string
  decimals: number
  priceUsd: number
  price?: string
  coinKey: string
  logoUri: string
}

export interface GetLifiSwapRouteParams {
  direction: GetLifiSwapRouteDirection
  chainId: number
  walletAddress: string
  tokenAddress: string
  tokenAmount: string
}

export interface LifiSwapRoute {
  fromChainId: number
  toChainId: number
  fromTokens: Array<LifiToken>
  toTokens: Array<LifiToken>
}

export interface GetLifiSwapQuoteParams {
  chainId: number
  walletAddress: string
  fromTokenAddress: string
  toTokenAddress: string
  fromTokenAmount?: string
  toTokenAmount?: string
  includeApprove: boolean
  slippageBps: number
}

export interface LifiSwapQuote {
  currencyAddress: string
  currencyBalance: string
  price: string
  maxPrice: string
  to: string
  transactionData: string
  transactionValue: string
  approveData: string
  amount: string
  amountMin: string
}

export interface CurrencyGroup {
  name: string
  tokens: Array<CurrencyGroupToken>
}

export interface CurrencyGroupToken {
  chainId: number
  tokenAddress: string
}

export interface OffchainInventory {
  id: number
  projectId: number
  chainId: number
  externalProductId: string
  paymentTokenAddress: string
  paymentTokenType: TokenType
  paymentTokenId: number
  paymentAmount: number
  paymentRecipient: string
  chainedCallAddress?: string
  chainedCallData?: string
  allowCrossChainPayments?: boolean
  callbackURL?: string
  createdAt: string
  deletedAt?: string
}

export interface OffchainPayment {
  id: number
  offchainInventoryId: number
  productRecipient: string
  paymentChainId: number
  paymentTokenAddress: string
  expiration: string
  createdAt: string
  completedAt?: string
  processedAt?: string
}

export interface PaymentResponse {
  paymentId: number
  offchainInventoryId: number
  chainId: number
  externalProductId: string
  paymentTokenAddress: string
  paymentTokenType: TokenType
  paymentTokenId: number
  paymentTotal: number
  expiration: string
  signature: string
  txTo: string
  txData: string
}

export interface AdoptedChildWallet {
  address: string
}

export interface Pack {
  id: number
  chainId: number
  projectId: number
  contractAddress: string
  packId: string
  content: Array<PackContent>
  createdAt?: string
}

export interface PackContent {
  tokenAddresses: Array<string>
  isERC721: Array<boolean>
  tokenIds: Array<Array<string>>
  amounts: Array<Array<string>>
}

export interface TransakCountry {
  alpha2: string
  alpha3: string
  isAllowed: boolean
  isLightKycAllowed: boolean
  name: string
  currencyCode: string
  supportedDocuments: Array<string>
  partners: Array<TransakPartner>
  states: Array<TransakState>
}

export interface TransakPartner {
  name: string
  isCardPayment: boolean
  currencyCode: string
}

export interface TransakState {
  code: string
  name: string
  isAllowed: boolean
}

export interface TransakCryptoCurrency {
  id: string
  coinID: string
  address: string
  addressAdditionalData: any
  createdAt: string
  decimals: number
  image: TransakCryptoCurrencyImage
  isAllowed: boolean
  isPopular: boolean
  isStable: boolean
  name: string
  roundOff: number
  symbol: string
  isIgnorePriceVerification: boolean
  imageBk: TransakCryptoCurrencyImage
  kycCountriesNotSupported: Array<string>
  network: TransakCryptoCurrencyNetwork
  uniqueID: string
  tokenType: string
  tokenIdentifier: string
  isPayInAllowed: boolean
  isSuspended: boolean
}

export interface TransakCryptoCurrencyImage {
  large: string
  small: string
  thumb: string
}

export interface TransakCryptoCurrencyNetwork {
  name: string
  fiatCurrenciesNotSupported: Array<any>
  chainID: string
}

export interface TransakCryptoCurrencyNetworkFiatNotSupported {
  fiatCurrency: string
  paymentMethod: string
}

export interface TransakFiatCurrency {
  symbol: string
  supportingCountries: Array<string>
  logoSymbol: string
  name: string
  paymentOptions: Array<TransakFiatCurrencyPaymentOption>
  isPopular: boolean
  isAllowed: boolean
  roundOff: number
  isPayOutAllowed: boolean
  defaultCountryForNFT: string
  icon: string
  displayMessage: string
}

export interface TransakFiatCurrencyPaymentOption {
  name: string
  id: string
  isNftAllowed: boolean
  isNonCustodial: boolean
  processingTime: string
  displayText: boolean
  icon: string
  limitCurrency: string
  isActive: boolean
  provider: string
  maxAmount: number
  minAmount: number
  defaultAmount: number
  isConverted: boolean
  visaPayoutCountries: Array<string>
  mastercardPayoutCountries: Array<string>
  isPayOutAllowed: boolean
  minAmountForPayOut: number
  maxAmountForPayOut: number
  defaultAmountForPayOut: number
}

export interface TransakPrice {
  quoteID: string
  conversionPrice: number
  marketConversionPrice: number
  slippage: number
  fiatCurrency: string
  cryptoCurrency: string
  paymentMethod: string
  fiatAmount: number
  cryptoAmount: number
  isBuyOrSell: string
  network: string
  feeDecimal: number
  totalFee: number
  feeBreakdown: Array<TransakPriceFeeBreakdown>
  nonce: number
  cryptoLiquidityProvider: string
  notes: Array<any>
}

export interface TransakPriceFeeBreakdown {
  Name: string
  Value: number
  ID: string
  Ids: Array<string>
}

export interface TransakGetPriceParams {
  fiatCurrency: string
  cryptoCurrency: string
  isBuyOrSell: TransakBuySell
  network: string
  paymentMethod: string
  fiatAmount: number
  cryptoAmount: number
  quoteCountryCode: string
}

export interface TransakNFTData {
  imageUrl: string
  nftName: string
  collectionAddress: string
  tokenIds: Array<string>
  prices: Array<number>
  quantity: number
  nftType: string
}

export interface TransakGetWidgetURLParams {
  targetContractAddress?: string
  isNft?: boolean
  calldata?: string
  cryptoCurrencyCode?: string
  estimatedGasLimit?: number
  nftData: Array<TransakNFTData>
  walletAddress?: string
  disableWalletAddressForm?: boolean
  partnerOrderId?: string
  network?: string
  referrerDomain?: string
  fiatAmount?: string
  fiatCurrency?: string
  defaultFiatAmount?: string
  defaultCryptoCurrency?: string
  cryptoCurrencyList?: string
  networks?: string
}

export interface TransakChain {
  name: string
  chainId: number
}

export interface CheckoutOptionsPrimaryParams {
  quantity: string
  tokenId: string
}

export interface CheckoutOptionsSecondaryParams {
  collectionAddress: string
  marketplaceAddress: string
  currencyAddress: string
  priceAmount: string
  tokenId: string
}

export interface CheckoutOptions {
  crypto: CheckoutOptionCrypto
  swap: Array<CheckoutOptionSwapProvider>
  nftCheckout: Array<CheckoutOptionNFTCheckoutProvider>
  onRamp: Array<CheckoutOptionOnRampProvider>
}

export interface FortePayCreateIntent {
  blockchain: string
  buyer: FortePayBuyer
  currency: string
  idempotencyKey: string
  items: Array<FortePayItem>
  seller: FortePaySeller
  transactionType: string
}

export interface FortePayBuyer {
  wallet: FortePayWallet
  email: string
  id: string
}

export interface FortePaySeller {
  wallet: FortePayWallet
}

export interface FortePayWallet {
  address: string
  blockchain: string
}

export interface FortePayItem {
  amount: string
  id: string
  imageUrl: string
  listingData: FortePayItemListingData
  nftData: FortePayItemNFTData
  mintData: FortePayItemMintData
  title: string
}

export interface FortePayItemListingData {
  orderHash: string
  protocol: string
  protocolAddress: string
  auctionHouse: string
  tokenAddress: string
  calldata: string
  payToAddress: string
  structuredCalldata: any
}

export interface FortePayItemNFTData {
  contractAddress: string
  tokenId: string
}

export interface FortePayItemMintData {
  nonce: string
  protocol: string
  protocolAddress: string
  signature: string
  tokenIds: Array<string>
  calldata: string
  payToAddress: string
  tokenContractAddress: string
  structuredCalldata: any
}

export interface FortePayIntent {
  flow: string
  widgetData: string
  paymentIntentId: string
  notes: Array<string>
}

export interface FortePaymentStatus {
  paymentIntentId: string
  status: string
}

export interface CrossChainFee {
  providerFee: string
  trailsSwapFee: string
  providerFeeUSD: number
  trailsSwapFeeUSD: number
  totalFeeAmount: string
  totalFeeUSD: number
}

export interface MetaTxnFeeDetail {
  metaTxnID: string
  estimatedGasLimit: string
  feeNative: string
}

export interface ChainExecuteQuote {
  chainId: string
  totalGasLimit: string
  gasPrice: string
  totalFeeAmount: string
  nativeTokenSymbol: string
  nativeTokenPrice?: string
  metaTxnFeeDetails: Array<MetaTxnFeeDetail>
  totalFeeUSD?: string
}

export interface ExecuteQuote {
  chainQuotes: Array<ChainExecuteQuote>
}

export interface PingRequest {}

export interface PingResponse {
  status: boolean
}

export interface VersionRequest {}

export interface VersionResponse {
  version: Version
}

export interface RuntimeStatusRequest {}

export interface RuntimeStatusResponse {
  status: RuntimeStatus
}

export interface ClockRequest {}

export interface ClockResponse {
  serverTime: string
}

export interface GetSequenceContextRequest {}

export interface GetSequenceContextResponse {
  data: SequenceContext
}

export interface GetAuthTokenRequest {
  ewtString: string
  testnetMode?: boolean
}

export interface GetAuthTokenResponse {
  status: boolean
  jwtToken: string
  address: string
  user?: User
}

export interface GetAuthToken2Request {
  ewtString: string
  chainID: string
}

export interface GetAuthToken2Response {
  status: boolean
  jwtToken: string
  address: string
  user?: User
}

export interface SendPasswordlessLinkRequest {
  email: string
  redirectUri: string
  intent: string
}

export interface SendPasswordlessLinkResponse {
  status: boolean
}

export interface RegisterPublicKeyRequest {
  publicKey: PublicKey
}

export interface RegisterPublicKeyResponse {
  status: boolean
}

export interface GetPublicKeyRequest {
  id: string
}

export interface GetPublicKeyResponse {
  publicKey: PublicKey
}

export interface FriendListRequest {
  nickname?: string
  page?: Page
}

export interface FriendListResponse {
  page: Page
  friends: Array<Friend>
}

export interface GetFriendByAddressRequest {
  friendAddress: string
}

export interface GetFriendByAddressResponse {
  status: boolean
  friend: Friend
}

export interface SearchFriendsRequest {
  filterUsername: string
  page?: Page
}

export interface SearchFriendsResponse {
  friends: Array<Friend>
}

export interface AddFriendRequest {
  friendAddress: string
  optionalNickname?: string
}

export interface AddFriendResponse {
  status: boolean
  friend?: Friend
}

export interface UpdateFriendNicknameRequest {
  friendAddress: string
  nickname: string
}

export interface UpdateFriendNicknameResponse {
  status: boolean
  friend?: Friend
}

export interface RemoveFriendRequest {
  friendAddress: string
}

export interface RemoveFriendResponse {
  status: boolean
}

export interface ContractCallRequest {
  chainID: string
  contract: string
  inputExpr: string
  outputExpr: string
  args: Array<string>
}

export interface ContractCallResponse {
  returns: Array<string>
}

export interface DecodeContractCallRequest {
  callData: string
}

export interface DecodeContractCallResponse {
  call: ContractCall
}

export interface LookupContractCallSelectorsRequest {
  selectors: Array<string>
}

export interface LookupContractCallSelectorsResponse {
  signatures: Array<Array<string>>
}

export interface UserStorageFetchRequest {
  key: string
}

export interface UserStorageFetchResponse {
  object: any
}

export interface UserStorageSaveRequest {
  key: string
  object: any
}

export interface UserStorageSaveResponse {
  ok: boolean
}

export interface UserStorageDeleteRequest {
  key: string
}

export interface UserStorageDeleteResponse {
  ok: boolean
}

export interface UserStorageFetchAllRequest {
  keys?: Array<string>
}

export interface UserStorageFetchAllResponse {
  objects: { [key: string]: any }
}

export interface GetMoonpayLinkRequest {
  url: string
}

export interface GetMoonpayLinkResponse {
  signedUrl: string
}

export interface ResolveENSAddressRequest {
  ens: string
}

export interface ResolveENSAddressResponse {
  address: string
  ok: boolean
}

export interface IsValidSignatureRequest {
  chainId: string
  walletAddress: string
  digest: string
  signature: string
}

export interface IsValidSignatureResponse {
  isValid: boolean
}

export interface IsValidMessageSignatureRequest {
  chainId: string
  walletAddress: string
  message: string
  signature: string
}

export interface IsValidMessageSignatureResponse {
  isValid: boolean
}

export interface IsValidTypedDataSignatureRequest {
  chainId: string
  walletAddress: string
  typedData: any
  signature: string
}

export interface IsValidTypedDataSignatureResponse {
  isValid: boolean
}

export interface IsValidETHAuthProofRequest {
  chainId: string
  walletAddress: string
  ethAuthProofString: string
}

export interface IsValidETHAuthProofResponse {
  isValid: boolean
}

export interface GetOnRampURLRequest {
  chainId: string
}

export interface GetOnRampURLResponse {
  url: string
}

export interface TransakGetCountriesRequest {}

export interface TransakGetCountriesResponse {
  regions: Array<TransakCountry>
}

export interface TransakGetCryptoCurrenciesRequest {}

export interface TransakGetCryptoCurrenciesResponse {
  currencies: Array<TransakCryptoCurrency>
}

export interface TransakGetFiatCurrenciesRequest {}

export interface TransakGetFiatCurrenciesResponse {
  currencies: Array<TransakFiatCurrency>
}

export interface TransakGetPriceRequest {
  params: TransakGetPriceParams
}

export interface TransakGetPriceResponse {
  price: TransakPrice
}

export interface TransakGetSupportedNFTCheckoutChainsRequest {}

export interface TransakGetSupportedNFTCheckoutChainsResponse {
  chains: Array<TransakChain>
}

export interface TransakGetWidgetURLRequest {
  params: TransakGetWidgetURLParams
}

export interface TransakGetWidgetURLResponse {
  url: string
}

export interface GetCoinPricesRequest {
  tokens: Array<Token>
}

export interface GetCoinPricesResponse {
  tokenPrices: Array<TokenPrice>
}

export interface GetCollectiblePricesRequest {
  tokens: Array<Token>
}

export interface GetCollectiblePricesResponse {
  tokenPrices: Array<TokenPrice>
}

export interface GetExchangeRateRequest {
  toCurrency: string
}

export interface GetExchangeRateResponse {
  exchangeRate: ExchangeRate
}

export interface MemoryStoreRequest {
  key: string
  value: string
}

export interface MemoryStoreResponse {
  ok: boolean
}

export interface MemoryLoadRequest {
  key: string
}

export interface MemoryLoadResponse {
  value: string
}

export interface GetInviteInfoRequest {}

export interface GetInviteInfoResponse {
  inviteInfo: InviteInfo
}

export interface IsValidAccessCodeRequest {
  accessCode: string
}

export interface IsValidAccessCodeResponse {
  status: boolean
}

export interface InternalClaimAccessCodeRequest {
  address: string
  accessCode: string
}

export interface InternalClaimAccessCodeResponse {
  status: boolean
}

export interface BlockNumberAtTimeRequest {
  chainId: number
  timestamps: Array<number>
}

export interface BlockNumberAtTimeResponse {
  blocks: Array<number>
}

export interface PaperSessionSecretRequest {
  chainName: string
  contractAddress: string
  paramsJson: string
  contractType: string
}

export interface PaperSessionSecretResponse {
  secret: string
}

export interface PaperSessionSecret2Request {
  chainName: string
  contractAddress: string
  paramsJson: string
  abi: string
}

export interface PaperSessionSecret2Response {
  secret: string
}

export interface LinkWalletRequest {
  parentWalletAddress: string
  parentWalletMessage: string
  parentWalletSignature: string
  linkedWalletAddress: string
  linkedWalletMessage: string
  linkedWalletSignature: string
  signatureChainId: string
  linkedWalletType?: string
}

export interface LinkWalletResponse {
  status: boolean
}

export interface GetLinkedWalletsRequest {
  parentWalletAddress: string
  parentWalletMessage: string
  parentWalletSignature: string
  signatureChainId: string
}

export interface GetLinkedWalletsResponse {
  linkedWallets: Array<LinkedWallet>
}

export interface RemoveLinkedWalletRequest {
  parentWalletAddress: string
  parentWalletMessage: string
  parentWalletSignature: string
  linkedWalletAddress: string
  signatureChainId: string
}

export interface RemoveLinkedWalletResponse {
  status: boolean
}

export interface GenerateWaaSVerificationURLRequest {
  walletAddress: string
}

export interface GenerateWaaSVerificationURLResponse {
  nonce: string
  verificationURL: string
}

export interface ValidateWaaSVerificationNonceRequest {
  nonce: string
  signature: string
  sessionId: string
  chainId: string
}

export interface ValidateWaaSVerificationNonceResponse {
  walletAddress: string
}

export interface ListAdoptedWalletsRequest {
  page?: Page
}

export interface ListAdoptedWalletsResponse {
  page: Page
  wallets: Array<AdoptedChildWallet>
}

export interface GetLifiChainsRequest {}

export interface GetLifiChainsResponse {
  chains: Array<number>
}

export interface GetLifiTokensRequest {
  chainIds: Array<number>
}

export interface GetLifiTokensResponse {
  tokens: Array<Token>
}

export interface GetLifiSwapRoutesRequest {
  params: GetLifiSwapRouteParams
}

export interface GetLifiSwapRoutesResponse {
  routes: Array<LifiSwapRoute>
}

export interface GetLifiSwapQuoteRequest {
  params: GetLifiSwapQuoteParams
}

export interface GetLifiSwapQuoteResponse {
  quote: LifiSwapQuote
}

export interface ListCurrencyGroupsRequest {}

export interface ListCurrencyGroupsResponse {
  currencyGroups: Array<CurrencyGroup>
}

export interface AddOffchainInventoryRequest {
  inventory: OffchainInventory
}

export interface AddOffchainInventoryResponse {
  inventoryId: number
}

export interface GetOffchainInventoryRequest {
  inventoryId: number
}

export interface GetOffchainInventoryResponse {
  inventory: OffchainInventory
}

export interface ListOffchainInventoriesRequest {
  projectId: number
}

export interface ListOffchainInventoriesResponse {
  inventory: Array<OffchainInventory>
}

export interface UpdateOffchainInventoryRequest {
  inventory: OffchainInventory
}

export interface UpdateOffchainInventoryResponse {}

export interface DeleteOffchainInventoryRequest {
  inventoryId: number
}

export interface DeleteOffchainInventoryResponse {
  ok: boolean
}

export interface RequestOffchainPaymentRequest {
  inventoryId: number
  recipient: string
  chainId?: number
  tokenAddress?: string
}

export interface RequestOffchainPaymentResponse {
  payment: PaymentResponse
}

export interface ListOffchainPaymentsRequest {
  inventoryId: number
  page?: Page
}

export interface ListOffchainPaymentsResponse {
  page: Page
  payments: Array<OffchainPayment>
}

export interface SavePackRequest {
  pack: Pack
}

export interface SavePackResponse {
  merkleRoot: string
}

export interface GetPackRequest {
  contractAddress: string
  packId: string
  chainId: number
}

export interface GetPackResponse {
  pack: Pack
}

export interface GetPackIdsRequest {
  contractAddress: string
  chainId: number
}

export interface GetPackIdsResponse {
  packIds: Array<string>
}

export interface DeletePackRequest {
  contractAddress: string
  packId: string
  chainId: number
}

export interface DeletePackResponse {
  status: boolean
}

export interface UpdatePackContentRequest {
  pack: Pack
}

export interface UpdatePackContentResponse {
  merkleRoot: string
}

export interface GetRevealTxDataRequest {
  contractAddress: string
  packId: string
  chainId: number
  userAddress: string
}

export interface GetRevealTxDataResponse {
  txData: string
}

export interface CheckoutOptionsPrimaryRequest {
  chainId: number
  wallet: string
  contractAddress: string
  collectionAddress: string
  params: Array<CheckoutOptionsPrimaryParams>
}

export interface CheckoutOptionsPrimaryResponse {
  options: CheckoutOptions
}

export interface CheckoutOptionsSecondaryRequest {
  chainId: number
  wallet: string
  params: Array<CheckoutOptionsSecondaryParams>
}

export interface CheckoutOptionsSecondaryResponse {
  options: CheckoutOptions
}

export interface CheckoutOptionsGetTransakContractIDRequest {
  chainId: number
  contractAddress: string
}

export interface CheckoutOptionsGetTransakContractIDResponse {
  contractId: string
}

export interface FortePayCreateIntentRequest {
  intent: FortePayCreateIntent
}

export interface FortePayCreateIntentResponse {
  resp: FortePayIntent
}

export interface FortePayGetPaymentStatusesRequest {
  paymentIntentIds: Array<string>
}

export interface FortePayGetPaymentStatusesResponse {
  statuses: Array<FortePaymentStatus>
}

//
// Client
//

export class API implements APIClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/API/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  queryKey = {
    ping: () => ['API', 'ping'] as const,
    version: () => ['API', 'version'] as const,
    runtimeStatus: () => ['API', 'runtimeStatus'] as const,
    clock: () => ['API', 'clock'] as const,
    getSequenceContext: () => ['API', 'getSequenceContext'] as const,
    getAuthToken: (req: GetAuthTokenRequest) => ['API', 'getAuthToken', req] as const,
    getAuthToken2: (req: GetAuthToken2Request) => ['API', 'getAuthToken2', req] as const,
    sendPasswordlessLink: (req: SendPasswordlessLinkRequest) => ['API', 'sendPasswordlessLink', req] as const,
    registerPublicKey: (req: RegisterPublicKeyRequest) => ['API', 'registerPublicKey', req] as const,
    getPublicKey: (req: GetPublicKeyRequest) => ['API', 'getPublicKey', req] as const,
    friendList: (req: FriendListRequest) => ['API', 'friendList', req] as const,
    getFriendByAddress: (req: GetFriendByAddressRequest) => ['API', 'getFriendByAddress', req] as const,
    searchFriends: (req: SearchFriendsRequest) => ['API', 'searchFriends', req] as const,
    addFriend: (req: AddFriendRequest) => ['API', 'addFriend', req] as const,
    updateFriendNickname: (req: UpdateFriendNicknameRequest) => ['API', 'updateFriendNickname', req] as const,
    removeFriend: (req: RemoveFriendRequest) => ['API', 'removeFriend', req] as const,
    contractCall: (req: ContractCallRequest) => ['API', 'contractCall', req] as const,
    decodeContractCall: (req: DecodeContractCallRequest) => ['API', 'decodeContractCall', req] as const,
    lookupContractCallSelectors: (req: LookupContractCallSelectorsRequest) =>
      ['API', 'lookupContractCallSelectors', req] as const,
    userStorageFetch: (req: UserStorageFetchRequest) => ['API', 'userStorageFetch', req] as const,
    userStorageSave: (req: UserStorageSaveRequest) => ['API', 'userStorageSave', req] as const,
    userStorageDelete: (req: UserStorageDeleteRequest) => ['API', 'userStorageDelete', req] as const,
    userStorageFetchAll: (req: UserStorageFetchAllRequest) => ['API', 'userStorageFetchAll', req] as const,
    getMoonpayLink: (req: GetMoonpayLinkRequest) => ['API', 'getMoonpayLink', req] as const,
    resolveENSAddress: (req: ResolveENSAddressRequest) => ['API', 'resolveENSAddress', req] as const,
    isValidSignature: (req: IsValidSignatureRequest) => ['API', 'isValidSignature', req] as const,
    isValidMessageSignature: (req: IsValidMessageSignatureRequest) => ['API', 'isValidMessageSignature', req] as const,
    isValidTypedDataSignature: (req: IsValidTypedDataSignatureRequest) => ['API', 'isValidTypedDataSignature', req] as const,
    isValidETHAuthProof: (req: IsValidETHAuthProofRequest) => ['API', 'isValidETHAuthProof', req] as const,
    getOnRampURL: (req: GetOnRampURLRequest) => ['API', 'getOnRampURL', req] as const,
    transakGetCountries: () => ['API', 'transakGetCountries'] as const,
    transakGetCryptoCurrencies: () => ['API', 'transakGetCryptoCurrencies'] as const,
    transakGetFiatCurrencies: () => ['API', 'transakGetFiatCurrencies'] as const,
    transakGetPrice: (req: TransakGetPriceRequest) => ['API', 'transakGetPrice', req] as const,
    transakGetSupportedNFTCheckoutChains: () => ['API', 'transakGetSupportedNFTCheckoutChains'] as const,
    transakGetWidgetURL: (req: TransakGetWidgetURLRequest) => ['API', 'transakGetWidgetURL', req] as const,
    getCoinPrices: (req: GetCoinPricesRequest) => ['API', 'getCoinPrices', req] as const,
    getCollectiblePrices: (req: GetCollectiblePricesRequest) => ['API', 'getCollectiblePrices', req] as const,
    getExchangeRate: (req: GetExchangeRateRequest) => ['API', 'getExchangeRate', req] as const,
    memoryStore: (req: MemoryStoreRequest) => ['API', 'memoryStore', req] as const,
    memoryLoad: (req: MemoryLoadRequest) => ['API', 'memoryLoad', req] as const,
    getInviteInfo: () => ['API', 'getInviteInfo'] as const,
    isValidAccessCode: (req: IsValidAccessCodeRequest) => ['API', 'isValidAccessCode', req] as const,
    internalClaimAccessCode: (req: InternalClaimAccessCodeRequest) => ['API', 'internalClaimAccessCode', req] as const,
    blockNumberAtTime: (req: BlockNumberAtTimeRequest) => ['API', 'blockNumberAtTime', req] as const,
    paperSessionSecret: (req: PaperSessionSecretRequest) => ['API', 'paperSessionSecret', req] as const,
    paperSessionSecret2: (req: PaperSessionSecret2Request) => ['API', 'paperSessionSecret2', req] as const,
    linkWallet: (req: LinkWalletRequest) => ['API', 'linkWallet', req] as const,
    getLinkedWallets: (req: GetLinkedWalletsRequest) => ['API', 'getLinkedWallets', req] as const,
    removeLinkedWallet: (req: RemoveLinkedWalletRequest) => ['API', 'removeLinkedWallet', req] as const,
    generateWaaSVerificationURL: (req: GenerateWaaSVerificationURLRequest) =>
      ['API', 'generateWaaSVerificationURL', req] as const,
    validateWaaSVerificationNonce: (req: ValidateWaaSVerificationNonceRequest) =>
      ['API', 'validateWaaSVerificationNonce', req] as const,
    listAdoptedWallets: (req: ListAdoptedWalletsRequest) => ['API', 'listAdoptedWallets', req] as const,
    getLifiChains: () => ['API', 'getLifiChains'] as const,
    getLifiTokens: (req: GetLifiTokensRequest) => ['API', 'getLifiTokens', req] as const,
    getLifiSwapRoutes: (req: GetLifiSwapRoutesRequest) => ['API', 'getLifiSwapRoutes', req] as const,
    getLifiSwapQuote: (req: GetLifiSwapQuoteRequest) => ['API', 'getLifiSwapQuote', req] as const,
    listCurrencyGroups: () => ['API', 'listCurrencyGroups'] as const,
    addOffchainInventory: (req: AddOffchainInventoryRequest) => ['API', 'addOffchainInventory', req] as const,
    getOffchainInventory: (req: GetOffchainInventoryRequest) => ['API', 'getOffchainInventory', req] as const,
    listOffchainInventories: (req: ListOffchainInventoriesRequest) => ['API', 'listOffchainInventories', req] as const,
    updateOffchainInventory: (req: UpdateOffchainInventoryRequest) => ['API', 'updateOffchainInventory', req] as const,
    deleteOffchainInventory: (req: DeleteOffchainInventoryRequest) => ['API', 'deleteOffchainInventory', req] as const,
    requestOffchainPayment: (req: RequestOffchainPaymentRequest) => ['API', 'requestOffchainPayment', req] as const,
    listOffchainPayments: (req: ListOffchainPaymentsRequest) => ['API', 'listOffchainPayments', req] as const,
    savePack: (req: SavePackRequest) => ['API', 'savePack', req] as const,
    getPack: (req: GetPackRequest) => ['API', 'getPack', req] as const,
    getPackIds: (req: GetPackIdsRequest) => ['API', 'getPackIds', req] as const,
    deletePack: (req: DeletePackRequest) => ['API', 'deletePack', req] as const,
    updatePackContent: (req: UpdatePackContentRequest) => ['API', 'updatePackContent', req] as const,
    getRevealTxData: (req: GetRevealTxDataRequest) => ['API', 'getRevealTxData', req] as const,
    checkoutOptionsPrimary: (req: CheckoutOptionsPrimaryRequest) => ['API', 'checkoutOptionsPrimary', req] as const,
    checkoutOptionsSecondary: (req: CheckoutOptionsSecondaryRequest) => ['API', 'checkoutOptionsSecondary', req] as const,
    checkoutOptionsGetTransakContractID: (req: CheckoutOptionsGetTransakContractIDRequest) =>
      ['API', 'checkoutOptionsGetTransakContractID', req] as const,
    fortePayCreateIntent: (req: FortePayCreateIntentRequest) => ['API', 'fortePayCreateIntent', req] as const,
    fortePayGetPaymentStatuses: (req: FortePayGetPaymentStatusesRequest) => ['API', 'fortePayGetPaymentStatuses', req] as const
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingResponse> => {
    return this.fetch(this.url('Ping'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PingResponse>(_data, 'PingResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  version = (headers?: object, signal?: AbortSignal): Promise<VersionResponse> => {
    return this.fetch(this.url('Version'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<VersionResponse>(_data, 'VersionResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse> => {
    return this.fetch(this.url('RuntimeStatus'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RuntimeStatusResponse>(_data, 'RuntimeStatusResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  clock = (headers?: object, signal?: AbortSignal): Promise<ClockResponse> => {
    return this.fetch(this.url('Clock'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ClockResponse>(_data, 'ClockResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getSequenceContext = (headers?: object, signal?: AbortSignal): Promise<GetSequenceContextResponse> => {
    return this.fetch(this.url('GetSequenceContext'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetSequenceContextResponse>(_data, 'GetSequenceContextResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getAuthToken = (req: GetAuthTokenRequest, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenResponse> => {
    return this.fetch(this.url('GetAuthToken'), createHttpRequest(JsonEncode(req, 'GetAuthTokenRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetAuthTokenResponse>(_data, 'GetAuthTokenResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getAuthToken2 = (req: GetAuthToken2Request, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Response> => {
    return this.fetch(
      this.url('GetAuthToken2'),
      createHttpRequest(JsonEncode(req, 'GetAuthToken2Request'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetAuthToken2Response>(_data, 'GetAuthToken2Response')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  sendPasswordlessLink = (
    req: SendPasswordlessLinkRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SendPasswordlessLinkResponse> => {
    return this.fetch(
      this.url('SendPasswordlessLink'),
      createHttpRequest(JsonEncode(req, 'SendPasswordlessLinkRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SendPasswordlessLinkResponse>(_data, 'SendPasswordlessLinkResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  registerPublicKey = (
    req: RegisterPublicKeyRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RegisterPublicKeyResponse> => {
    return this.fetch(
      this.url('RegisterPublicKey'),
      createHttpRequest(JsonEncode(req, 'RegisterPublicKeyRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RegisterPublicKeyResponse>(_data, 'RegisterPublicKeyResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getPublicKey = (req: GetPublicKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetPublicKeyResponse> => {
    return this.fetch(this.url('GetPublicKey'), createHttpRequest(JsonEncode(req, 'GetPublicKeyRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetPublicKeyResponse>(_data, 'GetPublicKeyResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  friendList = (req: FriendListRequest, headers?: object, signal?: AbortSignal): Promise<FriendListResponse> => {
    return this.fetch(this.url('FriendList'), createHttpRequest(JsonEncode(req, 'FriendListRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<FriendListResponse>(_data, 'FriendListResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getFriendByAddress = (
    req: GetFriendByAddressRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetFriendByAddressResponse> => {
    return this.fetch(
      this.url('GetFriendByAddress'),
      createHttpRequest(JsonEncode(req, 'GetFriendByAddressRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetFriendByAddressResponse>(_data, 'GetFriendByAddressResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  searchFriends = (req: SearchFriendsRequest, headers?: object, signal?: AbortSignal): Promise<SearchFriendsResponse> => {
    return this.fetch(
      this.url('SearchFriends'),
      createHttpRequest(JsonEncode(req, 'SearchFriendsRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SearchFriendsResponse>(_data, 'SearchFriendsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  addFriend = (req: AddFriendRequest, headers?: object, signal?: AbortSignal): Promise<AddFriendResponse> => {
    return this.fetch(this.url('AddFriend'), createHttpRequest(JsonEncode(req, 'AddFriendRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AddFriendResponse>(_data, 'AddFriendResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  updateFriendNickname = (
    req: UpdateFriendNicknameRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateFriendNicknameResponse> => {
    return this.fetch(
      this.url('UpdateFriendNickname'),
      createHttpRequest(JsonEncode(req, 'UpdateFriendNicknameRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UpdateFriendNicknameResponse>(_data, 'UpdateFriendNicknameResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  removeFriend = (req: RemoveFriendRequest, headers?: object, signal?: AbortSignal): Promise<RemoveFriendResponse> => {
    return this.fetch(this.url('RemoveFriend'), createHttpRequest(JsonEncode(req, 'RemoveFriendRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RemoveFriendResponse>(_data, 'RemoveFriendResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  contractCall = (req: ContractCallRequest, headers?: object, signal?: AbortSignal): Promise<ContractCallResponse> => {
    return this.fetch(this.url('ContractCall'), createHttpRequest(JsonEncode(req, 'ContractCallRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ContractCallResponse>(_data, 'ContractCallResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  decodeContractCall = (
    req: DecodeContractCallRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DecodeContractCallResponse> => {
    return this.fetch(
      this.url('DecodeContractCall'),
      createHttpRequest(JsonEncode(req, 'DecodeContractCallRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<DecodeContractCallResponse>(_data, 'DecodeContractCallResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  lookupContractCallSelectors = (
    req: LookupContractCallSelectorsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<LookupContractCallSelectorsResponse> => {
    return this.fetch(
      this.url('LookupContractCallSelectors'),
      createHttpRequest(JsonEncode(req, 'LookupContractCallSelectorsRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<LookupContractCallSelectorsResponse>(_data, 'LookupContractCallSelectorsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  userStorageFetch = (
    req: UserStorageFetchRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UserStorageFetchResponse> => {
    return this.fetch(
      this.url('UserStorageFetch'),
      createHttpRequest(JsonEncode(req, 'UserStorageFetchRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UserStorageFetchResponse>(_data, 'UserStorageFetchResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  userStorageSave = (req: UserStorageSaveRequest, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveResponse> => {
    return this.fetch(
      this.url('UserStorageSave'),
      createHttpRequest(JsonEncode(req, 'UserStorageSaveRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UserStorageSaveResponse>(_data, 'UserStorageSaveResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  userStorageDelete = (
    req: UserStorageDeleteRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UserStorageDeleteResponse> => {
    return this.fetch(
      this.url('UserStorageDelete'),
      createHttpRequest(JsonEncode(req, 'UserStorageDeleteRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UserStorageDeleteResponse>(_data, 'UserStorageDeleteResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  userStorageFetchAll = (
    req: UserStorageFetchAllRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UserStorageFetchAllResponse> => {
    return this.fetch(
      this.url('UserStorageFetchAll'),
      createHttpRequest(JsonEncode(req, 'UserStorageFetchAllRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UserStorageFetchAllResponse>(_data, 'UserStorageFetchAllResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getMoonpayLink = (req: GetMoonpayLinkRequest, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkResponse> => {
    return this.fetch(
      this.url('GetMoonpayLink'),
      createHttpRequest(JsonEncode(req, 'GetMoonpayLinkRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetMoonpayLinkResponse>(_data, 'GetMoonpayLinkResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  resolveENSAddress = (
    req: ResolveENSAddressRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ResolveENSAddressResponse> => {
    return this.fetch(
      this.url('ResolveENSAddress'),
      createHttpRequest(JsonEncode(req, 'ResolveENSAddressRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ResolveENSAddressResponse>(_data, 'ResolveENSAddressResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  isValidSignature = (
    req: IsValidSignatureRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidSignatureResponse> => {
    return this.fetch(
      this.url('IsValidSignature'),
      createHttpRequest(JsonEncode(req, 'IsValidSignatureRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<IsValidSignatureResponse>(_data, 'IsValidSignatureResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  isValidMessageSignature = (
    req: IsValidMessageSignatureRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidMessageSignatureResponse> => {
    return this.fetch(
      this.url('IsValidMessageSignature'),
      createHttpRequest(JsonEncode(req, 'IsValidMessageSignatureRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<IsValidMessageSignatureResponse>(_data, 'IsValidMessageSignatureResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  isValidTypedDataSignature = (
    req: IsValidTypedDataSignatureRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidTypedDataSignatureResponse> => {
    return this.fetch(
      this.url('IsValidTypedDataSignature'),
      createHttpRequest(JsonEncode(req, 'IsValidTypedDataSignatureRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<IsValidTypedDataSignatureResponse>(_data, 'IsValidTypedDataSignatureResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  isValidETHAuthProof = (
    req: IsValidETHAuthProofRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidETHAuthProofResponse> => {
    return this.fetch(
      this.url('IsValidETHAuthProof'),
      createHttpRequest(JsonEncode(req, 'IsValidETHAuthProofRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<IsValidETHAuthProofResponse>(_data, 'IsValidETHAuthProofResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getOnRampURL = (req: GetOnRampURLRequest, headers?: object, signal?: AbortSignal): Promise<GetOnRampURLResponse> => {
    return this.fetch(this.url('GetOnRampURL'), createHttpRequest(JsonEncode(req, 'GetOnRampURLRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetOnRampURLResponse>(_data, 'GetOnRampURLResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  transakGetCountries = (headers?: object, signal?: AbortSignal): Promise<TransakGetCountriesResponse> => {
    return this.fetch(this.url('TransakGetCountries'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<TransakGetCountriesResponse>(_data, 'TransakGetCountriesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  transakGetCryptoCurrencies = (headers?: object, signal?: AbortSignal): Promise<TransakGetCryptoCurrenciesResponse> => {
    return this.fetch(this.url('TransakGetCryptoCurrencies'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<TransakGetCryptoCurrenciesResponse>(_data, 'TransakGetCryptoCurrenciesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  transakGetFiatCurrencies = (headers?: object, signal?: AbortSignal): Promise<TransakGetFiatCurrenciesResponse> => {
    return this.fetch(this.url('TransakGetFiatCurrencies'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<TransakGetFiatCurrenciesResponse>(_data, 'TransakGetFiatCurrenciesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  transakGetPrice = (req: TransakGetPriceRequest, headers?: object, signal?: AbortSignal): Promise<TransakGetPriceResponse> => {
    return this.fetch(
      this.url('TransakGetPrice'),
      createHttpRequest(JsonEncode(req, 'TransakGetPriceRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<TransakGetPriceResponse>(_data, 'TransakGetPriceResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  transakGetSupportedNFTCheckoutChains = (
    headers?: object,
    signal?: AbortSignal
  ): Promise<TransakGetSupportedNFTCheckoutChainsResponse> => {
    return this.fetch(this.url('TransakGetSupportedNFTCheckoutChains'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<TransakGetSupportedNFTCheckoutChainsResponse>(_data, 'TransakGetSupportedNFTCheckoutChainsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  transakGetWidgetURL = (
    req: TransakGetWidgetURLRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<TransakGetWidgetURLResponse> => {
    return this.fetch(
      this.url('TransakGetWidgetURL'),
      createHttpRequest(JsonEncode(req, 'TransakGetWidgetURLRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<TransakGetWidgetURLResponse>(_data, 'TransakGetWidgetURLResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getCoinPrices = (req: GetCoinPricesRequest, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesResponse> => {
    return this.fetch(
      this.url('GetCoinPrices'),
      createHttpRequest(JsonEncode(req, 'GetCoinPricesRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetCoinPricesResponse>(_data, 'GetCoinPricesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getCollectiblePrices = (
    req: GetCollectiblePricesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectiblePricesResponse> => {
    return this.fetch(
      this.url('GetCollectiblePrices'),
      createHttpRequest(JsonEncode(req, 'GetCollectiblePricesRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetCollectiblePricesResponse>(_data, 'GetCollectiblePricesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getExchangeRate = (req: GetExchangeRateRequest, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateResponse> => {
    return this.fetch(
      this.url('GetExchangeRate'),
      createHttpRequest(JsonEncode(req, 'GetExchangeRateRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetExchangeRateResponse>(_data, 'GetExchangeRateResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  memoryStore = (req: MemoryStoreRequest, headers?: object, signal?: AbortSignal): Promise<MemoryStoreResponse> => {
    return this.fetch(this.url('MemoryStore'), createHttpRequest(JsonEncode(req, 'MemoryStoreRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<MemoryStoreResponse>(_data, 'MemoryStoreResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  memoryLoad = (req: MemoryLoadRequest, headers?: object, signal?: AbortSignal): Promise<MemoryLoadResponse> => {
    return this.fetch(this.url('MemoryLoad'), createHttpRequest(JsonEncode(req, 'MemoryLoadRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<MemoryLoadResponse>(_data, 'MemoryLoadResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getInviteInfo = (headers?: object, signal?: AbortSignal): Promise<GetInviteInfoResponse> => {
    return this.fetch(this.url('GetInviteInfo'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetInviteInfoResponse>(_data, 'GetInviteInfoResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  isValidAccessCode = (
    req: IsValidAccessCodeRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<IsValidAccessCodeResponse> => {
    return this.fetch(
      this.url('IsValidAccessCode'),
      createHttpRequest(JsonEncode(req, 'IsValidAccessCodeRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<IsValidAccessCodeResponse>(_data, 'IsValidAccessCodeResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  internalClaimAccessCode = (
    req: InternalClaimAccessCodeRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<InternalClaimAccessCodeResponse> => {
    return this.fetch(
      this.url('InternalClaimAccessCode'),
      createHttpRequest(JsonEncode(req, 'InternalClaimAccessCodeRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<InternalClaimAccessCodeResponse>(_data, 'InternalClaimAccessCodeResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  blockNumberAtTime = (
    req: BlockNumberAtTimeRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<BlockNumberAtTimeResponse> => {
    return this.fetch(
      this.url('BlockNumberAtTime'),
      createHttpRequest(JsonEncode(req, 'BlockNumberAtTimeRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<BlockNumberAtTimeResponse>(_data, 'BlockNumberAtTimeResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  paperSessionSecret = (
    req: PaperSessionSecretRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<PaperSessionSecretResponse> => {
    return this.fetch(
      this.url('PaperSessionSecret'),
      createHttpRequest(JsonEncode(req, 'PaperSessionSecretRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PaperSessionSecretResponse>(_data, 'PaperSessionSecretResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  paperSessionSecret2 = (
    req: PaperSessionSecret2Request,
    headers?: object,
    signal?: AbortSignal
  ): Promise<PaperSessionSecret2Response> => {
    return this.fetch(
      this.url('PaperSessionSecret2'),
      createHttpRequest(JsonEncode(req, 'PaperSessionSecret2Request'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PaperSessionSecret2Response>(_data, 'PaperSessionSecret2Response')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  linkWallet = (req: LinkWalletRequest, headers?: object, signal?: AbortSignal): Promise<LinkWalletResponse> => {
    return this.fetch(this.url('LinkWallet'), createHttpRequest(JsonEncode(req, 'LinkWalletRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<LinkWalletResponse>(_data, 'LinkWalletResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getLinkedWallets = (
    req: GetLinkedWalletsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLinkedWalletsResponse> => {
    return this.fetch(
      this.url('GetLinkedWallets'),
      createHttpRequest(JsonEncode(req, 'GetLinkedWalletsRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetLinkedWalletsResponse>(_data, 'GetLinkedWalletsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  removeLinkedWallet = (
    req: RemoveLinkedWalletRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveLinkedWalletResponse> => {
    return this.fetch(
      this.url('RemoveLinkedWallet'),
      createHttpRequest(JsonEncode(req, 'RemoveLinkedWalletRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RemoveLinkedWalletResponse>(_data, 'RemoveLinkedWalletResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  generateWaaSVerificationURL = (
    req: GenerateWaaSVerificationURLRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateWaaSVerificationURLResponse> => {
    return this.fetch(
      this.url('GenerateWaaSVerificationURL'),
      createHttpRequest(JsonEncode(req, 'GenerateWaaSVerificationURLRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GenerateWaaSVerificationURLResponse>(_data, 'GenerateWaaSVerificationURLResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  validateWaaSVerificationNonce = (
    req: ValidateWaaSVerificationNonceRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ValidateWaaSVerificationNonceResponse> => {
    return this.fetch(
      this.url('ValidateWaaSVerificationNonce'),
      createHttpRequest(JsonEncode(req, 'ValidateWaaSVerificationNonceRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ValidateWaaSVerificationNonceResponse>(_data, 'ValidateWaaSVerificationNonceResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  listAdoptedWallets = (
    req: ListAdoptedWalletsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListAdoptedWalletsResponse> => {
    return this.fetch(
      this.url('ListAdoptedWallets'),
      createHttpRequest(JsonEncode(req, 'ListAdoptedWalletsRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ListAdoptedWalletsResponse>(_data, 'ListAdoptedWalletsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getLifiChains = (headers?: object, signal?: AbortSignal): Promise<GetLifiChainsResponse> => {
    return this.fetch(this.url('GetLifiChains'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetLifiChainsResponse>(_data, 'GetLifiChainsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getLifiTokens = (req: GetLifiTokensRequest, headers?: object, signal?: AbortSignal): Promise<GetLifiTokensResponse> => {
    return this.fetch(
      this.url('GetLifiTokens'),
      createHttpRequest(JsonEncode(req, 'GetLifiTokensRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetLifiTokensResponse>(_data, 'GetLifiTokensResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getLifiSwapRoutes = (
    req: GetLifiSwapRoutesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLifiSwapRoutesResponse> => {
    return this.fetch(
      this.url('GetLifiSwapRoutes'),
      createHttpRequest(JsonEncode(req, 'GetLifiSwapRoutesRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetLifiSwapRoutesResponse>(_data, 'GetLifiSwapRoutesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getLifiSwapQuote = (
    req: GetLifiSwapQuoteRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLifiSwapQuoteResponse> => {
    return this.fetch(
      this.url('GetLifiSwapQuote'),
      createHttpRequest(JsonEncode(req, 'GetLifiSwapQuoteRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetLifiSwapQuoteResponse>(_data, 'GetLifiSwapQuoteResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  listCurrencyGroups = (headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsResponse> => {
    return this.fetch(this.url('ListCurrencyGroups'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ListCurrencyGroupsResponse>(_data, 'ListCurrencyGroupsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  addOffchainInventory = (
    req: AddOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddOffchainInventoryResponse> => {
    return this.fetch(
      this.url('AddOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'AddOffchainInventoryRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AddOffchainInventoryResponse>(_data, 'AddOffchainInventoryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getOffchainInventory = (
    req: GetOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetOffchainInventoryResponse> => {
    return this.fetch(
      this.url('GetOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'GetOffchainInventoryRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetOffchainInventoryResponse>(_data, 'GetOffchainInventoryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  listOffchainInventories = (
    req: ListOffchainInventoriesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainInventoriesResponse> => {
    return this.fetch(
      this.url('ListOffchainInventories'),
      createHttpRequest(JsonEncode(req, 'ListOffchainInventoriesRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ListOffchainInventoriesResponse>(_data, 'ListOffchainInventoriesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  updateOffchainInventory = (
    req: UpdateOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateOffchainInventoryResponse> => {
    return this.fetch(
      this.url('UpdateOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'UpdateOffchainInventoryRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UpdateOffchainInventoryResponse>(_data, 'UpdateOffchainInventoryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  deleteOffchainInventory = (
    req: DeleteOffchainInventoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeleteOffchainInventoryResponse> => {
    return this.fetch(
      this.url('DeleteOffchainInventory'),
      createHttpRequest(JsonEncode(req, 'DeleteOffchainInventoryRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<DeleteOffchainInventoryResponse>(_data, 'DeleteOffchainInventoryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  requestOffchainPayment = (
    req: RequestOffchainPaymentRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RequestOffchainPaymentResponse> => {
    return this.fetch(
      this.url('RequestOffchainPayment'),
      createHttpRequest(JsonEncode(req, 'RequestOffchainPaymentRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RequestOffchainPaymentResponse>(_data, 'RequestOffchainPaymentResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  listOffchainPayments = (
    req: ListOffchainPaymentsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffchainPaymentsResponse> => {
    return this.fetch(
      this.url('ListOffchainPayments'),
      createHttpRequest(JsonEncode(req, 'ListOffchainPaymentsRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ListOffchainPaymentsResponse>(_data, 'ListOffchainPaymentsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  savePack = (req: SavePackRequest, headers?: object, signal?: AbortSignal): Promise<SavePackResponse> => {
    return this.fetch(this.url('SavePack'), createHttpRequest(JsonEncode(req, 'SavePackRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SavePackResponse>(_data, 'SavePackResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getPack = (req: GetPackRequest, headers?: object, signal?: AbortSignal): Promise<GetPackResponse> => {
    return this.fetch(this.url('GetPack'), createHttpRequest(JsonEncode(req, 'GetPackRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetPackResponse>(_data, 'GetPackResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getPackIds = (req: GetPackIdsRequest, headers?: object, signal?: AbortSignal): Promise<GetPackIdsResponse> => {
    return this.fetch(this.url('GetPackIds'), createHttpRequest(JsonEncode(req, 'GetPackIdsRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetPackIdsResponse>(_data, 'GetPackIdsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  deletePack = (req: DeletePackRequest, headers?: object, signal?: AbortSignal): Promise<DeletePackResponse> => {
    return this.fetch(this.url('DeletePack'), createHttpRequest(JsonEncode(req, 'DeletePackRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<DeletePackResponse>(_data, 'DeletePackResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  updatePackContent = (
    req: UpdatePackContentRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdatePackContentResponse> => {
    return this.fetch(
      this.url('UpdatePackContent'),
      createHttpRequest(JsonEncode(req, 'UpdatePackContentRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UpdatePackContentResponse>(_data, 'UpdatePackContentResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getRevealTxData = (req: GetRevealTxDataRequest, headers?: object, signal?: AbortSignal): Promise<GetRevealTxDataResponse> => {
    return this.fetch(
      this.url('GetRevealTxData'),
      createHttpRequest(JsonEncode(req, 'GetRevealTxDataRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetRevealTxDataResponse>(_data, 'GetRevealTxDataResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  checkoutOptionsPrimary = (
    req: CheckoutOptionsPrimaryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsPrimaryResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsPrimary'),
      createHttpRequest(JsonEncode(req, 'CheckoutOptionsPrimaryRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<CheckoutOptionsPrimaryResponse>(_data, 'CheckoutOptionsPrimaryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  checkoutOptionsSecondary = (
    req: CheckoutOptionsSecondaryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsSecondaryResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsSecondary'),
      createHttpRequest(JsonEncode(req, 'CheckoutOptionsSecondaryRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<CheckoutOptionsSecondaryResponse>(_data, 'CheckoutOptionsSecondaryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  checkoutOptionsGetTransakContractID = (
    req: CheckoutOptionsGetTransakContractIDRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsGetTransakContractIDResponse> => {
    return this.fetch(
      this.url('CheckoutOptionsGetTransakContractID'),
      createHttpRequest(JsonEncode(req, 'CheckoutOptionsGetTransakContractIDRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<CheckoutOptionsGetTransakContractIDResponse>(_data, 'CheckoutOptionsGetTransakContractIDResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  fortePayCreateIntent = (
    req: FortePayCreateIntentRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FortePayCreateIntentResponse> => {
    return this.fetch(
      this.url('FortePayCreateIntent'),
      createHttpRequest(JsonEncode(req, 'FortePayCreateIntentRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<FortePayCreateIntentResponse>(_data, 'FortePayCreateIntentResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  fortePayGetPaymentStatuses = (
    req: FortePayGetPaymentStatusesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FortePayGetPaymentStatusesResponse> => {
    return this.fetch(
      this.url('FortePayGetPaymentStatuses'),
      createHttpRequest(JsonEncode(req, 'FortePayGetPaymentStatusesRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<FortePayGetPaymentStatusesResponse>(_data, 'FortePayGetPaymentStatusesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }
}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = {
    ...headers,
    'Content-Type': 'application/json',
    [WebrpcHeader]: WebrpcHeaderValue
  }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>

export const JsonEncode = <T = any>(obj: T, _typ: string = ''): string => {
  return JSON.stringify(obj)
}

export const JsonDecode = <T = any>(data: string | any, _typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try {
      parsed = JSON.parse(data)
    } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return parsed as T
}

//
// Errors
//

type WebrpcErrorParams = { name?: string; code?: number; message?: string; status?: number; cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}

export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class AbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Aborted'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request aborted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Rate-limited. Please slow down.`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1008
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1101
    this.message = error.message || `Access key not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyMismatch'
    this.code = typeof error.code === 'number' ? error.code : 1102
    this.message = error.message || `Access key mismatch`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidOrigin'
    this.code = typeof error.code === 'number' ? error.code : 1103
    this.message = error.message || `Invalid origin for Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidService'
    this.code = typeof error.code === 'number' ? error.code : 1104
    this.message = error.message || `Service not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnauthorizedUser'
    this.code = typeof error.code === 'number' ? error.code : 1105
    this.message = error.message || `Unauthorized user`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaExceeded'
    this.code = typeof error.code === 'number' ? error.code : 1200
    this.message = error.message || `Quota request exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class QuotaRateLimitError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaRateLimit'
    this.code = typeof error.code === 'number' ? error.code : 1201
    this.message = error.message || `Quota rate limit exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaRateLimitError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NoDefaultKey'
    this.code = typeof error.code === 'number' ? error.code : 1300
    this.message = error.message || `No default access key found`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MaxAccessKeys'
    this.code = typeof error.code === 'number' ? error.code : 1301
    this.message = error.message || `Access keys limit reached`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AtLeastOneKey'
    this.code = typeof error.code === 'number' ? error.code : 1302
    this.message = error.message || `You need at least one Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 1900
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidArgument'
    this.code = typeof error.code === 'number' ? error.code : 2000
    this.message = error.message || `Invalid argument`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class UnavailableError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unavailable'
    this.code = typeof error.code === 'number' ? error.code : 2002
    this.message = error.message || `Unavailable resource`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnavailableError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QueryFailed'
    this.code = typeof error.code === 'number' ? error.code : 2003
    this.message = error.message || `Query failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotFound'
    this.code = typeof error.code === 'number' ? error.code : 3000
    this.message = error.message || `Resource not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class UnsupportedNetworkError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnsupportedNetwork'
    this.code = typeof error.code === 'number' ? error.code : 3008
    this.message = error.message || `Unsupported network`
    this.status = typeof error.status === 'number' ? error.status : 422
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnsupportedNetworkError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Aborted = 'Aborted',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  ProjectNotFound = 'ProjectNotFound',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AccessKeyMismatch = 'AccessKeyMismatch',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  UnauthorizedUser = 'UnauthorizedUser',
  QuotaExceeded = 'QuotaExceeded',
  QuotaRateLimit = 'QuotaRateLimit',
  NoDefaultKey = 'NoDefaultKey',
  MaxAccessKeys = 'MaxAccessKeys',
  AtLeastOneKey = 'AtLeastOneKey',
  Timeout = 'Timeout',
  InvalidArgument = 'InvalidArgument',
  Unavailable = 'Unavailable',
  QueryFailed = 'QueryFailed',
  NotFound = 'NotFound',
  UnsupportedNetwork = 'UnsupportedNetwork'
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Aborted = 1005,
  Geoblocked = 1006,
  RateLimited = 1007,
  ProjectNotFound = 1008,
  AccessKeyNotFound = 1101,
  AccessKeyMismatch = 1102,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  UnauthorizedUser = 1105,
  QuotaExceeded = 1200,
  QuotaRateLimit = 1201,
  NoDefaultKey = 1300,
  MaxAccessKeys = 1301,
  AtLeastOneKey = 1302,
  Timeout = 1900,
  InvalidArgument = 2000,
  Unavailable = 2002,
  QueryFailed = 2003,
  NotFound = 3000,
  UnsupportedNetwork = 3008
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [1006]: GeoblockedError,
  [1007]: RateLimitedError,
  [1008]: ProjectNotFoundError,
  [1101]: AccessKeyNotFoundError,
  [1102]: AccessKeyMismatchError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1105]: UnauthorizedUserError,
  [1200]: QuotaExceededError,
  [1201]: QuotaRateLimitError,
  [1300]: NoDefaultKeyError,
  [1301]: MaxAccessKeysError,
  [1302]: AtLeastOneKeyError,
  [1900]: TimeoutError,
  [2000]: InvalidArgumentError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [3000]: NotFoundError,
  [3008]: UnsupportedNetworkError
}

//
// Webrpc
//

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.31.0;gen-typescript@v0.22.5;sequence-api@v0.4.0'

type WebrpcGenVersions = {
  WebrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  const [_, WebrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? ''
  }
}
