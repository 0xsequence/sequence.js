/* eslint-disable */
// sequence-indexer v0.4.0 9424146daac757c1b912723a9a212b419dfea11e
// --
// Code generated by webrpc-gen@v0.25.3 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=merged.gen.json -service=IndexerGateway -target=typescript -client -out=./clients/indexergw.gen.ts

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.25.3;gen-typescript@v0.17.0;sequence-indexer@v0.4.0'

// WebRPC description and code-gen version
export const WebRPCVersion = 'v1'

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = '9424146daac757c1b912723a9a212b419dfea11e'

type WebrpcGenVersions = {
  webrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  const [_, webrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    webrpcGenVersion: webrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? ''
  }
}

//
// Types
//

export interface Asset {
  id: number
  collectionId: number
  tokenId?: string
  url?: string
  metadataField: string
  name?: string
  filesize?: number
  mimeType?: string
  width?: number
  height?: number
  updatedAt?: string
}

export interface BloomStats {
  hitRatio: string
  falsePositivesPercent: string
  hitCount: number
  missCount: number
  falsePositives: number
}

export interface BloomStatus {
  enabled: boolean
  initialized: boolean
  bloomInitElapsedTime: string
  stats: BloomStats
}

export interface Bond {
  pebble: PebbleMetrics
  estimatedDiskUsagePerTable: any
  estimatedDiskUsageTotal: string
}

export interface ChainInfo {
  chainId: number
  chainName: string
}

export interface ContractInfo {
  chainId: number
  address: string
  source: string
  name: string
  type: string
  symbol: string
  decimals?: number
  logoURI: string
  deployed: boolean
  bytecodeHash: string
  extensions: ContractInfoExtensions
  updatedAt: string
  queuedAt?: string
  status: ResourceStatus
}

export interface ContractInfoExtensions {
  link: string
  description: string
  categories: Array<string>
  ogImage: string
  ogName: string
  originChainId: number
  originAddress: string
  blacklist: boolean
  verified: boolean
  verifiedBy: string
  featured: boolean
  featureIndex: number
}

export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  NATIVE = 'NATIVE',
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155',
  SEQUENCE_WALLET = 'SEQUENCE_WALLET',
  ERC20_BRIDGE = 'ERC20_BRIDGE',
  ERC721_BRIDGE = 'ERC721_BRIDGE',
  ERC1155_BRIDGE = 'ERC1155_BRIDGE',
  SEQ_MARKETPLACE = 'SEQ_MARKETPLACE',
  ERC6909 = 'ERC6909'
}

export enum ContractVerificationStatus {
  VERIFIED = 'VERIFIED',
  UNVERIFIED = 'UNVERIFIED',
  ALL = 'ALL'
}

export interface DiskUsage {
  humanReadable: string
  used: number
  size: number
  percent: number
  dirs: { [key: string]: string }
}

export interface EtherBalance {
  accountAddress: string
  balanceWei: string
}

export interface EventDecoded {
  topicHash: string
  eventSig: string
  types: Array<string>
  names: Array<string>
  values: Array<string>
}

export interface EventFilter {
  events?: Array<string>
  contractAddresses?: Array<string>
  accounts?: Array<string>
  tokenIDs?: Array<string>
}

export interface EventLog {
  id: number
  uid: string
  type: EventLogType
  blockNumber: number
  blockHash: string
  parentBlockHash: string
  contractAddress: string
  contractType: ContractType
  txnHash: string
  txnIndex: number
  txnLogIndex: number
  logDataType: EventLogDataType
  ts: string
  txnInfo?: TxnInfo
  rawLog?: { [key: string]: any }
  event?: EventDecoded
}

export enum EventLogDataType {
  EVENT = 'EVENT',
  TOKEN_TRANSFER = 'TOKEN_TRANSFER',
  NATIVE_TOKEN_TRANSFER = 'NATIVE_TOKEN_TRANSFER',
  SEQUENCE_TXN = 'SEQUENCE_TXN'
}

export enum EventLogType {
  UNKNOWN = 'UNKNOWN',
  BLOCK_ADDED = 'BLOCK_ADDED',
  BLOCK_REMOVED = 'BLOCK_REMOVED'
}

export interface GatewayBackendResponseTime {
  percentiles: { [key: string]: number }
  average: number
}

export interface GatewayBackendRuntimeStatus {
  name: string
  chainId: number
  responseTime: GatewayBackendResponseTime
}

export interface GatewayEtherBalance {
  chainId: number
  errorReason?: string
  result: EtherBalance
}

export interface GatewayNativeTokenBalance {
  chainId: number
  errorReason?: string
  result: NativeTokenBalance
}

export interface GatewayNativeTokenBalances {
  chainId: number
  errorReason?: string
  results: Array<NativeTokenBalance>
}

export interface GatewayRuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  backends: Array<GatewayBackendRuntimeStatus>
}

export interface GatewayTokenBalance {
  chainId: number
  errorReason?: string
  results: Array<TokenBalance>
}

export interface GatewayTransaction {
  chainId: number
  errorReason?: string
  results: Array<Transaction>
}

export interface IndexState {
  chainId: string
  lastBlockNum: number
  lastBlockHash: string
}

export interface IndexedBlock {
  blockNumber: number
  blockShortHash: string
}

export interface IndexerMetrics {
  blocksPerSecond: number
  eventsPerSecond: number
}

export interface MarketplaceOrder {
  orderId: string
  tokenContract: string
  tokenId: string
  isListing: boolean
  quantity: string
  quantityRemaining: string
  currencyAddress: string
  pricePerToken: string
  expiry: string
  orderStatus: OrderStatus
  createdBy: string
  blockNumber: number
  orderbookContractAddress: string
  createdAt: number
}

export interface MarketplaceOrderFilter {
  isListing?: boolean
  userAddresses?: Array<string>
  currencyAddresses: Array<string>
  orderIds: Array<string>
  tokenIds: Array<string>
  excludeUserAddresses?: Array<string>
  blockNumberGt: number
  createdAtAfter: number
  orderStatuses: Array<OrderStatus>
  returnExpired: boolean
}

export interface MarketplaceTopOrdersFilter {
  currencyAddresses: Array<string>
  tokenIds: Array<string>
  isListing: boolean
  priceSort: SortOrder
  excludeUser?: string
}

export interface MetadataOptions {
  verifiedOnly?: boolean
  unverifiedOnly?: boolean
  includeContracts?: Array<string>
}

export interface NativeTokenBalance {
  accountAddress: string
  chainId: number
  balance: string
  balanceUSD: string
  priceUSD: string
  error: string
}

export enum NetworkType {
  MAINNETS = 'MAINNETS',
  TESTNETS = 'TESTNETS',
  ALL = 'ALL'
}

export enum OrderStatus {
  OPEN = 'OPEN',
  CLOSED = 'CLOSED',
  CANCELLED = 'CANCELLED'
}

export interface Page {
  page?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
  pageSize?: number
  more?: boolean
}

export interface PebbleMetrics {
  compactionCount: number
  compactionEstimatedDebt: number
  compactionInProgressBytes: number
  compactionNumInProgress: number
  compactionMarkedFiles: number
}

export interface Price {
  contractAddress: string
  tokenID?: string
  priceUSD: string
}

export enum ResourceStatus {
  NOT_AVAILABLE = 'NOT_AVAILABLE',
  REFRESHING = 'REFRESHING',
  AVAILABLE = 'AVAILABLE'
}

export interface RuntimeChecks {
  running: boolean
  runnables: any
  cgoEnabled: boolean
  quotaControlEnabled: boolean
  syncMode: string
  percentIndexed: number
  lastBlockNum: number
  lastBlockNumWithState: number
  bloomStatus: BloomStatus
  bond: Bond
  diskUsage: DiskUsage
  metrics: IndexerMetrics
}

export interface RuntimeStatus {
  healthOK: boolean
  indexerEnabled: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  chainID: number
  checks: RuntimeChecks
}

export interface SortBy {
  column: string
  order: SortOrder
}

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export interface TokenBalance {
  contractType: ContractType
  contractAddress: string
  accountAddress: string
  tokenID?: string
  balance: string
  balanceUSD: string
  priceUSD: string
  blockHash: string
  blockNumber: number
  chainId: number
  uniqueCollectibles: string
  isSummary: boolean
  contractInfo?: ContractInfo
  tokenMetadata?: TokenMetadata
}

export interface TokenBalanceFilter {
  contractAddress: string
  sinceBlockNumber: number
}

export interface TokenBalancesByContractFilter {
  contractAddresses: Array<string>
  accountAddresses?: Array<string>
  contractStatus?: ContractVerificationStatus
}

export interface TokenBalancesFilter {
  accountAddresses: Array<string>
  contractStatus?: ContractVerificationStatus
  contractWhitelist?: Array<string>
  contractBlacklist?: Array<string>
  omitNativeBalances: boolean
  omitPrices?: boolean
}

export interface TokenHistory {
  blockNumber: number
  blockHash: string
  contractAddress: string
  contractType: ContractType
  fromAddress: string
  toAddress: string
  txnHash: string
  txnIndex: number
  txnLogIndex: number
  tokenIDs: string
  amounts: string
  ts: string
}

export interface TokenIDRange {
  start: string
  end: string
}

export interface TokenMetadata {
  contractAddress?: string
  tokenId: string
  source: string
  name: string
  description?: string
  image?: string
  video?: string
  audio?: string
  properties?: { [key: string]: any }
  attributes: Array<{ [key: string]: any }>
  image_data?: string
  external_url?: string
  background_color?: string
  animation_url?: string
  decimals?: number
  updatedAt?: string
  assets?: Array<Asset>
  status: ResourceStatus
  queuedAt?: string
  lastFetched?: string
}

export interface TokenSupply {
  tokenID: string
  supply: string
  chainId: number
  contractInfo?: ContractInfo
  tokenMetadata?: TokenMetadata
}

export interface Transaction {
  txnHash: string
  blockNumber: number
  blockHash: string
  chainId: number
  metaTxnID?: string
  transfers?: Array<TxnTransfer>
  timestamp: string
}

export interface TransactionFilter {
  txnHash?: string
  from?: string
  to?: string
  contractAddress?: string
  event?: string
}

export interface TransactionHistoryFilter {
  accountAddress?: string
  contractAddress?: string
  accountAddresses?: Array<string>
  contractAddresses?: Array<string>
  transactionHashes?: Array<string>
  metaTransactionIDs?: Array<string>
  fromBlock?: number
  toBlock?: number
  tokenID?: string
  omitPrices?: boolean
}

export interface TransactionLog {
  contractAddress: string
  topics: Array<string>
  data: string
  index: number
}

export interface TransactionReceipt {
  txnHash: string
  txnStatus: TransactionStatus
  txnIndex: number
  txnType: TransactionType
  blockHash: string
  blockNumber: number
  gasUsed: number
  effectiveGasPrice: string
  from: string
  to: string
  logs: Array<TransactionLog>
  final: boolean
  reorged: boolean
}

export enum TransactionStatus {
  FAILED = 'FAILED',
  SUCCESSFUL = 'SUCCESSFUL'
}

export enum TransactionType {
  LegacyTxnType = 'LegacyTxnType',
  AccessListTxnType = 'AccessListTxnType',
  DynamicFeeTxnType = 'DynamicFeeTxnType'
}

export interface TxnInfo {
  from: string
  to: string
  value: string
}

export interface TxnTransfer {
  transferType: TxnTransferType
  contractAddress: string
  contractType: ContractType
  from: string
  to: string
  tokenIds?: Array<string>
  amounts: Array<string>
  logIndex: number
  amountsUSD?: Array<string>
  pricesUSD?: Array<string>
  contractInfo?: ContractInfo
  tokenMetadata?: { [key: string]: TokenMetadata }
}

export enum TxnTransferType {
  UNKNOWN = 'UNKNOWN',
  SEND = 'SEND',
  RECEIVE = 'RECEIVE'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface WALWriterRuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  chainID: number
  percentWALWritten: number
}

export interface WebhookListener {
  id: number
  projectID: number
  url: string
  filters: EventFilter
  name: string
  updatedAt: string
  active: boolean
}

export interface IndexerGateway {
  /**
   * GetTokenBalances returns a balance summary/details for an specific account
   * on all indexer nodes. By default if accountAddress is left empty, it will
   * use the account from the jwt session.
   */
  getBalanceUpdates(args: GetBalanceUpdatesArgs, headers?: object, signal?: AbortSignal): Promise<GetBalanceUpdatesReturn>
  /**
   * GetChains returns a list of chains with their ID and name
   */
  getChains(args: GetChainsArgs, headers?: object, signal?: AbortSignal): Promise<GetChainsReturn>
  /**
   * GetNativeTokenBalance queries indexer nodes for the latest native token
   * account balance.
   */
  getNativeTokenBalance(
    args: GetNativeTokenBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetNativeTokenBalanceReturn>
  /**
   * GetTokenBalances returns a balance summary/details for a specific account
   * on all indexer nodes. By default if accountAddress is left empty, it will
   * use the account from the jwt session.
   *
   * @deprecated Use GetTokenBalancesSummary or GetTokenBalancesDetails instead.
   */
  getTokenBalances(args: GetTokenBalancesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenBalancesReturn>
  /**
   * GetTokenBalancesByContract returns a balances for specific accounts and
   * contracts on all indexer nodes. The collection ERC721 & ERC1155 tokens are
   * represented as individual balances.
   */
  getTokenBalancesByContract(
    args: GetTokenBalancesByContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesByContractReturn>
  /**
   * GetTokenBalancesDetails returns a detailed balance summary for the given
   * accounts on all indexer nodes. The collection ERC721 & ERC1155 tokens are
   * represented as individual balances.
   */
  getTokenBalancesDetails(
    args: GetTokenBalancesDetailsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesDetailsReturn>
  /**
   * GetTokenBalancesSummary returns a summary of token balances for the given
   * accounts on all indexer nodes. The collection ERC721 & ERC1155 tokens are
   * represented as a single aggregated balance.
   */
  getTokenBalancesSummary(
    args: GetTokenBalancesSummaryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesSummaryReturn>
  /**
   * GetTransactionHistory returns the history of mined transactions for the
   * given account on all indexer nodes, which includes a list of token transfer
   * (sent/received) , and sent transactions from a Sequence wallet.
   */
  getTransactionHistory(
    args: GetTransactionHistoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTransactionHistoryReturn>
  /**
   * Ping the indexer
   */
  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>
  /**
   * Get the current runtime health status of the indexer gatewya
   */
  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>
  /**
   * Get the current version of the indexer
   */
  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>
}

export interface GetBalanceUpdatesArgs {
  chainIds?: Array<number>
  networks?: Array<string>
  networkType?: NetworkType
  contractAddress: string
  lastBlockNumber: number
  lastBlockHash?: string
  page?: Page
}

export interface GetBalanceUpdatesReturn {
  page: Page
  balances: Array<GatewayTokenBalance>
}
export interface GetChainsArgs {
  networkType?: NetworkType
}

export interface GetChainsReturn {
  chains: Array<ChainInfo>
}
export interface GetNativeTokenBalanceArgs {
  chainIds?: Array<number>
  networks?: Array<string>
  networkType?: NetworkType
  accountAddress?: string
  omitPrices?: boolean
}

export interface GetNativeTokenBalanceReturn {
  balances: Array<GatewayNativeTokenBalance>
}
export interface GetTokenBalancesArgs {
  chainIds?: Array<number>
  networks?: Array<string>
  networkType?: NetworkType
  accountAddress?: string
  contractAddress?: string
  tokenID?: string
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
  includeCollectionTokens?: boolean
  page?: Page
}

export interface GetTokenBalancesReturn {
  page: Page
  balances: Array<GatewayTokenBalance>
}
export interface GetTokenBalancesByContractArgs {
  chainIds?: Array<number>
  networks?: Array<string>
  networkType?: NetworkType
  filter: TokenBalancesByContractFilter
  omitMetadata?: boolean
  page?: Page
}

export interface GetTokenBalancesByContractReturn {
  page: Page
  balances: Array<GatewayTokenBalance>
}
export interface GetTokenBalancesDetailsArgs {
  chainIds?: Array<number>
  networks?: Array<string>
  networkType?: NetworkType
  filter: TokenBalancesFilter
  omitMetadata?: boolean
  page?: Page
}

export interface GetTokenBalancesDetailsReturn {
  page: Page
  nativeBalances: Array<GatewayNativeTokenBalances>
  balances: Array<GatewayTokenBalance>
}
export interface GetTokenBalancesSummaryArgs {
  chainIds?: Array<number>
  networks?: Array<string>
  networkType?: NetworkType
  filter: TokenBalancesFilter
  omitMetadata?: boolean
  page?: Page
}

export interface GetTokenBalancesSummaryReturn {
  page: Page
  nativeBalances: Array<GatewayNativeTokenBalances>
  balances: Array<GatewayTokenBalance>
}
export interface GetTransactionHistoryArgs {
  chainIds?: Array<number>
  networks?: Array<string>
  networkType?: NetworkType
  filter: TransactionHistoryFilter
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
  page?: Page
}

export interface GetTransactionHistoryReturn {
  page: Page
  transactions: Array<GatewayTransaction>
}
export interface PingArgs {}

export interface PingReturn {
  status: boolean
}
export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: GatewayRuntimeStatus
}
export interface VersionArgs {}

export interface VersionReturn {
  version: Version
}

//
// Client
//
export class IndexerGateway implements IndexerGateway {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/IndexerGateway/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  getBalanceUpdates = (args: GetBalanceUpdatesArgs, headers?: object, signal?: AbortSignal): Promise<GetBalanceUpdatesReturn> => {
    return this.fetch(this.url('GetBalanceUpdates'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            balances: <Array<GatewayTokenBalance>>_data.balances
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getChains = (args: GetChainsArgs, headers?: object, signal?: AbortSignal): Promise<GetChainsReturn> => {
    return this.fetch(this.url('GetChains'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            chains: <Array<ChainInfo>>_data.chains
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getNativeTokenBalance = (
    args: GetNativeTokenBalanceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetNativeTokenBalanceReturn> => {
    return this.fetch(this.url('GetNativeTokenBalance'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            balances: <Array<GatewayNativeTokenBalance>>_data.balances
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getTokenBalances = (args: GetTokenBalancesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenBalancesReturn> => {
    return this.fetch(this.url('GetTokenBalances'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            balances: <Array<GatewayTokenBalance>>_data.balances
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getTokenBalancesByContract = (
    args: GetTokenBalancesByContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesByContractReturn> => {
    return this.fetch(this.url('GetTokenBalancesByContract'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            balances: <Array<GatewayTokenBalance>>_data.balances
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getTokenBalancesDetails = (
    args: GetTokenBalancesDetailsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesDetailsReturn> => {
    return this.fetch(this.url('GetTokenBalancesDetails'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            nativeBalances: <Array<GatewayNativeTokenBalances>>_data.nativeBalances,
            balances: <Array<GatewayTokenBalance>>_data.balances
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getTokenBalancesSummary = (
    args: GetTokenBalancesSummaryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesSummaryReturn> => {
    return this.fetch(this.url('GetTokenBalancesSummary'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            nativeBalances: <Array<GatewayNativeTokenBalances>>_data.nativeBalances,
            balances: <Array<GatewayTokenBalance>>_data.balances
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getTransactionHistory = (
    args: GetTransactionHistoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTransactionHistoryReturn> => {
    return this.fetch(this.url('GetTransactionHistory'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            transactions: <Array<GatewayTransaction>>_data.transactions
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            status: <boolean>_data.status
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {
    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            status: <GatewayRuntimeStatus>_data.status
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {
    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            version: <Version>_data.version
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }
}

const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  reqHeaders[WebrpcHeader] = WebrpcHeaderValue

  return {
    method: 'POST',
    headers: reqHeaders,
    body: JSON.stringify(body || {}),
    signal
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      let message = ''
      if (error instanceof Error) {
        message = error.message
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

//
// Errors
//

export class WebrpcError extends Error {
  name: string
  code: number
  message: string
  status: number
  cause?: string

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string

  constructor(name: string, code: number, message: string, status: number, cause?: string) {
    super(message)
    this.name = name || 'WebrpcError'
    this.code = typeof code === 'number' ? code : 0
    this.message = message || `endpoint error ${this.code}`
    this.msg = this.message
    this.status = typeof status === 'number' ? status : 0
    this.cause = cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = 'WebrpcEndpoint',
    code: number = 0,
    message: string = `endpoint error`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcRequestFailed',
    code: number = -1,
    message: string = `request failed`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRoute',
    code: number = -2,
    message: string = `bad route`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadMethod',
    code: number = -3,
    message: string = `bad method`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRequest',
    code: number = -4,
    message: string = `bad request`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadResponse',
    code: number = -5,
    message: string = `bad response`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(
    name: string = 'WebrpcServerPanic',
    code: number = -6,
    message: string = `server panic`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(
    name: string = 'WebrpcInternalError',
    code: number = -7,
    message: string = `internal error`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcClientDisconnected',
    code: number = -8,
    message: string = `client disconnected`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(
    name: string = 'WebrpcStreamLost',
    code: number = -9,
    message: string = `stream lost`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcStreamFinished',
    code: number = -10,
    message: string = `stream finished`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

// Schema errors

export class AbortedError extends WebrpcError {
  constructor(
    name: string = 'Aborted',
    code: number = 1005,
    message: string = `Request aborted`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(
    name: string = 'AccessKeyMismatch',
    code: number = 1102,
    message: string = `Access key mismatch`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(
    name: string = 'AccessKeyNotFound',
    code: number = 1101,
    message: string = `Access key not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(
    name: string = 'AtLeastOneKey',
    code: number = 1302,
    message: string = `You need at least one Access Key`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(
    name: string = 'Geoblocked',
    code: number = 1006,
    message: string = `Geoblocked region`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(
    name: string = 'InvalidArgument',
    code: number = 2001,
    message: string = `Invalid argument`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(
    name: string = 'InvalidOrigin',
    code: number = 1103,
    message: string = `Invalid origin for Access Key`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(
    name: string = 'InvalidService',
    code: number = 1104,
    message: string = `Service not enabled for Access key`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(
    name: string = 'MaxAccessKeys',
    code: number = 1301,
    message: string = `Access keys limit reached`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class MetadataCallFailedError extends WebrpcError {
  constructor(
    name: string = 'MetadataCallFailed',
    code: number = 3003,
    message: string = `Metadata service call failed`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, MetadataCallFailedError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(
    name: string = 'MethodNotFound',
    code: number = 1003,
    message: string = `Method not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(
    name: string = 'NoDefaultKey',
    code: number = 1300,
    message: string = `No default access key found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(
    name: string = 'NotFound',
    code: number = 3000,
    message: string = `Resource not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(
    name: string = 'PermissionDenied',
    code: number = 1001,
    message: string = `Permission denied`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(
    name: string = 'ProjectNotFound',
    code: number = 1100,
    message: string = `Project not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
  constructor(
    name: string = 'QueryFailed',
    code: number = 2003,
    message: string = `Query failed`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(
    name: string = 'QuotaExceeded',
    code: number = 1200,
    message: string = `Quota exceeded`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class RateLimitError extends WebrpcError {
  constructor(
    name: string = 'RateLimit',
    code: number = 1201,
    message: string = `Rate limit exceeded`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, RateLimitError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(
    name: string = 'RateLimited',
    code: number = 1007,
    message: string = `Rate-limited. Please slow down.`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(
    name: string = 'RequestConflict',
    code: number = 1004,
    message: string = `Conflict with target resource`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class ResourceExhaustedError extends WebrpcError {
  constructor(
    name: string = 'ResourceExhausted',
    code: number = 2004,
    message: string = `Resource exhausted`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, ResourceExhaustedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(
    name: string = 'SessionExpired',
    code: number = 1002,
    message: string = `Session expired`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(
    name: string = 'Timeout',
    code: number = 1900,
    message: string = `Request timed out`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = 'Unauthorized',
    code: number = 1000,
    message: string = `Unauthorized access`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(
    name: string = 'UnauthorizedUser',
    code: number = 1105,
    message: string = `Unauthorized user`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class UnavailableError extends WebrpcError {
  constructor(
    name: string = 'Unavailable',
    code: number = 2002,
    message: string = `Unavailable resource`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnavailableError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientDisconnected = 'WebrpcClientDisconnected',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Aborted = 'Aborted',
  AccessKeyMismatch = 'AccessKeyMismatch',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AtLeastOneKey = 'AtLeastOneKey',
  Geoblocked = 'Geoblocked',
  InvalidArgument = 'InvalidArgument',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  MaxAccessKeys = 'MaxAccessKeys',
  MetadataCallFailed = 'MetadataCallFailed',
  MethodNotFound = 'MethodNotFound',
  NoDefaultKey = 'NoDefaultKey',
  NotFound = 'NotFound',
  PermissionDenied = 'PermissionDenied',
  ProjectNotFound = 'ProjectNotFound',
  QueryFailed = 'QueryFailed',
  QuotaExceeded = 'QuotaExceeded',
  RateLimit = 'RateLimit',
  RateLimited = 'RateLimited',
  RequestConflict = 'RequestConflict',
  ResourceExhausted = 'ResourceExhausted',
  SessionExpired = 'SessionExpired',
  Timeout = 'Timeout',
  Unauthorized = 'Unauthorized',
  UnauthorizedUser = 'UnauthorizedUser',
  Unavailable = 'Unavailable'
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientDisconnected = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Aborted = 1005,
  AccessKeyMismatch = 1102,
  AccessKeyNotFound = 1101,
  AtLeastOneKey = 1302,
  Geoblocked = 1006,
  InvalidArgument = 2001,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  MaxAccessKeys = 1301,
  MetadataCallFailed = 3003,
  MethodNotFound = 1003,
  NoDefaultKey = 1300,
  NotFound = 3000,
  PermissionDenied = 1001,
  ProjectNotFound = 1100,
  QueryFailed = 2003,
  QuotaExceeded = 1200,
  RateLimit = 1201,
  RateLimited = 1007,
  RequestConflict = 1004,
  ResourceExhausted = 2004,
  SessionExpired = 1002,
  Timeout = 1900,
  Unauthorized = 1000,
  UnauthorizedUser = 1105,
  Unavailable = 2002
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1005]: AbortedError,
  [1102]: AccessKeyMismatchError,
  [1101]: AccessKeyNotFoundError,
  [1302]: AtLeastOneKeyError,
  [1006]: GeoblockedError,
  [2001]: InvalidArgumentError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1301]: MaxAccessKeysError,
  [3003]: MetadataCallFailedError,
  [1003]: MethodNotFoundError,
  [1300]: NoDefaultKeyError,
  [3000]: NotFoundError,
  [1001]: PermissionDeniedError,
  [1100]: ProjectNotFoundError,
  [2003]: QueryFailedError,
  [1200]: QuotaExceededError,
  [1201]: RateLimitError,
  [1007]: RateLimitedError,
  [1004]: RequestConflictError,
  [2004]: ResourceExhaustedError,
  [1002]: SessionExpiredError,
  [1900]: TimeoutError,
  [1000]: UnauthorizedError,
  [1105]: UnauthorizedUserError,
  [2002]: UnavailableError
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
