/* eslint-disable */
// sequence-indexer v0.4.0 1532960ee7a152a172fcfb97cdc150b16c7dc297
// --
// Code generated by Webrpc-gen@v0.31.2 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=merged.gen.json -service=Indexer -target=typescript -client -out=./clients/indexer.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = 'v1'

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = '1532960ee7a152a172fcfb97cdc150b16c7dc297'

//
// Client interface
//

export interface IndexerClient {
  addWebhookListener(req: AddWebhookListenerRequest, headers?: object, signal?: AbortSignal): Promise<AddWebhookListenerResponse>

  /**
   * Fetches a single receipt and then will stop the subscription
   */
  fetchTransactionReceipt(
    req: FetchTransactionReceiptRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FetchTransactionReceiptResponse>

  /**
   * Fetches a single receipt with filter and then will stop the subscription
   */
  fetchTransactionReceiptWithFilter(
    req: FetchTransactionReceiptWithFilterRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FetchTransactionReceiptWithFilterResponse>

  /**
   * Webhooks
   */
  getAllWebhookListeners(
    req: GetAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAllWebhookListenersResponse>

  /**
   * Get balance update aggregate values -- useful for syncing balance details of a contract, ie. from Skyweaver.
   * Also consider using SubscribeBalanceUpdates or SubscribeEvents as other alternatives.
   */
  getBalanceUpdates(req: GetBalanceUpdatesRequest, headers?: object, signal?: AbortSignal): Promise<GetBalanceUpdatesResponse>

  /**
   * Get the chain ID of the indexer
   */
  getChainID(headers?: object, signal?: AbortSignal): Promise<GetChainIDResponse>

  /**
   * Queries an ethereum node for the latest and confirm ETH balances
   * DEPRECATED: use GetNativeTokenBalance instead
   *
   * @deprecated GetNativeTokenBalance
   */
  getEtherBalance(req: GetEtherBalanceRequest, headers?: object, signal?: AbortSignal): Promise<GetEtherBalanceResponse>

  /**
   * GetMarketplaceOrders queries marketplace orders with filtering and pagination.
   *
   * Retrieves buy orders (offers) and sell orders (listings) from a specific marketplace
   * and collection with comprehensive filtering options.
   *
   * Parameters:
   * marketplaceContractAddress: Target marketplace contract (required)
   * collectionAddress: NFT collection contract (required)
   * filter: MarketplaceOrderFilter with options:
   * - isListing: true=listings, false=offers, omit=both
   * - userAddresses: Include specific users
   * - currencyAddresses: Filter by currencies (empty=all)
   * - orderIds: Filter by specific order ids (empty=all)
   * - tokenIds: Filter by specific tokens (empty=all)
   * - excludeUserAddresses: Exclude specific users
   * - blockNumberGt: Orders greater than block number
   * - createdAtAfter: Orders after timestamp
   * - orderStatuses: Filter by status (OPEN, CLOSED, CANCELLED)
   * - returnExpired: Include expired orders
   * page: Pagination control (optional)
   *
   * Returns: Updated pagination info and array of matching orders
   */
  getMarketplaceOrders(
    req: GetMarketplaceOrdersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketplaceOrdersResponse>

  /**
   * GetMarketplaceTopOrders finds the most competitive orders for specific tokens.
   *
   * Optimized for price discovery, returns the best available orders for each token.
   * Useful for displaying current market prices and finding trading opportunities.
   *
   * Parameters:
   * marketplaceContractAddress: Target marketplace contract (required)
   * collectionAddress: NFT collection contract (required)
   * filter: MarketplaceTopOrdersFilter with options:
   * - currencyAddresses: Consider specific currencies (empty=all)
   * - tokenIds: Target token IDs (required, non-empty)
   * - isListing: true=listings/sell orders, false=offers/buy orders
   * - priceSort: ASC=lowest first, DESC=highest first
   * - excludeUser: Hide orders from specific user
   *
   * Returns: Array of top-priced active orders, sorted by priceSort preference
   */
  getMarketplaceTopOrders(
    req: GetMarketplaceTopOrdersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketplaceTopOrdersResponse>

  /**
   * GetNativeTokenBalance queries an ethereum node for the latest native token account balance.
   * The native token is the token of the chain the indexer is connected to, for example, ETH on Ethereum
   * and POL on Polygon.
   */
  getNativeTokenBalance(
    req: GetNativeTokenBalanceRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetNativeTokenBalanceResponse>

  getPrices(req: GetPricesRequest, headers?: object, signal?: AbortSignal): Promise<GetPricesResponse>

  /**
   * GetTokenBalances returns a balance summary/details for a specific account. By default
   * if accountAddress is left empty, it will use the account from the jwt session.
   *
   * Also, if contractAddress is undefined, then it will list all current user coins/collectibles.
   * But, if contractAddress is provided, then it will return the token balances for the contract, this is
   * only useful for 1155, but for other tokens, it can act as a filter for the single balance.
   *
   * DEPRECATED: use GetTokenBalancesSummary / GetTokenBalancesDetails
   *
   * @deprecated GetTokenBalancesSummary
   */
  getTokenBalances(req: GetTokenBalancesRequest, headers?: object, signal?: AbortSignal): Promise<GetTokenBalancesResponse>

  /**
   * GetTokenBalancesByContract returns a balances for a specific accounts and
   * contracts. The collection ERC721 & ERC1155 tokens are represented as
   * individual balances.
   *
   * If `filter` is not provided, it will error out as it requires at least
   * contract address.
   *
   * If `filter.contractStatus` is not provided, it will include verified only
   * tokens.
   */
  getTokenBalancesByContract(
    req: GetTokenBalancesByContractRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesByContractResponse>

  /**
   * GetTokenBalancesDetails returns a detailed balance summary for a specific
   * accounts. The collection ERC721 & ERC1155 tokens are represented as
   * individual balances.
   *
   * If `filter` is not provided, it will use the filter with account from the
   * jwt session.
   *
   * If `filter.contractStatus` is not provided, it will include verified only
   * tokens.
   */
  getTokenBalancesDetails(
    req: GetTokenBalancesDetailsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesDetailsResponse>

  /**
   * GetTokenBalancesSummary returns a summary of token balances for a specific
   * accounts. The collection ERC721 & ERC1155 tokens are represented as a
   * single aggregated balance.
   *
   * If `filter` is not provided, it will use the filter with account from the
   * jwt session.
   *
   * If `filter.contractStatus` is not provided, it will include verified only
   * tokens.
   */
  getTokenBalancesSummary(
    req: GetTokenBalancesSummaryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesSummaryResponse>

  /**
   * GetTokenIDRanges returns the range of tokenIDs for a token collection contract.
   * This is useful for ERC-721 and ERC-1155 contracts to get the range of valid tokenIDs. It is similar to
   * GetTokenIDs, but returns the range of tokenIDs instead of the list of tokenIDs, which is more efficient
   * for large collections and very easy to the caller to expand the range into a list of tokenIDs.
   *
   * NOTE: this method will only return up to 15,000 ranges, if there are more ranges, it will return
   * a boolean to indicate there are more ranges beyond the first 15,000. Therefore, if `moreRanges` is
   * false then you have all the ranges, but if true, you need to make a follow up call to fetch the next
   * page of ranges.
   *
   * As an example, if a NFT collection of 100,000 tokens uses ids from 1,2,3,...,100_000 then this endpoint
   * will return just a single range from [1,100_000], but if there are gaps between the sequence, then
   * those will be broken into separate range entries.
   */
  getTokenIDRanges(req: GetTokenIDRangesRequest, headers?: object, signal?: AbortSignal): Promise<GetTokenIDRangesResponse>

  /**
   * GetTokenIDs returns the list of each individual token id for a token collection contract.
   * This is useful for ERC-721 and ERC-1155 contracts to get the list of valid tokenIDs.
   */
  getTokenIDs(req: GetTokenIDsRequest, headers?: object, signal?: AbortSignal): Promise<GetTokenIDsResponse>

  /**
   * GetTokenSupplies returns the set of tokenIDs used by a contract address, supporting ERC-20, ERC-721, and ERC-1155
   * contracts, and their respective supply as well.
   */
  getTokenSupplies(req: GetTokenSuppliesRequest, headers?: object, signal?: AbortSignal): Promise<GetTokenSuppliesResponse>

  /**
   * GetTokenSuppliesMap returns the token supplies of ERC-20 and ERC-1155 tokens as requested in the `tokenMap`
   * represented as a map of contractAddress :: []tokenIDs.
   *
   * For an ERC-20 specify tokenIDs as an empty array or [0], for example, { '0xdef': [] } or { '0xdef': [0] }
   * For ERC-1155 pass the array of tokens are strings, ie. { '0xabc': ['1', '2', '3'] }
   */
  getTokenSuppliesMap(
    req: GetTokenSuppliesMapRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenSuppliesMapResponse>

  /**
   * History of mined transactions for the account which includes a list of token transfers (sent/recieved)
   * and sent transactions from a Sequence wallet
   */
  getTransactionHistory(
    req: GetTransactionHistoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTransactionHistoryResponse>

  getWebhookListener(req: GetWebhookListenerRequest, headers?: object, signal?: AbortSignal): Promise<GetWebhookListenerResponse>

  pauseAllWebhookListeners(
    req: PauseAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<PauseAllWebhookListenersResponse>

  /**
   * Ping the indexer
   */
  ping(headers?: object, signal?: AbortSignal): Promise<PingResponse>

  removeAllWebhookListeners(
    req: RemoveAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveAllWebhookListenersResponse>

  removeWebhookListener(
    req: RemoveWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveWebhookListenerResponse>

  resumeAllWebhookListeners(
    req: ResumeAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ResumeAllWebhookListenersResponse>

  /**
   * Get the current runtime health status of the indexer
   */
  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse>

  /**
   * SubscribeBalanceUpdates listens to balance updates for a specific contract address
   */
  subscribeBalanceUpdates(
    req: SubscribeBalanceUpdatesRequest,
    options: WebrpcStreamOptions<SubscribeBalanceUpdatesResponse>
  ): WebrpcStreamController

  /**
   * SubscribeEvents listens to events on-chain based on the filter criteria
   *
   * TODO: some additional options can be passed such as block, reorg true, etc.
   * or stay behind, etc.
   */
  subscribeEvents(req: SubscribeEventsRequest, options: WebrpcStreamOptions<SubscribeEventsResponse>): WebrpcStreamController

  /**
   * Listen to transaction receipts on-chain based on the filter criteria
   */
  subscribeReceipts(
    req: SubscribeReceiptsRequest,
    options: WebrpcStreamOptions<SubscribeReceiptsResponse>
  ): WebrpcStreamController

  /**
   * Re-sync an incorrect token balance with the correct on-chain balance
   * NOTE: this method is almost never used, but we've marked it internal in case
   * we ever want to use it again. This method was written a very long time ago in
   * scenarios when the indexer had little bugs, but now its solid.
   */
  syncBalance(req: SyncBalanceRequest, headers?: object, signal?: AbortSignal): Promise<SyncBalanceResponse>

  toggleWebhookListener(
    req: ToggleWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ToggleWebhookListenerResponse>

  updateWebhookListener(
    req: UpdateWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateWebhookListenerResponse>

  /**
   * Get the current version of the indexer
   */
  version(headers?: object, signal?: AbortSignal): Promise<VersionResponse>
}

//
// Schema types
//

export interface Asset {
  id: number
  collectionId: number
  tokenId?: string
  url?: string
  metadataField: string
  name?: string
  filesize?: number
  mimeType?: string
  width?: number
  height?: number
  updatedAt?: string
}

export interface BloomStats {
  hitRatio: string
  falsePositivesPercent: string
  hitCount: number
  missCount: number
  falsePositives: number
}

export interface BloomStatus {
  enabled: boolean
  initialized: boolean
  bloomInitElapsedTime: string
  stats: BloomStats
}

export interface Bond {
  pebble: PebbleMetrics
  estimatedDiskUsagePerTable: any
  estimatedDiskUsageTotal: string
}

export interface ChainInfo {
  chainId: number
  chainName: string
}

export interface ContractInfo {
  chainId: number
  address: string
  source: string
  name: string
  type: string
  symbol: string
  decimals?: number
  logoURI: string
  deployed: boolean
  bytecodeHash: string
  extensions: ContractInfoExtensions
  updatedAt: string
  queuedAt?: string
  status: ResourceStatus
}

export interface ContractInfoExtensionBridgeInfo {
  tokenAddress: string
}

export interface ContractInfoExtensionIndexingInfo {
  useOnChainBalance: boolean
}

export interface ContractInfoExtensions {
  link?: string
  description?: string
  categories?: Array<string>
  bridgeInfo?: { [key: string]: ContractInfoExtensionBridgeInfo }
  indexingInfo?: ContractInfoExtensionIndexingInfo
  ogImage?: string
  ogName?: string
  originChainId?: number
  originAddress?: string
  blacklist?: boolean
  verified?: boolean
  verifiedBy?: string
  featured?: boolean
  featureIndex?: number
}

export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  NATIVE = 'NATIVE',
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155',
  SEQUENCE_WALLET = 'SEQUENCE_WALLET',
  ERC20_BRIDGE = 'ERC20_BRIDGE',
  ERC721_BRIDGE = 'ERC721_BRIDGE',
  ERC1155_BRIDGE = 'ERC1155_BRIDGE',
  SEQ_MARKETPLACE = 'SEQ_MARKETPLACE',
  ERC6909 = 'ERC6909'
}

export enum ContractVerificationStatus {
  VERIFIED = 'VERIFIED',
  UNVERIFIED = 'UNVERIFIED',
  ALL = 'ALL'
}

export interface DiskUsage {
  humanReadable: string
  used: number
  size: number
  percent: number
  dirs: { [key: string]: string }
}

export interface EtherBalance {
  accountAddress: string
  balanceWei: string
}

export interface EventDecoded {
  topicHash: string
  eventSig: string
  types: Array<string>
  names: Array<string>
  values: Array<string>
}

export interface EventFilter {
  events?: Array<string>
  contractAddresses?: Array<string>
  accounts?: Array<string>
  tokenIDs?: Array<string>
}

export interface EventLog {
  id: number
  uid: string
  type: EventLogType
  blockNumber: number
  blockHash: string
  parentBlockHash: string
  contractAddress: string
  contractType: ContractType
  txnHash: string
  txnIndex: number
  txnLogIndex: number
  logDataType: EventLogDataType
  ts: string
  txnInfo?: TxnInfo
  rawLog?: { [key: string]: any }
  event?: EventDecoded
}

export enum EventLogDataType {
  EVENT = 'EVENT',
  TOKEN_TRANSFER = 'TOKEN_TRANSFER',
  NATIVE_TOKEN_TRANSFER = 'NATIVE_TOKEN_TRANSFER',
  SEQUENCE_TXN = 'SEQUENCE_TXN'
}

export enum EventLogType {
  UNKNOWN = 'UNKNOWN',
  BLOCK_ADDED = 'BLOCK_ADDED',
  BLOCK_REMOVED = 'BLOCK_REMOVED'
}

export interface GatewayBackendResponseTime {
  percentiles: { [key: string]: number }
  average: number
}

export interface GatewayBackendRuntimeStatus {
  name: string
  chainId: number
  responseTime: GatewayBackendResponseTime
}

export interface GatewayEtherBalance {
  chainId: number
  errorReason?: string
  result: EtherBalance
}

export interface GatewayNativeTokenBalance {
  chainId: number
  errorReason?: string
  result: NativeTokenBalance
}

export interface GatewayNativeTokenBalances {
  chainId: number
  errorReason?: string
  results: Array<NativeTokenBalance>
}

export interface GatewayRuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  backends: Array<GatewayBackendRuntimeStatus>
}

export interface GatewayTokenBalance {
  chainId: number
  errorReason?: string
  results: Array<TokenBalance>
}

export interface GatewayTransaction {
  chainId: number
  errorReason?: string
  results: Array<Transaction>
}

export interface IndexState {
  chainId: string
  lastBlockNum: number
  lastBlockHash: string
}

export interface IndexedBlock {
  blockNumber: number
  blockShortHash: string
}

export interface IndexerMetrics {
  blocksPerSecond: number
  eventsPerSecond: number
}

export interface MarketplaceOrder {
  orderId: string
  tokenContract: string
  tokenId: string
  isListing: boolean
  quantity: string
  quantityRemaining: string
  currencyAddress: string
  pricePerToken: string
  expiry: string
  orderStatus: OrderStatus
  createdBy: string
  blockNumber: number
  orderbookContractAddress: string
  createdAt: number
}

export interface MarketplaceOrderFilter {
  isListing?: boolean
  userAddresses?: Array<string>
  currencyAddresses: Array<string>
  orderIds: Array<string>
  tokenIds: Array<string>
  excludeUserAddresses?: Array<string>
  blockNumberGt: number
  createdAtAfter: number
  orderStatuses: Array<OrderStatus>
  returnExpired: boolean
}

export interface MarketplaceTopOrdersFilter {
  currencyAddresses: Array<string>
  tokenIds: Array<string>
  isListing: boolean
  priceSort: SortOrder
  excludeUser?: string
}

export interface MetadataOptions {
  verifiedOnly?: boolean
  unverifiedOnly?: boolean
  includeContracts?: Array<string>
}

export interface NativeTokenBalance {
  accountAddress: string
  chainId: number
  name: string
  symbol: string
  balance: string
  balanceUSD: string
  priceUSD: string
  errorReason?: string
}

export enum NetworkType {
  MAINNETS = 'MAINNETS',
  TESTNETS = 'TESTNETS',
  ALL = 'ALL'
}

export enum OrderStatus {
  OPEN = 'OPEN',
  CLOSED = 'CLOSED',
  CANCELLED = 'CANCELLED'
}

export interface Page {
  page?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
  pageSize?: number
  more?: boolean
}

export interface PebbleMetrics {
  compactionCount: number
  compactionEstimatedDebt: number
  compactionInProgressBytes: number
  compactionNumInProgress: number
  compactionMarkedFiles: number
}

export interface Price {
  contractAddress: string
  tokenID?: string
  priceUSD: string
}

export enum ResourceStatus {
  NOT_AVAILABLE = 'NOT_AVAILABLE',
  REFRESHING = 'REFRESHING',
  AVAILABLE = 'AVAILABLE'
}

export interface RuntimeChecks {
  running: boolean
  runnables: any
  cgoEnabled: boolean
  quotaControlEnabled: boolean
  syncMode: string
  percentIndexed: number
  lastBlockNum: number
  lastBlockNumWithState: number
  bloomStatus: BloomStatus
  bond: Bond
  diskUsage: DiskUsage
  metrics: IndexerMetrics
}

export interface RuntimeStatus {
  healthOK: boolean
  indexerEnabled: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  chainID: number
  checks: RuntimeChecks
}

export interface SortBy {
  column: string
  order: SortOrder
}

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export interface TokenBalance {
  contractType: ContractType
  contractAddress: string
  accountAddress: string
  tokenID?: string
  balance: string
  balanceUSD: string
  priceUSD: string
  blockHash: string
  blockNumber: number
  chainId: number
  uniqueCollectibles: string
  isSummary: boolean
  contractInfo?: ContractInfo
  tokenMetadata?: TokenMetadata
}

export interface TokenBalanceFilter {
  contractAddress: string
  sinceBlockNumber: number
}

export interface TokenBalancesByContractFilter {
  contractAddresses: Array<string>
  accountAddresses?: Array<string>
  contractStatus?: ContractVerificationStatus
}

export interface TokenBalancesFilter {
  accountAddresses: Array<string>
  contractStatus?: ContractVerificationStatus
  contractTypes?: Array<string>
  contractWhitelist?: Array<string>
  contractBlacklist?: Array<string>
  omitNativeBalances: boolean
  omitPrices?: boolean
}

export interface TokenHistory {
  blockNumber: number
  blockHash: string
  contractAddress: string
  contractType: ContractType
  fromAddress: string
  toAddress: string
  txnHash: string
  txnIndex: number
  txnLogIndex: number
  tokenIDs: string
  amounts: string
  ts: string
}

export interface TokenIDRange {
  start: string
  end: string
}

export interface TokenMetadata {
  chainId?: number
  contractAddress?: string
  tokenId: string
  source: string
  name: string
  description?: string
  image?: string
  video?: string
  audio?: string
  properties?: { [key: string]: any }
  attributes: Array<{ [key: string]: any }>
  image_data?: string
  external_url?: string
  background_color?: string
  animation_url?: string
  decimals?: number
  updatedAt?: string
  assets?: Array<Asset>
  status: ResourceStatus
  queuedAt?: string
  lastFetched?: string
}

export interface TokenSupply {
  tokenID: string
  supply: string
  chainId: number
  contractInfo?: ContractInfo
  tokenMetadata?: TokenMetadata
}

export interface Transaction {
  txnHash: string
  blockNumber: number
  blockHash: string
  chainId: number
  metaTxnID?: string
  transfers?: Array<TxnTransfer>
  timestamp: string
}

export interface TransactionFilter {
  txnHash?: string
  from?: string
  to?: string
  contractAddress?: string
  event?: string
}

export interface TransactionHistoryFilter {
  accountAddress?: string
  contractAddress?: string
  accountAddresses?: Array<string>
  contractAddresses?: Array<string>
  transactionHashes?: Array<string>
  metaTransactionIDs?: Array<string>
  fromBlock?: number
  toBlock?: number
  tokenID?: string
  omitPrices?: boolean
}

export interface TransactionLog {
  contractAddress: string
  topics: Array<string>
  data: string
  index: number
}

export interface TransactionReceipt {
  txnHash: string
  txnStatus: TransactionStatus
  txnIndex: number
  txnType: TransactionType
  blockHash: string
  blockNumber: number
  gasUsed: number
  effectiveGasPrice: string
  from: string
  to: string
  logs: Array<TransactionLog>
  final: boolean
  reorged: boolean
}

export enum TransactionStatus {
  FAILED = 'FAILED',
  SUCCESSFUL = 'SUCCESSFUL'
}

export enum TransactionType {
  LegacyTxnType = 'LegacyTxnType',
  AccessListTxnType = 'AccessListTxnType',
  DynamicFeeTxnType = 'DynamicFeeTxnType'
}

export interface TxnInfo {
  from: string
  to: string
  value: string
}

export interface TxnTransfer {
  transferType: TxnTransferType
  contractAddress: string
  contractType: ContractType
  from: string
  to: string
  tokenIds?: Array<string>
  amounts: Array<string>
  logIndex: number
  amountsUSD?: Array<string>
  pricesUSD?: Array<string>
  contractInfo?: ContractInfo
  tokenMetadata?: { [key: string]: TokenMetadata }
}

export enum TxnTransferType {
  UNKNOWN = 'UNKNOWN',
  SEND = 'SEND',
  RECEIVE = 'RECEIVE'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface WALWriterRuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  chainID: number
  percentWALWritten: number
}

export interface WebhookListener {
  id: number
  projectID: number
  url: string
  filters: EventFilter
  name: string
  updatedAt: string
  active: boolean
}

export interface AddWebhookListenerRequest {
  url: string
  filters: EventFilter
  projectId?: number
}

export interface AddWebhookListenerResponse {
  status: boolean
  listener: WebhookListener
}

export interface FetchTransactionReceiptRequest {
  txnHash: string
  maxBlockWait?: number
}

export interface FetchTransactionReceiptResponse {
  receipt: TransactionReceipt
}

export interface FetchTransactionReceiptWithFilterRequest {
  filter: TransactionFilter
  maxBlockWait?: number
}

export interface FetchTransactionReceiptWithFilterResponse {
  receipt: TransactionReceipt
}

export interface GetAllWebhookListenersRequest {
  projectId?: number
}

export interface GetAllWebhookListenersResponse {
  listeners: Array<WebhookListener>
}

export interface GetBalanceUpdatesRequest {
  contractAddress: string
  lastBlockNumber: number
  lastBlockHash?: string
  page?: Page
}

export interface GetBalanceUpdatesResponse {
  page: Page
  balances: Array<TokenBalance>
}

export interface GetChainIDRequest {}

export interface GetChainIDResponse {
  chainID: number
}

export interface GetEtherBalanceRequest {
  accountAddress?: string
}

export interface GetEtherBalanceResponse {
  balance: EtherBalance
}

export interface GetMarketplaceOrdersRequest {
  marketplaceContractAddress: string
  collectionAddress: string
  filter?: MarketplaceOrderFilter
  page?: Page
}

export interface GetMarketplaceOrdersResponse {
  page?: Page
  orders: Array<MarketplaceOrder>
}

export interface GetMarketplaceTopOrdersRequest {
  marketplaceContractAddress: string
  collectionAddress: string
  filter: MarketplaceTopOrdersFilter
}

export interface GetMarketplaceTopOrdersResponse {
  orders: Array<MarketplaceOrder>
}

export interface GetNativeTokenBalanceRequest {
  accountAddress?: string
  omitPrices?: boolean
}

export interface GetNativeTokenBalanceResponse {
  balance: NativeTokenBalance
}

export interface GetPricesRequest {
  page?: Page
}

export interface GetPricesResponse {
  page: Page
  prices: Array<Price>
}

export interface GetTokenBalancesRequest {
  accountAddress?: string
  contractAddress?: string
  tokenID?: string
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
  includeCollectionTokens?: boolean
  page?: Page
}

export interface GetTokenBalancesResponse {
  page: Page
  balances: Array<TokenBalance>
}

export interface GetTokenBalancesByContractRequest {
  filter: TokenBalancesByContractFilter
  omitMetadata?: boolean
  page?: Page
}

export interface GetTokenBalancesByContractResponse {
  page: Page
  balances: Array<TokenBalance>
}

export interface GetTokenBalancesDetailsRequest {
  filter: TokenBalancesFilter
  omitMetadata?: boolean
  page?: Page
}

export interface GetTokenBalancesDetailsResponse {
  page: Page
  nativeBalances: Array<NativeTokenBalance>
  balances: Array<TokenBalance>
}

export interface GetTokenBalancesSummaryRequest {
  filter: TokenBalancesFilter
  omitMetadata?: boolean
  page?: Page
}

export interface GetTokenBalancesSummaryResponse {
  page: Page
  nativeBalances: Array<NativeTokenBalance>
  balances: Array<TokenBalance>
}

export interface GetTokenIDRangesRequest {
  contractAddress: string
  lastTokenID?: string
}

export interface GetTokenIDRangesResponse {
  contractType: ContractType
  tokenIDRanges: Array<TokenIDRange>
  moreRanges: boolean
}

export interface GetTokenIDsRequest {
  contractAddress: string
  page?: Page
}

export interface GetTokenIDsResponse {
  page: Page
  contractType: ContractType
  tokenIDs: Array<string>
}

export interface GetTokenSuppliesRequest {
  contractAddress: string
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
  page?: Page
}

export interface GetTokenSuppliesResponse {
  page: Page
  contractType: ContractType
  tokenIDs: Array<TokenSupply>
}

export interface GetTokenSuppliesMapRequest {
  tokenMap: { [key: string]: Array<string> }
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
}

export interface GetTokenSuppliesMapResponse {
  supplies: { [key: string]: Array<TokenSupply> }
}

export interface GetTransactionHistoryRequest {
  filter: TransactionHistoryFilter
  page?: Page
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
}

export interface GetTransactionHistoryResponse {
  page: Page
  transactions: Array<Transaction>
}

export interface GetWebhookListenerRequest {
  id: number
  projectId?: number
}

export interface GetWebhookListenerResponse {
  listener: WebhookListener
}

export interface PauseAllWebhookListenersRequest {
  projectId?: number
}

export interface PauseAllWebhookListenersResponse {
  status: boolean
}

export interface PingRequest {}

export interface PingResponse {
  status: boolean
}

export interface RemoveAllWebhookListenersRequest {
  projectId?: number
}

export interface RemoveAllWebhookListenersResponse {
  status: boolean
}

export interface RemoveWebhookListenerRequest {
  id: number
  projectId?: number
}

export interface RemoveWebhookListenerResponse {
  status: boolean
}

export interface ResumeAllWebhookListenersRequest {
  projectId?: number
}

export interface ResumeAllWebhookListenersResponse {
  status: boolean
}

export interface RuntimeStatusRequest {}

export interface RuntimeStatusResponse {
  status: RuntimeStatus
}

export interface SubscribeBalanceUpdatesRequest {
  contractAddress: string
}

export interface SubscribeBalanceUpdatesResponse {
  balance: TokenBalance
}

export interface SubscribeEventsRequest {
  filter: EventFilter
}

export interface SubscribeEventsResponse {
  log: EventLog
}

export interface SubscribeReceiptsRequest {
  filter: TransactionFilter
}

export interface SubscribeReceiptsResponse {
  receipt: TransactionReceipt
}

export interface SyncBalanceRequest {
  accountAddress: string
  contractAddress: string
  tokenID?: string
}

export interface SyncBalanceResponse {}

export interface ToggleWebhookListenerRequest {
  id: number
  projectId?: number
}

export interface ToggleWebhookListenerResponse {
  webhookListener: WebhookListener
}

export interface UpdateWebhookListenerRequest {
  listener: WebhookListener
  projectId?: number
}

export interface UpdateWebhookListenerResponse {
  status: boolean
}

export interface VersionRequest {}

export interface VersionResponse {
  version: Version
}

//
// Client
//

export class Indexer implements IndexerClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Indexer/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  queryKey = {
    addWebhookListener: (req: AddWebhookListenerRequest) => ['Indexer', 'addWebhookListener', req] as const,
    fetchTransactionReceipt: (req: FetchTransactionReceiptRequest) => ['Indexer', 'fetchTransactionReceipt', req] as const,
    fetchTransactionReceiptWithFilter: (req: FetchTransactionReceiptWithFilterRequest) =>
      ['Indexer', 'fetchTransactionReceiptWithFilter', req] as const,
    getAllWebhookListeners: (req: GetAllWebhookListenersRequest) => ['Indexer', 'getAllWebhookListeners', req] as const,
    getBalanceUpdates: (req: GetBalanceUpdatesRequest) => ['Indexer', 'getBalanceUpdates', req] as const,
    getChainID: () => ['Indexer', 'getChainID'] as const,
    getEtherBalance: (req: GetEtherBalanceRequest) => ['Indexer', 'getEtherBalance', req] as const,
    getMarketplaceOrders: (req: GetMarketplaceOrdersRequest) => ['Indexer', 'getMarketplaceOrders', req] as const,
    getMarketplaceTopOrders: (req: GetMarketplaceTopOrdersRequest) => ['Indexer', 'getMarketplaceTopOrders', req] as const,
    getNativeTokenBalance: (req: GetNativeTokenBalanceRequest) => ['Indexer', 'getNativeTokenBalance', req] as const,
    getPrices: (req: GetPricesRequest) => ['Indexer', 'getPrices', req] as const,
    getTokenBalances: (req: GetTokenBalancesRequest) => ['Indexer', 'getTokenBalances', req] as const,
    getTokenBalancesByContract: (req: GetTokenBalancesByContractRequest) =>
      ['Indexer', 'getTokenBalancesByContract', req] as const,
    getTokenBalancesDetails: (req: GetTokenBalancesDetailsRequest) => ['Indexer', 'getTokenBalancesDetails', req] as const,
    getTokenBalancesSummary: (req: GetTokenBalancesSummaryRequest) => ['Indexer', 'getTokenBalancesSummary', req] as const,
    getTokenIDRanges: (req: GetTokenIDRangesRequest) => ['Indexer', 'getTokenIDRanges', req] as const,
    getTokenIDs: (req: GetTokenIDsRequest) => ['Indexer', 'getTokenIDs', req] as const,
    getTokenSupplies: (req: GetTokenSuppliesRequest) => ['Indexer', 'getTokenSupplies', req] as const,
    getTokenSuppliesMap: (req: GetTokenSuppliesMapRequest) => ['Indexer', 'getTokenSuppliesMap', req] as const,
    getTransactionHistory: (req: GetTransactionHistoryRequest) => ['Indexer', 'getTransactionHistory', req] as const,
    getWebhookListener: (req: GetWebhookListenerRequest) => ['Indexer', 'getWebhookListener', req] as const,
    pauseAllWebhookListeners: (req: PauseAllWebhookListenersRequest) => ['Indexer', 'pauseAllWebhookListeners', req] as const,
    ping: () => ['Indexer', 'ping'] as const,
    removeAllWebhookListeners: (req: RemoveAllWebhookListenersRequest) => ['Indexer', 'removeAllWebhookListeners', req] as const,
    removeWebhookListener: (req: RemoveWebhookListenerRequest) => ['Indexer', 'removeWebhookListener', req] as const,
    resumeAllWebhookListeners: (req: ResumeAllWebhookListenersRequest) => ['Indexer', 'resumeAllWebhookListeners', req] as const,
    runtimeStatus: () => ['Indexer', 'runtimeStatus'] as const,
    subscribeBalanceUpdates: (req: SubscribeBalanceUpdatesRequest) => ['Indexer', 'subscribeBalanceUpdates', req] as const,
    subscribeEvents: (req: SubscribeEventsRequest) => ['Indexer', 'subscribeEvents', req] as const,
    subscribeReceipts: (req: SubscribeReceiptsRequest) => ['Indexer', 'subscribeReceipts', req] as const,
    syncBalance: (req: SyncBalanceRequest) => ['Indexer', 'syncBalance', req] as const,
    toggleWebhookListener: (req: ToggleWebhookListenerRequest) => ['Indexer', 'toggleWebhookListener', req] as const,
    updateWebhookListener: (req: UpdateWebhookListenerRequest) => ['Indexer', 'updateWebhookListener', req] as const,
    version: () => ['Indexer', 'version'] as const
  }

  addWebhookListener = (
    req: AddWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<AddWebhookListenerResponse> => {
    return this.fetch(this.url('AddWebhookListener'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<AddWebhookListenerResponse>(_data, 'AddWebhookListenerResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  fetchTransactionReceipt = (
    req: FetchTransactionReceiptRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FetchTransactionReceiptResponse> => {
    return this.fetch(this.url('FetchTransactionReceipt'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<FetchTransactionReceiptResponse>(_data, 'FetchTransactionReceiptResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  fetchTransactionReceiptWithFilter = (
    req: FetchTransactionReceiptWithFilterRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<FetchTransactionReceiptWithFilterResponse> => {
    return this.fetch(this.url('FetchTransactionReceiptWithFilter'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<FetchTransactionReceiptWithFilterResponse>(_data, 'FetchTransactionReceiptWithFilterResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getAllWebhookListeners = (
    req: GetAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetAllWebhookListenersResponse> => {
    return this.fetch(this.url('GetAllWebhookListeners'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetAllWebhookListenersResponse>(_data, 'GetAllWebhookListenersResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getBalanceUpdates = (
    req: GetBalanceUpdatesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetBalanceUpdatesResponse> => {
    return this.fetch(this.url('GetBalanceUpdates'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetBalanceUpdatesResponse>(_data, 'GetBalanceUpdatesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getChainID = (headers?: object, signal?: AbortSignal): Promise<GetChainIDResponse> => {
    return this.fetch(this.url('GetChainID'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetChainIDResponse>(_data, 'GetChainIDResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getEtherBalance = (req: GetEtherBalanceRequest, headers?: object, signal?: AbortSignal): Promise<GetEtherBalanceResponse> => {
    return this.fetch(this.url('GetEtherBalance'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetEtherBalanceResponse>(_data, 'GetEtherBalanceResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getMarketplaceOrders = (
    req: GetMarketplaceOrdersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketplaceOrdersResponse> => {
    return this.fetch(this.url('GetMarketplaceOrders'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetMarketplaceOrdersResponse>(_data, 'GetMarketplaceOrdersResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getMarketplaceTopOrders = (
    req: GetMarketplaceTopOrdersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetMarketplaceTopOrdersResponse> => {
    return this.fetch(this.url('GetMarketplaceTopOrders'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetMarketplaceTopOrdersResponse>(_data, 'GetMarketplaceTopOrdersResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getNativeTokenBalance = (
    req: GetNativeTokenBalanceRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetNativeTokenBalanceResponse> => {
    return this.fetch(this.url('GetNativeTokenBalance'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetNativeTokenBalanceResponse>(_data, 'GetNativeTokenBalanceResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getPrices = (req: GetPricesRequest, headers?: object, signal?: AbortSignal): Promise<GetPricesResponse> => {
    return this.fetch(this.url('GetPrices'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetPricesResponse>(_data, 'GetPricesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenBalances = (
    req: GetTokenBalancesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesResponse> => {
    return this.fetch(this.url('GetTokenBalances'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenBalancesResponse>(_data, 'GetTokenBalancesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenBalancesByContract = (
    req: GetTokenBalancesByContractRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesByContractResponse> => {
    return this.fetch(this.url('GetTokenBalancesByContract'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenBalancesByContractResponse>(_data, 'GetTokenBalancesByContractResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenBalancesDetails = (
    req: GetTokenBalancesDetailsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesDetailsResponse> => {
    return this.fetch(this.url('GetTokenBalancesDetails'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenBalancesDetailsResponse>(_data, 'GetTokenBalancesDetailsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenBalancesSummary = (
    req: GetTokenBalancesSummaryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenBalancesSummaryResponse> => {
    return this.fetch(this.url('GetTokenBalancesSummary'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenBalancesSummaryResponse>(_data, 'GetTokenBalancesSummaryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenIDRanges = (
    req: GetTokenIDRangesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenIDRangesResponse> => {
    return this.fetch(this.url('GetTokenIDRanges'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenIDRangesResponse>(_data, 'GetTokenIDRangesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenIDs = (req: GetTokenIDsRequest, headers?: object, signal?: AbortSignal): Promise<GetTokenIDsResponse> => {
    return this.fetch(this.url('GetTokenIDs'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenIDsResponse>(_data, 'GetTokenIDsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenSupplies = (
    req: GetTokenSuppliesRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenSuppliesResponse> => {
    return this.fetch(this.url('GetTokenSupplies'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenSuppliesResponse>(_data, 'GetTokenSuppliesResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTokenSuppliesMap = (
    req: GetTokenSuppliesMapRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTokenSuppliesMapResponse> => {
    return this.fetch(this.url('GetTokenSuppliesMap'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTokenSuppliesMapResponse>(_data, 'GetTokenSuppliesMapResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getTransactionHistory = (
    req: GetTransactionHistoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetTransactionHistoryResponse> => {
    return this.fetch(this.url('GetTransactionHistory'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetTransactionHistoryResponse>(_data, 'GetTransactionHistoryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getWebhookListener = (
    req: GetWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetWebhookListenerResponse> => {
    return this.fetch(this.url('GetWebhookListener'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetWebhookListenerResponse>(_data, 'GetWebhookListenerResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  pauseAllWebhookListeners = (
    req: PauseAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<PauseAllWebhookListenersResponse> => {
    return this.fetch(this.url('PauseAllWebhookListeners'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PauseAllWebhookListenersResponse>(_data, 'PauseAllWebhookListenersResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingResponse> => {
    return this.fetch(this.url('Ping'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PingResponse>(_data, 'PingResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  removeAllWebhookListeners = (
    req: RemoveAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveAllWebhookListenersResponse> => {
    return this.fetch(this.url('RemoveAllWebhookListeners'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RemoveAllWebhookListenersResponse>(_data, 'RemoveAllWebhookListenersResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  removeWebhookListener = (
    req: RemoveWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<RemoveWebhookListenerResponse> => {
    return this.fetch(this.url('RemoveWebhookListener'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RemoveWebhookListenerResponse>(_data, 'RemoveWebhookListenerResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  resumeAllWebhookListeners = (
    req: ResumeAllWebhookListenersRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ResumeAllWebhookListenersResponse> => {
    return this.fetch(this.url('ResumeAllWebhookListeners'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ResumeAllWebhookListenersResponse>(_data, 'ResumeAllWebhookListenersResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse> => {
    return this.fetch(this.url('RuntimeStatus'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RuntimeStatusResponse>(_data, 'RuntimeStatusResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  subscribeBalanceUpdates = (
    req: SubscribeBalanceUpdatesRequest,
    options: WebrpcStreamOptions<SubscribeBalanceUpdatesResponse>
  ): WebrpcStreamController => {
    const abortController = new AbortController()
    const abortSignal = abortController.signal

    if (options.signal) {
      abortSignal.addEventListener('abort', () => abortController.abort(options.signal?.reason), {
        signal: options.signal
      })
    }

    const _fetch = () =>
      this.fetch(this.url('SubscribeBalanceUpdates'), createHttpRequest(JsonEncode(req), options.headers, abortSignal)).then(
        async res => {
          await sseResponse(res, options, _fetch)
        },
        error => {
          options.onError(error, _fetch)
        }
      )

    const resp = _fetch()
    return {
      abort: abortController.abort.bind(abortController),
      closed: resp
    }
  }
  subscribeEvents = (
    req: SubscribeEventsRequest,
    options: WebrpcStreamOptions<SubscribeEventsResponse>
  ): WebrpcStreamController => {
    const abortController = new AbortController()
    const abortSignal = abortController.signal

    if (options.signal) {
      abortSignal.addEventListener('abort', () => abortController.abort(options.signal?.reason), {
        signal: options.signal
      })
    }

    const _fetch = () =>
      this.fetch(this.url('SubscribeEvents'), createHttpRequest(JsonEncode(req), options.headers, abortSignal)).then(
        async res => {
          await sseResponse(res, options, _fetch)
        },
        error => {
          options.onError(error, _fetch)
        }
      )

    const resp = _fetch()
    return {
      abort: abortController.abort.bind(abortController),
      closed: resp
    }
  }
  subscribeReceipts = (
    req: SubscribeReceiptsRequest,
    options: WebrpcStreamOptions<SubscribeReceiptsResponse>
  ): WebrpcStreamController => {
    const abortController = new AbortController()
    const abortSignal = abortController.signal

    if (options.signal) {
      abortSignal.addEventListener('abort', () => abortController.abort(options.signal?.reason), {
        signal: options.signal
      })
    }

    const _fetch = () =>
      this.fetch(this.url('SubscribeReceipts'), createHttpRequest(JsonEncode(req), options.headers, abortSignal)).then(
        async res => {
          await sseResponse(res, options, _fetch)
        },
        error => {
          options.onError(error, _fetch)
        }
      )

    const resp = _fetch()
    return {
      abort: abortController.abort.bind(abortController),
      closed: resp
    }
  }
  syncBalance = (req: SyncBalanceRequest, headers?: object, signal?: AbortSignal): Promise<SyncBalanceResponse> => {
    return this.fetch(this.url('SyncBalance'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SyncBalanceResponse>(_data, 'SyncBalanceResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  toggleWebhookListener = (
    req: ToggleWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ToggleWebhookListenerResponse> => {
    return this.fetch(this.url('ToggleWebhookListener'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ToggleWebhookListenerResponse>(_data, 'ToggleWebhookListenerResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  updateWebhookListener = (
    req: UpdateWebhookListenerRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<UpdateWebhookListenerResponse> => {
    return this.fetch(this.url('UpdateWebhookListener'), createHttpRequest(JsonEncode(req), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<UpdateWebhookListenerResponse>(_data, 'UpdateWebhookListenerResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  version = (headers?: object, signal?: AbortSignal): Promise<VersionResponse> => {
    return this.fetch(this.url('Version'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<VersionResponse>(_data, 'VersionResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }
}

const sseResponse = async (res: Response, options: WebrpcStreamOptions<any>, retryFetch: () => Promise<void>) => {
  const { onMessage, onOpen, onClose, onError } = options

  if (!res.ok) {
    try {
      await buildResponse(res)
    } catch (error) {
      // @ts-ignore
      onError(error, retryFetch)
    }
    return
  }

  if (!res.body) {
    onError(
      WebrpcBadResponseError.new({
        status: res.status,
        cause: 'Invalid response, missing body'
      }),
      retryFetch
    )
    return
  }

  onOpen && onOpen()

  const reader = res.body.getReader()
  const decoder = new TextDecoder()
  let buffer = ''
  let lastReadTime = Date.now()
  const timeout = (10 + 1) * 1000
  let timeoutError = false
  const intervalId = setInterval(() => {
    if (Date.now() - lastReadTime > timeout) {
      timeoutError = true
      clearInterval(intervalId)
      reader.releaseLock()
    }
  }, timeout)

  while (true) {
    let value
    let done
    try {
      ;({ value, done } = await reader.read())
      if (timeoutError) throw new Error('Timeout, no data or heartbeat received')
      lastReadTime = Date.now()
      buffer += decoder.decode(value, { stream: true })
    } catch (error) {
      if (error instanceof DOMException && error.name === 'AbortError') {
        onError(
          WebrpcClientAbortedError.new({
            message: 'AbortError',
            cause: `AbortError: ${error instanceof Error ? error.message : String(error)}`
          }),
          () => {
            throw new Error('Abort signal cannot be used to reconnect')
          }
        )
      } else {
        onError(
          WebrpcStreamLostError.new({
            cause: `reader.read(): ${error instanceof Error ? error.message : String(error)}`
          }),
          retryFetch
        )
      }
      return
    }

    let lines = buffer.split('\n')
    for (let i = 0; i < lines.length - 1; i++) {
      const line = lines[i]
      if (line?.length === 0) {
        continue
      }
      let data: any
      try {
        data = JSON.parse(line)
        if (data.hasOwnProperty('webrpcError')) {
          const error = data.webrpcError
          const code: number = typeof error.code === 'number' ? error.code : 0
          onError((webrpcErrorByCode[code] || WebrpcError).new(error), retryFetch)
          return
        }
      } catch (error) {
        if (error instanceof Error && error.message === 'Abort signal cannot be used to reconnect') {
          throw error
        }
        onError(
          WebrpcBadResponseError.new({
            status: res.status,
            cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}`
          }),
          retryFetch
        )
      }
      onMessage(data)
    }

    if (!done) {
      const lastLine = lines[lines.length - 1]
      buffer = lastLine || ''
      continue
    }

    onClose && onClose()
    return
  }
}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = {
    ...headers,
    'Content-Type': 'application/json',
    [WebrpcHeader]: WebrpcHeaderValue
  }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>

export interface WebrpcStreamOptions<T> extends WebrpcOptions {
  onMessage: (message: T) => void
  onError: (error: WebrpcError, reconnect: () => void) => void
  onOpen?: () => void
  onClose?: () => void
}

export interface WebrpcOptions {
  headers?: HeadersInit
  signal?: AbortSignal
}

export interface WebrpcStreamController {
  abort: (reason?: any) => void
  closed: Promise<void>
}

export const JsonEncode = <T = any>(obj: T): string => {
  return JSON.stringify(obj)
}

export const JsonDecode = <T = any>(data: string | any, _typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try {
      parsed = JSON.parse(data)
    } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return parsed as T
}

//
// Errors
//

type WebrpcErrorParams = { name?: string; code?: number; message?: string; status?: number; cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}

export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

//
// Schema errors
//

export class AbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Aborted'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request aborted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyMismatch'
    this.code = typeof error.code === 'number' ? error.code : 1102
    this.message = error.message || `Access key mismatch`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1101
    this.message = error.message || `Access key not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AtLeastOneKey'
    this.code = typeof error.code === 'number' ? error.code : 1302
    this.message = error.message || `You need at least one Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidArgument'
    this.code = typeof error.code === 'number' ? error.code : 2001
    this.message = error.message || `Invalid argument`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidOrigin'
    this.code = typeof error.code === 'number' ? error.code : 1103
    this.message = error.message || `Invalid origin for Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidService'
    this.code = typeof error.code === 'number' ? error.code : 1104
    this.message = error.message || `Service not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MaxAccessKeys'
    this.code = typeof error.code === 'number' ? error.code : 1301
    this.message = error.message || `Access keys limit reached`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class MetadataCallFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MetadataCallFailed'
    this.code = typeof error.code === 'number' ? error.code : 3003
    this.message = error.message || `Metadata service call failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MetadataCallFailedError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NoDefaultKey'
    this.code = typeof error.code === 'number' ? error.code : 1300
    this.message = error.message || `No default access key found`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotFound'
    this.code = typeof error.code === 'number' ? error.code : 3000
    this.message = error.message || `Resource not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1100
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QueryFailed'
    this.code = typeof error.code === 'number' ? error.code : 2003
    this.message = error.message || `Query failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaExceeded'
    this.code = typeof error.code === 'number' ? error.code : 1200
    this.message = error.message || `Quota exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class RateLimitError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimit'
    this.code = typeof error.code === 'number' ? error.code : 1201
    this.message = error.message || `Rate limit exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Rate-limited. Please slow down.`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class ResourceExhaustedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ResourceExhausted'
    this.code = typeof error.code === 'number' ? error.code : 2004
    this.message = error.message || `Resource exhausted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ResourceExhaustedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 1900
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnauthorizedUser'
    this.code = typeof error.code === 'number' ? error.code : 1105
    this.message = error.message || `Unauthorized user`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class UnavailableError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unavailable'
    this.code = typeof error.code === 'number' ? error.code : 2002
    this.message = error.message || `Unavailable resource`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnavailableError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Aborted = 'Aborted',
  AccessKeyMismatch = 'AccessKeyMismatch',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AtLeastOneKey = 'AtLeastOneKey',
  Geoblocked = 'Geoblocked',
  InvalidArgument = 'InvalidArgument',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  MaxAccessKeys = 'MaxAccessKeys',
  MetadataCallFailed = 'MetadataCallFailed',
  MethodNotFound = 'MethodNotFound',
  NoDefaultKey = 'NoDefaultKey',
  NotFound = 'NotFound',
  PermissionDenied = 'PermissionDenied',
  ProjectNotFound = 'ProjectNotFound',
  QueryFailed = 'QueryFailed',
  QuotaExceeded = 'QuotaExceeded',
  RateLimit = 'RateLimit',
  RateLimited = 'RateLimited',
  RequestConflict = 'RequestConflict',
  ResourceExhausted = 'ResourceExhausted',
  SessionExpired = 'SessionExpired',
  Timeout = 'Timeout',
  Unauthorized = 'Unauthorized',
  UnauthorizedUser = 'UnauthorizedUser',
  Unavailable = 'Unavailable'
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Aborted = 1005,
  AccessKeyMismatch = 1102,
  AccessKeyNotFound = 1101,
  AtLeastOneKey = 1302,
  Geoblocked = 1006,
  InvalidArgument = 2001,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  MaxAccessKeys = 1301,
  MetadataCallFailed = 3003,
  MethodNotFound = 1003,
  NoDefaultKey = 1300,
  NotFound = 3000,
  PermissionDenied = 1001,
  ProjectNotFound = 1100,
  QueryFailed = 2003,
  QuotaExceeded = 1200,
  RateLimit = 1201,
  RateLimited = 1007,
  RequestConflict = 1004,
  ResourceExhausted = 2004,
  SessionExpired = 1002,
  Timeout = 1900,
  Unauthorized = 1000,
  UnauthorizedUser = 1105,
  Unavailable = 2002
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1005]: AbortedError,
  [1102]: AccessKeyMismatchError,
  [1101]: AccessKeyNotFoundError,
  [1302]: AtLeastOneKeyError,
  [1006]: GeoblockedError,
  [2001]: InvalidArgumentError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1301]: MaxAccessKeysError,
  [3003]: MetadataCallFailedError,
  [1003]: MethodNotFoundError,
  [1300]: NoDefaultKeyError,
  [3000]: NotFoundError,
  [1001]: PermissionDeniedError,
  [1100]: ProjectNotFoundError,
  [2003]: QueryFailedError,
  [1200]: QuotaExceededError,
  [1201]: RateLimitError,
  [1007]: RateLimitedError,
  [1004]: RequestConflictError,
  [2004]: ResourceExhaustedError,
  [1002]: SessionExpiredError,
  [1900]: TimeoutError,
  [1000]: UnauthorizedError,
  [1105]: UnauthorizedUserError,
  [2002]: UnavailableError
}

//
// Webrpc
//

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.31.2;gen-typescript@v0.23.1;sequence-indexer@v0.4.0'

type WebrpcGenVersions = {
  WebrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  const [_, WebrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? ''
  }
}
