/* eslint-disable */
// sequence-indexer v0.4.0 83530970d81179658f6546c87fc4352280dbd287
// --
// Code generated by webrpc-gen@v0.14.0-dev with typescript@v0.10.0 generator. DO NOT EDIT.
//
// webrpc-gen -schema=indexer.ridl -target=typescript@v0.10.0 -client -out=./clients/indexer.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = 'v1'

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = '83530970d81179658f6546c87fc4352280dbd287'

//
// Types
//

export interface ContractInfo {
  chainId: number
  address: string
  name: string
  type: string
  symbol: string
  decimals?: number
  logoURI: string
  deployed: boolean
  bytecodeHash: string
  extensions: ContractInfoExtensions

  updatedAt: string
}

export interface ContractInfoExtensions {
  link: string
  description: string
  ogImage: string
  originChainId: number
  originAddress: string
  blacklist: boolean
  verified: boolean
  verifiedBy: string
}

export interface TokenMetadata {
  tokenId: string
  contractAddress: string
  name: string
  description: string
  image: string
  decimals: number
  properties: { [key: string]: any }
  video: string
  audio: string
  image_data: string
  external_url: string
  background_color: string
  animation_url: string
  attributes: Array<{ [key: string]: any }>
  updatedAt: string
}
export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  NATIVE = 'NATIVE',
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155',
  SEQUENCE_WALLET = 'SEQUENCE_WALLET',
  ERC20_BRIDGE = 'ERC20_BRIDGE',
  ERC721_BRIDGE = 'ERC721_BRIDGE',
  ERC1155_BRIDGE = 'ERC1155_BRIDGE',
  SEQ_MARKETPLACE = 'SEQ_MARKETPLACE'
}
export enum EventLogType {
  UNKNOWN = 'UNKNOWN',
  BLOCK_ADDED = 'BLOCK_ADDED',
  BLOCK_REMOVED = 'BLOCK_REMOVED'
}
export enum EventLogDataType {
  UNKNOWN = 'UNKNOWN',
  TOKEN_TRANSFER = 'TOKEN_TRANSFER',
  NATIVE_TOKEN_TRANSFER = 'NATIVE_TOKEN_TRANSFER',
  SEQUENCE_TXN = 'SEQUENCE_TXN'
}
export enum OrderStatus {
  OPEN = 'OPEN',
  CLOSED = 'CLOSED',
  CANCELLED = 'CANCELLED'
}
export enum TxnTransferType {
  UNKNOWN = 'UNKNOWN',
  SEND = 'SEND',
  RECEIVE = 'RECEIVE'
}
export enum TransactionStatus {
  FAILED = 'FAILED',
  SUCCESSFUL = 'SUCCESSFUL'
}
export enum TransactionType {
  LegacyTxnType = 'LegacyTxnType',
  AccessListTxnType = 'AccessListTxnType',
  DynamicFeeTxnType = 'DynamicFeeTxnType'
}
export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  indexerEnabled: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  chainID: number
  checks: RuntimeChecks
}

export interface WALWriterRuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  chainID: number
  percentWALWritten: number
}

export interface RuntimeChecks {
  running: boolean
  cgoEnabled: boolean
  quotaControlEnabled: boolean
  syncMode: string
  percentIndexed: number
  lastBlockNum: number
  lastBlockNumWithState: number
  bloomStatus: BloomStatus
  bond: Bond
  diskUsage: string
}

export interface Bond {
  pebble: PebbleMetrics
  estimatedDiskUsagePerTable: any
  estimatedDiskUsageTotal: string
}

export interface PebbleMetrics {
  compactionCount: number
  compactionEstimatedDebt: number
  compactionInProgressBytes: number
  compactionNumInProgress: number
  compactionMarkedFiles: number
}

export interface BloomStatus {
  enabled: boolean
  initialized: boolean
  bloomInitElapsedTime: string
}

export interface EtherBalance {
  accountAddress: string
  balanceWei: string
}

export interface IndexState {
  chainId: string
  lastBlockNum: number
  lastBlockHash: string
}

export interface IndexedBlock {
  blockNumber: number
  blockShortHash: string
}

export interface TxnData {
  from: string
  to: string
  value: string
}

export interface EventLog {
  id: number
  type: EventLogType
  blockNumber: number
  blockHash: string
  parentBlockHash: string
  contractAddress: string
  contractType: ContractType
  txnHash: string
  txnIndex: number
  txnData: TxnData
  txnLogIndex: number
  logDataType: EventLogDataType
  ts: string
  logData: string
}

export interface TokenBalance {
  contractType: ContractType
  contractAddress: string
  accountAddress: string
  tokenID: string
  balance: string
  blockHash: string
  blockNumber: number
  chainId: number

  contractInfo?: ContractInfo
  tokenMetadata?: TokenMetadata
}

export interface OrderbookOrder {
  orderId: string
  tokenContract: string
  tokenId: string
  isListing: boolean
  quantity: string
  quantityRemaining: string
  currencyAddress: string
  pricePerToken: string
  expiry: string
  orderStatus: OrderStatus
  createdBy: string
  createdAt: number
  orderbookContractAddress: string
}

export interface OrderbookOrderFilter {
  isListing?: boolean
  userAddress?: string
  tokenIds: Array<string>
  excludeUserAddress?: string
}

export interface TokenHistory {
  blockNumber: number
  blockHash: string
  accountAddress: string
  contractAddress: string
  contractType: ContractType
  fromAddress: string
  toAddress: string
  txnHash: string
  txnIndex: number
  txnLogIndex: number
  logData: string
  tokenIDs: string
  Amounts: string
  ts: string
}

export interface TokenSupply {
  tokenID: string
  supply: string
  chainId: number
  contractInfo?: ContractInfo
  tokenMetadata?: TokenMetadata
}

export interface Transaction {
  txnHash: string
  blockNumber: number
  blockHash: string
  chainId: number
  metaTxnID?: string
  transfers?: Array<TxnTransfer>
  timestamp: string
}

export interface TxnTransfer {
  transferType: TxnTransferType
  contractAddress: string
  contractType: ContractType
  from: string
  to: string
  tokenIds?: Array<string>
  amounts: Array<string>
  logIndex: number
  contractInfo?: ContractInfo
  tokenMetadata?: { [key: string]: TokenMetadata }
}

export interface TransactionHistoryFilter {
  accountAddress?: string
  contractAddress?: string
  accountAddresses?: Array<string>
  contractAddresses?: Array<string>
  transactionHashes?: Array<string>
  metaTransactionIDs?: Array<string>
  fromBlock?: number
  toBlock?: number
  tokenID?: string
}

export interface Filter {
  txnHash?: string
  from?: string
  to?: string
  contractAddress?: string
  logTopic?: string
}

export interface TransactionReceipt {
  txnHash: string
  txnStatus: TransactionStatus
  txnIndex: number
  txnType: TransactionType
  blockHash: string
  blockNumber: number
  gasUsed: number
  effectiveGasPrice: string
  from: string
  to: string
  logs: Array<TransactionLog>
  final: boolean
  reorged: boolean
}

export interface TransactionLog {
  contractAddress: string
  topics: Array<string>
  data: string
  index: number
}

export interface Page {
  page?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
  pageSize?: number
  more?: boolean
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface WebhookListener {
  id: number
  projectID: number
  url: string
  filters: WebhookEventFilter
  updatedAt: string
}

export interface WebhookEventFilter {
  contractAddresses?: Array<string>
  tokenIDs?: Array<string>
  accounts?: Array<string>
}

export interface MetadataOptions {
  verifiedOnly?: boolean
  unverifiedOnly?: boolean
  includeContracts?: Array<string>
}

export interface Indexer {
  ping(headers?: object): Promise<PingReturn>
  version(headers?: object): Promise<VersionReturn>
  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>
  getChainID(headers?: object): Promise<GetChainIDReturn>
  getEtherBalance(args: GetEtherBalanceArgs, headers?: object): Promise<GetEtherBalanceReturn>
  getTokenBalances(args: GetTokenBalancesArgs, headers?: object): Promise<GetTokenBalancesReturn>
  getTokenSupplies(args: GetTokenSuppliesArgs, headers?: object): Promise<GetTokenSuppliesReturn>
  getTokenSuppliesMap(args: GetTokenSuppliesMapArgs, headers?: object): Promise<GetTokenSuppliesMapReturn>
  getBalanceUpdates(args: GetBalanceUpdatesArgs, headers?: object): Promise<GetBalanceUpdatesReturn>
  getTransactionHistory(args: GetTransactionHistoryArgs, headers?: object): Promise<GetTransactionHistoryReturn>
  syncBalance(args: SyncBalanceArgs, headers?: object): Promise<SyncBalanceReturn>
  fetchTransactionReceipt(args: FetchTransactionReceiptArgs, headers?: object): Promise<FetchTransactionReceiptReturn>
  getOrderbookOrders(args: GetOrderbookOrdersArgs, headers?: object): Promise<GetOrderbookOrdersReturn>
  getTopOrders(args: GetTopOrdersArgs, headers?: object): Promise<GetTopOrdersReturn>
  fetchTransactionReceiptWithFilter(
    args: FetchTransactionReceiptWithFilterArgs,
    headers?: object
  ): Promise<FetchTransactionReceiptWithFilterReturn>
  getAllWebhookListeners(args: GetAllWebhookListenersArgs, headers?: object): Promise<GetAllWebhookListenersReturn>
  getWebhookListener(args: GetWebhookListenerArgs, headers?: object): Promise<GetWebhookListenerReturn>
  addWebhookListener(args: AddWebhookListenerArgs, headers?: object): Promise<AddWebhookListenerReturn>
  updateWebhookListener(args: UpdateWebhookListenerArgs, headers?: object): Promise<UpdateWebhookListenerReturn>
  removeWebhookListener(args: RemoveWebhookListenerArgs, headers?: object): Promise<RemoveWebhookListenerReturn>
}

export interface PingArgs {}

export interface PingReturn {
  status: boolean
}
export interface VersionArgs {}

export interface VersionReturn {
  version: Version
}
export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: RuntimeStatus
}
export interface GetChainIDArgs {}

export interface GetChainIDReturn {
  chainID: number
}
export interface GetEtherBalanceArgs {
  accountAddress?: string
}

export interface GetEtherBalanceReturn {
  balance: EtherBalance
}
export interface GetTokenBalancesArgs {
  accountAddress?: string
  contractAddress?: string
  tokenID?: string
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
  includeCollectionTokens?: boolean
  page?: Page
}

export interface GetTokenBalancesReturn {
  page: Page
  balances: Array<TokenBalance>
}
export interface GetTokenSuppliesArgs {
  contractAddress: string
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
  page?: Page
}

export interface GetTokenSuppliesReturn {
  page: Page
  contractType: ContractType
  tokenIDs: Array<TokenSupply>
}
export interface GetTokenSuppliesMapArgs {
  tokenMap: { [key: string]: Array<string> }
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
}

export interface GetTokenSuppliesMapReturn {
  supplies: { [key: string]: Array<TokenSupply> }
}
export interface GetBalanceUpdatesArgs {
  contractAddress: string
  lastBlockNumber: number
  lastBlockHash?: string
  page?: Page
}

export interface GetBalanceUpdatesReturn {
  page: Page
  balances: Array<TokenBalance>
}
export interface GetTransactionHistoryArgs {
  filter: TransactionHistoryFilter
  page?: Page
  includeMetadata?: boolean
  metadataOptions?: MetadataOptions
}

export interface GetTransactionHistoryReturn {
  page: Page
  transactions: Array<Transaction>
}
export interface SyncBalanceArgs {
  accountAddress: string
  contractAddress: string
  tokenID?: string
}

export interface SyncBalanceReturn {}
export interface FetchTransactionReceiptArgs {
  txnHash: string
  maxBlockWait?: number
}

export interface FetchTransactionReceiptReturn {
  receipt: TransactionReceipt
}
export interface GetOrderbookOrdersArgs {
  page?: Page
  orderbookContractAddress: string
  collectionAddress: string
  currencyAddresses: Array<string>
  filters: Array<OrderbookOrderFilter>
  orderStatuses: Array<OrderStatus>
  beforeExpiryTimestamp: number
}

export interface GetOrderbookOrdersReturn {
  page?: Page
  orders: Array<OrderbookOrder>
}
export interface GetTopOrdersArgs {
  orderbookContractAddress: string
  collectionAddress: string
  currencyAddresses: Array<string>
  tokenIDs: Array<string>
  isListing: boolean
  priceSort: SortOrder
  excludeUser?: string
}

export interface GetTopOrdersReturn {
  orders: Array<OrderbookOrder>
}
export interface FetchTransactionReceiptWithFilterArgs {
  filter: Filter
  maxBlockWait?: number
}

export interface FetchTransactionReceiptWithFilterReturn {
  receipt: TransactionReceipt
}
export interface GetAllWebhookListenersArgs {
  projectId?: number
}

export interface GetAllWebhookListenersReturn {
  listeners: Array<WebhookListener>
}
export interface GetWebhookListenerArgs {
  id: number
  projectId?: number
}

export interface GetWebhookListenerReturn {
  listener: WebhookListener
}
export interface AddWebhookListenerArgs {
  url: string
  filters: WebhookEventFilter
  projectId?: number
}

export interface AddWebhookListenerReturn {
  status: boolean
  listener: WebhookListener
}
export interface UpdateWebhookListenerArgs {
  listener: WebhookListener
  projectId?: number
}

export interface UpdateWebhookListenerReturn {
  status: boolean
}
export interface RemoveWebhookListenerArgs {
  id: number
  projectId?: number
}

export interface RemoveWebhookListenerReturn {
  status: boolean
}

//
// Client
//
export class Indexer implements Indexer {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Indexer/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status
        }
      })
    })
  }

  version = (headers?: object): Promise<VersionReturn> => {
    return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          version: <Version>_data.version
        }
      })
    })
  }

  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {
    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <RuntimeStatus>_data.status
        }
      })
    })
  }

  getChainID = (headers?: object): Promise<GetChainIDReturn> => {
    return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          chainID: <number>_data.chainID
        }
      })
    })
  }

  getEtherBalance = (args: GetEtherBalanceArgs, headers?: object): Promise<GetEtherBalanceReturn> => {
    return this.fetch(this.url('GetEtherBalance'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          balance: <EtherBalance>_data.balance
        }
      })
    })
  }

  getTokenBalances = (args: GetTokenBalancesArgs, headers?: object): Promise<GetTokenBalancesReturn> => {
    return this.fetch(this.url('GetTokenBalances'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          balances: <Array<TokenBalance>>_data.balances
        }
      })
    })
  }

  getTokenSupplies = (args: GetTokenSuppliesArgs, headers?: object): Promise<GetTokenSuppliesReturn> => {
    return this.fetch(this.url('GetTokenSupplies'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          contractType: <ContractType>_data.contractType,
          tokenIDs: <Array<TokenSupply>>_data.tokenIDs
        }
      })
    })
  }

  getTokenSuppliesMap = (args: GetTokenSuppliesMapArgs, headers?: object): Promise<GetTokenSuppliesMapReturn> => {
    return this.fetch(this.url('GetTokenSuppliesMap'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          supplies: <{ [key: string]: Array<TokenSupply> }>_data.supplies
        }
      })
    })
  }

  getBalanceUpdates = (args: GetBalanceUpdatesArgs, headers?: object): Promise<GetBalanceUpdatesReturn> => {
    return this.fetch(this.url('GetBalanceUpdates'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          balances: <Array<TokenBalance>>_data.balances
        }
      })
    })
  }

  getTransactionHistory = (args: GetTransactionHistoryArgs, headers?: object): Promise<GetTransactionHistoryReturn> => {
    return this.fetch(this.url('GetTransactionHistory'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          transactions: <Array<Transaction>>_data.transactions
        }
      })
    })
  }

  syncBalance = (args: SyncBalanceArgs, headers?: object): Promise<SyncBalanceReturn> => {
    return this.fetch(this.url('SyncBalance'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {}
      })
    })
  }

  fetchTransactionReceipt = (args: FetchTransactionReceiptArgs, headers?: object): Promise<FetchTransactionReceiptReturn> => {
    return this.fetch(this.url('FetchTransactionReceipt'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          receipt: <TransactionReceipt>_data.receipt
        }
      })
    })
  }

  getOrderbookOrders = (args: GetOrderbookOrdersArgs, headers?: object): Promise<GetOrderbookOrdersReturn> => {
    return this.fetch(this.url('GetOrderbookOrders'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          orders: <Array<OrderbookOrder>>_data.orders
        }
      })
    })
  }

  getTopOrders = (args: GetTopOrdersArgs, headers?: object): Promise<GetTopOrdersReturn> => {
    return this.fetch(this.url('GetTopOrders'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          orders: <Array<OrderbookOrder>>_data.orders
        }
      })
    })
  }

  fetchTransactionReceiptWithFilter = (
    args: FetchTransactionReceiptWithFilterArgs,
    headers?: object
  ): Promise<FetchTransactionReceiptWithFilterReturn> => {
    return this.fetch(this.url('FetchTransactionReceiptWithFilter'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          receipt: <TransactionReceipt>_data.receipt
        }
      })
    })
  }

  getAllWebhookListeners = (args: GetAllWebhookListenersArgs, headers?: object): Promise<GetAllWebhookListenersReturn> => {
    return this.fetch(this.url('GetAllWebhookListeners'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          listeners: <Array<WebhookListener>>_data.listeners
        }
      })
    })
  }

  getWebhookListener = (args: GetWebhookListenerArgs, headers?: object): Promise<GetWebhookListenerReturn> => {
    return this.fetch(this.url('GetWebhookListener'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          listener: <WebhookListener>_data.listener
        }
      })
    })
  }

  addWebhookListener = (args: AddWebhookListenerArgs, headers?: object): Promise<AddWebhookListenerReturn> => {
    return this.fetch(this.url('AddWebhookListener'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status,
          listener: <WebhookListener>_data.listener
        }
      })
    })
  }

  updateWebhookListener = (args: UpdateWebhookListenerArgs, headers?: object): Promise<UpdateWebhookListenerReturn> => {
    return this.fetch(this.url('UpdateWebhookListener'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status
        }
      })
    })
  }

  removeWebhookListener = (args: RemoveWebhookListenerArgs, headers?: object): Promise<RemoveWebhookListenerReturn> => {
    return this.fetch(this.url('RemoveWebhookListener'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status
        }
      })
    })
  }
}

export interface WebRPCError extends Error {
  code: string
  msg: string
  status: number
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (err) {
      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError
    }
    if (!res.ok) {
      throw data // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
