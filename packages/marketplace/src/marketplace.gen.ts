/* eslint-disable */
// marketplace-api  0391bc2ece6d83092773039f15d1ea60ebfc32bf
// --
// Code generated by webrpc-gen@v0.25.4 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=marketplace.ridl -target=typescript -client -out=./clients/marketplace.gen.ts

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue =
  'webrpc@v0.25.4;gen-typescript@v0.17.0;marketplace-api@v0.0.0-0391bc2ece6d83092773039f15d1ea60ebfc32bf'

// WebRPC description and code-gen version
export const WebRPCVersion = 'v1'

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = ''

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = '0391bc2ece6d83092773039f15d1ea60ebfc32bf'

type WebrpcGenVersions = {
  webrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  const [_, webrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    webrpcGenVersion: webrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? ''
  }
}

//
// Types
//

export enum MetadataStatus {
  NOT_AVAILABLE = 'NOT_AVAILABLE',
  REFRESHING = 'REFRESHING',
  AVAILABLE = 'AVAILABLE'
}

export interface TokenMetadata {
  tokenId: string
  name: string
  description?: string
  image?: string
  video?: string
  audio?: string
  properties?: { [key: string]: any }
  attributes: Array<{ [key: string]: any }>
  image_data?: string
  external_url?: string
  background_color?: string
  animation_url?: string
  decimals?: number
  updatedAt?: string
  assets?: Array<Asset>
  status: MetadataStatus
}

export interface Asset {
  id: number
  collectionId: number
  tokenId: string
  url?: string
  metadataField: string
  name?: string
  filesize?: number
  mimeType?: string
  width?: number
  height?: number
  updatedAt?: string
}

export enum SortOrder {
  ASC = 'ASC',
  DESC = 'DESC'
}

export enum PropertyType {
  INT = 'INT',
  STRING = 'STRING',
  ARRAY = 'ARRAY',
  GENERIC = 'GENERIC'
}

export enum MarketplaceKind {
  unknown = 'unknown',
  sequence_marketplace_v1 = 'sequence_marketplace_v1',
  sequence_marketplace_v2 = 'sequence_marketplace_v2',
  blur = 'blur',
  zerox = 'zerox',
  opensea = 'opensea',
  looks_rare = 'looks_rare',
  x2y2 = 'x2y2',
  alienswap = 'alienswap',
  payment_processor = 'payment_processor',
  mintify = 'mintify',
  magic_eden = 'magic_eden'
}

export enum OrderbookKind {
  unknown = 'unknown',
  sequence_marketplace_v1 = 'sequence_marketplace_v1',
  sequence_marketplace_v2 = 'sequence_marketplace_v2',
  blur = 'blur',
  opensea = 'opensea',
  looks_rare = 'looks_rare',
  reservoir = 'reservoir',
  x2y2 = 'x2y2'
}

export enum SourceKind {
  unknown = 'unknown',
  external = 'external',
  sequence_marketplace_v1 = 'sequence_marketplace_v1',
  sequence_marketplace_v2 = 'sequence_marketplace_v2',
  opensea = 'opensea'
}

export enum OrderSide {
  unknown = 'unknown',
  listing = 'listing',
  offer = 'offer'
}

export enum OfferType {
  unknown = 'unknown',
  item = 'item',
  collection = 'collection'
}

export enum OrderStatus {
  unknown = 'unknown',
  active = 'active',
  inactive = 'inactive',
  expired = 'expired',
  cancelled = 'cancelled',
  filled = 'filled',
  decimals_missing = 'decimals_missing'
}

export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155'
}

export enum CollectionPriority {
  unknown = 'unknown',
  low = 'low',
  normal = 'normal',
  high = 'high'
}

export enum CollectionStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_orders = 'syncing_orders',
  active = 'active',
  failed = 'failed',
  inactive = 'inactive',
  incompatible_type = 'incompatible_type'
}

export enum ProjectStatus {
  unknown = 'unknown',
  active = 'active',
  inactive = 'inactive'
}

export enum ItemsContractStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_contract_metadata = 'syncing_contract_metadata',
  synced_contract_metadata = 'synced_contract_metadata',
  syncing_tokens = 'syncing_tokens',
  synced_tokens = 'synced_tokens',
  active = 'active',
  inactive = 'inactive',
  incompatible_type = 'incompatible_type'
}

export enum CollectibleStatus {
  unknown = 'unknown',
  active = 'active',
  inactive = 'inactive'
}

export enum CollectibleSource {
  unknown = 'unknown',
  indexer = 'indexer',
  manual = 'manual'
}

export enum CurrencyStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_metadata = 'syncing_metadata',
  active = 'active',
  failed = 'failed'
}

export enum WalletKind {
  unknown = 'unknown',
  sequence = 'sequence'
}

export enum StepType {
  unknown = 'unknown',
  tokenApproval = 'tokenApproval',
  buy = 'buy',
  sell = 'sell',
  createListing = 'createListing',
  createOffer = 'createOffer',
  signEIP712 = 'signEIP712',
  signEIP191 = 'signEIP191',
  cancel = 'cancel'
}

export enum TransactionCrypto {
  none = 'none',
  partially = 'partially',
  all = 'all'
}

export enum TransactionNFTCheckoutProvider {
  unknown = 'unknown',
  transak = 'transak',
  sardine = 'sardine'
}

export enum TransactionOnRampProvider {
  unknown = 'unknown',
  transak = 'transak',
  sardine = 'sardine'
}

export enum TransactionSwapProvider {
  unknown = 'unknown',
  lifi = 'lifi'
}

export enum ExecuteType {
  unknown = 'unknown',
  order = 'order',
  createListing = 'createListing',
  createItemOffer = 'createItemOffer',
  createTraitOffer = 'createTraitOffer'
}

export enum ActivityAction {
  unknown = 'unknown',
  listing = 'listing',
  offer = 'offer',
  mint = 'mint',
  sale = 'sale',
  listingCancel = 'listingCancel',
  offerCancel = 'offerCancel',
  transfer = 'transfer'
}

export enum PrimarySaleContractStatus {
  unknown = 'unknown',
  created = 'created',
  syncing_items = 'syncing_items',
  active = 'active',
  inactive = 'inactive',
  incompatible_type = 'incompatible_type',
  failed = 'failed'
}

export enum PrimarySaleVersion {
  v0 = 'v0',
  v1 = 'v1'
}

export enum PrimarySaleItemDetailType {
  unknown = 'unknown',
  global = 'global',
  individual = 'individual'
}

export interface Page {
  page: number
  pageSize: number
  more?: boolean
  sort?: Array<SortBy>
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface Filter {
  text?: string
  properties?: Array<PropertyFilter>
}

export interface PropertyFilter {
  name: string
  type: PropertyType
  min?: number
  max?: number
  values?: Array<any>
}

export interface CollectiblesFilter {
  includeEmpty: boolean
  searchText?: string
  properties?: Array<PropertyFilter>
  marketplaces?: Array<MarketplaceKind>
  inAccounts?: Array<string>
  notInAccounts?: Array<string>
  ordersCreatedBy?: Array<string>
  ordersNotCreatedBy?: Array<string>
  inCurrencyAddresses?: Array<string>
  notInCurrencyAddresses?: Array<string>
  prices?: Array<PriceFilter>
}

export interface OrdersFilter {
  searchText?: string
  properties?: Array<PropertyFilter>
  marketplaces?: Array<MarketplaceKind>
  inAccounts?: Array<string>
  notInAccounts?: Array<string>
  ordersCreatedBy?: Array<string>
  ordersNotCreatedBy?: Array<string>
  inCurrencyAddresses?: Array<string>
  notInCurrencyAddresses?: Array<string>
  prices?: Array<PriceFilter>
}

export interface PriceFilter {
  contractAddress: string
  min?: string
  max?: string
}

export interface Order {
  orderId: string
  marketplace: MarketplaceKind
  side: OrderSide
  status: OrderStatus
  chainId: number
  originName: string
  slug: string
  collectionContractAddress: string
  tokenId?: string
  createdBy: string
  priceAmount: string
  priceAmountFormatted: string
  priceAmountNet: string
  priceAmountNetFormatted: string
  priceCurrencyAddress: string
  priceDecimals: number
  priceUSD: number
  priceUSDFormatted: string
  quantityInitial: string
  quantityInitialFormatted: string
  quantityRemaining: string
  quantityRemainingFormatted: string
  quantityAvailable: string
  quantityAvailableFormatted: string
  quantityDecimals: number
  feeBps: number
  feeBreakdown: Array<FeeBreakdown>
  validFrom: string
  validUntil: string
  blockNumber: number
  orderCreatedAt?: string
  orderUpdatedAt?: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface FeeBreakdown {
  kind: string
  recipientAddress: string
  bps: number
}

export interface CollectibleOrder {
  metadata: TokenMetadata
  order?: Order
  listing?: Order
  offer?: Order
}

export interface OrderFilter {
  createdBy?: Array<string>
  marketplace?: Array<MarketplaceKind>
  currencies?: Array<string>
}

export interface Collection {
  status: CollectionStatus
  chainId: number
  contractAddress: string
  contractType: ContractType
  priority: CollectionPriority
  tokenQuantityDecimals: number
  config: CollectionConfig
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface CollectionConfig {
  lastSynced: { [key: string]: CollectionLastSynced }
  collectiblesSynced: string
  activitiesSynced: string
  activitiesSyncedContinuity: string
}

export interface CollectionLastSynced {
  allOrders: string
  newOrders: string
  names: Array<string>
  cursors: { [key: string]: string }
}

export interface Project {
  projectId: number
  chainId: number
  contractAddress: string
  status: ProjectStatus
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface ItemsContract {
  status: ItemsContractStatus
  chainId: number
  contractAddress: string
  contractType: ContractType
  lastSynced: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface Collectible {
  status: CollectibleStatus
  tokenId: string
  decimals: number
  source: CollectibleSource
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface Currency {
  chainId: number
  contractAddress: string
  status: CurrencyStatus
  name: string
  symbol: string
  decimals: number
  imageUrl: string
  exchangeRate: number
  defaultChainCurrency: boolean
  nativeCurrency: boolean
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface OrderData {
  orderId: string
  quantity: string
  tokenId?: string
}

export interface AdditionalFee {
  amount: string
  receiver: string
}

export interface Step {
  id: StepType
  data: string
  to: string
  value: string
  price: string
  signature?: Signature
  post?: PostRequest
  executeType?: ExecuteType
}

export interface PostRequest {
  endpoint: string
  method: string
  body: any
}

export interface CreateReq {
  tokenId: string
  quantity: string
  expiry: string
  currencyAddress: string
  pricePerToken: string
}

export interface GetOrdersInput {
  contractAddress: string
  orderId: string
  marketplace: MarketplaceKind
}

export interface Signature {
  domain: Domain
  types: any
  primaryType: string
  value: any
}

export interface Domain {
  name: string
  version: string
  chainId: number
  verifyingContract: string
}

export interface CheckoutOptionsMarketplaceOrder {
  contractAddress: string
  orderId: string
  marketplace: MarketplaceKind
}

export interface CheckoutOptionsItem {
  tokenId: string
  quantity: string
}

export interface CheckoutOptions {
  crypto: TransactionCrypto
  swap: Array<TransactionSwapProvider>
  nftCheckout: Array<TransactionNFTCheckoutProvider>
  onRamp: Array<TransactionOnRampProvider>
}

export interface ExecuteInput {
  chainId: string
  signature: string
  method: string
  endpoint: string
  slug: string
  executeType: ExecuteType
  body: any
}

export interface Activity {
  chainId: number
  contractAddress: string
  tokenId: string
  action: ActivityAction
  txHash: string
  from: string
  to?: string
  quantity: string
  quantityDecimals: number
  priceAmount?: string
  priceAmountFormatted?: string
  priceCurrencyAddress?: string
  priceDecimals?: number
  activityCreatedAt: string
  uniqueHash: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface PrimarySaleContract {
  chainId: number
  contractAddress: string
  collectionAddress: string
  contractType: ContractType
  version: PrimarySaleVersion
  currencyAddress: string
  priceDecimals: number
  status: PrimarySaleContractStatus
  lastSynced: string
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface PrimarySaleItem {
  itemAddress: string
  contractType: ContractType
  tokenId: string
  itemType: PrimarySaleItemDetailType
  startDate: string
  endDate: string
  currencyAddress: string
  priceDecimals: number
  priceAmount: string
  priceAmountFormatted: string
  supply: string
  supplyCap: string
  unlimitedSupply: boolean
  createdAt: string
  updatedAt: string
  deletedAt?: string
}

export interface CollectiblePrimarySaleItem {
  metadata: TokenMetadata
  primarySaleItem: PrimarySaleItem
}

export interface PrimarySaleItemsFilter {
  includeEmpty: boolean
  searchText?: string
  properties?: Array<PropertyFilter>
  detailTypes?: Array<PrimarySaleItemDetailType>
  startDateAfter?: string
  startDateBefore?: string
  endDateAfter?: string
  endDateBefore?: string
}

export interface Admin {
  createCollection(args: CreateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<CreateCollectionReturn>
  getCollection(args: GetCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionReturn>
  updateCollection(args: UpdateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionReturn>
  listCollections(args: ListCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectionsReturn>
  deleteCollection(args: DeleteCollectionArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionReturn>
  /**
   * determine what should happen here
   */
  syncCollection(args: SyncCollectionArgs, headers?: object, signal?: AbortSignal): Promise<SyncCollectionReturn>
  createPrimarySaleContract(
    args: CreatePrimarySaleContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreatePrimarySaleContractReturn>
  deletePrimarySaleContract(
    args: DeletePrimarySaleContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeletePrimarySaleContractReturn>
  createCurrency(args: CreateCurrencyArgs, headers?: object, signal?: AbortSignal): Promise<CreateCurrencyReturn>
  createCurrencies(args: CreateCurrenciesArgs, headers?: object, signal?: AbortSignal): Promise<CreateCurrenciesReturn>
  updateCurrency(args: UpdateCurrencyArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCurrencyReturn>
  listCurrencies(args: ListCurrenciesArgs, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesReturn>
  deleteCurrency(args: DeleteCurrencyArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCurrencyReturn>
  /**
   * This for manual adding of non minted ERC1155 tokens, it's used for purposes of Shop.
   */
  addCollectibles(args: AddCollectiblesArgs, headers?: object, signal?: AbortSignal): Promise<AddCollectiblesReturn>
}

export interface CreateCollectionArgs {
  chainId: string
  projectId: number
  contractAddress: string
}

export interface CreateCollectionReturn {
  collection: Collection
}
export interface GetCollectionArgs {
  chainId: string
  projectId: number
  contractAddress: string
}

export interface GetCollectionReturn {
  collection: Collection
}
export interface UpdateCollectionArgs {
  chainId: string
  collection: Collection
}

export interface UpdateCollectionReturn {
  collection: Collection
}
export interface ListCollectionsArgs {
  chainId: string
  projectId: number
  page?: Page
}

export interface ListCollectionsReturn {
  collections: Array<Collection>
  page?: Page
}
export interface DeleteCollectionArgs {
  chainId: string
  projectId: number
  contractAddress: string
}

export interface DeleteCollectionReturn {
  collection: Collection
}
export interface SyncCollectionArgs {
  chainId: string
  contractAddress: string
}

export interface SyncCollectionReturn {}
export interface CreatePrimarySaleContractArgs {
  chainId: string
  projectId: number
  primarySaleContractAddress: string
  itemsContractAddress: string
}

export interface CreatePrimarySaleContractReturn {
  primarySaleContract: PrimarySaleContract
}
export interface DeletePrimarySaleContractArgs {
  chainId: string
  projectId: number
  primarySaleContractAddress: string
}

export interface DeletePrimarySaleContractReturn {}
export interface CreateCurrencyArgs {
  chainId: string
  currency: Currency
}

export interface CreateCurrencyReturn {
  currency: Currency
}
export interface CreateCurrenciesArgs {
  chainId: string
  currencies: Array<Currency>
}

export interface CreateCurrenciesReturn {
  currency: { [key: string]: Currency }
}
export interface UpdateCurrencyArgs {
  chainId: string
  currency: Currency
}

export interface UpdateCurrencyReturn {
  currency: Currency
}
export interface ListCurrenciesArgs {
  chainId: string
}

export interface ListCurrenciesReturn {
  currencies: Array<Currency>
}
export interface DeleteCurrencyArgs {
  chainId: string
  contractAddress: string
}

export interface DeleteCurrencyReturn {
  currency: Currency
}
export interface AddCollectiblesArgs {
  chainId: string
  itemsContractAddress: string
  tokenIds: Array<string>
}

export interface AddCollectiblesReturn {}

export interface Marketplace {
  listCurrencies(args: ListCurrenciesArgs, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesReturn>
  getCollectionDetail(args: GetCollectionDetailArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionDetailReturn>
  getCollectible(args: GetCollectibleArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectibleReturn>
  getLowestPriceOfferForCollectible(
    args: GetLowestPriceOfferForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLowestPriceOfferForCollectibleReturn>
  getHighestPriceOfferForCollectible(
    args: GetHighestPriceOfferForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetHighestPriceOfferForCollectibleReturn>
  getLowestPriceListingForCollectible(
    args: GetLowestPriceListingForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLowestPriceListingForCollectibleReturn>
  getHighestPriceListingForCollectible(
    args: GetHighestPriceListingForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetHighestPriceListingForCollectibleReturn>
  listListingsForCollectible(
    args: ListListingsForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListListingsForCollectibleReturn>
  listOffersForCollectible(
    args: ListOffersForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffersForCollectibleReturn>
  listOrdersWithCollectibles(
    args: ListOrdersWithCollectiblesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOrdersWithCollectiblesReturn>
  getCountOfAllOrders(args: GetCountOfAllOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetCountOfAllOrdersReturn>
  getCountOfFilteredOrders(
    args: GetCountOfFilteredOrdersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfFilteredOrdersReturn>
  listListings(args: ListListingsArgs, headers?: object, signal?: AbortSignal): Promise<ListListingsReturn>
  listOffers(args: ListOffersArgs, headers?: object, signal?: AbortSignal): Promise<ListOffersReturn>
  getCountOfListingsForCollectible(
    args: GetCountOfListingsForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfListingsForCollectibleReturn>
  getCountOfOffersForCollectible(
    args: GetCountOfOffersForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfOffersForCollectibleReturn>
  /**
   * @deprecated Please use GetLowestPriceOfferForCollectible instead.
   */
  getCollectibleLowestOffer(
    args: GetCollectibleLowestOfferArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleLowestOfferReturn>
  /**
   * @deprecated Please use GetHighestPriceOfferForCollectible instead.
   */
  getCollectibleHighestOffer(
    args: GetCollectibleHighestOfferArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleHighestOfferReturn>
  /**
   * @deprecated Please use GetLowestPriceListingForCollectible instead.
   */
  getCollectibleLowestListing(
    args: GetCollectibleLowestListingArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleLowestListingReturn>
  /**
   * @deprecated Please use GetHighestPriceListingForCollectible instead.
   */
  getCollectibleHighestListing(
    args: GetCollectibleHighestListingArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleHighestListingReturn>
  /**
   * @deprecated Please use ListListingsForCollectible instead.
   */
  listCollectibleListings(
    args: ListCollectibleListingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectibleListingsReturn>
  /**
   * @deprecated Please use ListOffersForCollectible instead.
   */
  listCollectibleOffers(
    args: ListCollectibleOffersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectibleOffersReturn>
  /**
   * checkout process
   */
  generateBuyTransaction(
    args: GenerateBuyTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateBuyTransactionReturn>
  generateSellTransaction(
    args: GenerateSellTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateSellTransactionReturn>
  generateListingTransaction(
    args: GenerateListingTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateListingTransactionReturn>
  generateOfferTransaction(
    args: GenerateOfferTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateOfferTransactionReturn>
  generateCancelTransaction(
    args: GenerateCancelTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateCancelTransactionReturn>
  /**
   * only used in a case of external transactions ( when we create off-chain transactions ) for instance opensea market, use onlyu ExecuteInput and leave other inputs empty, they are depracated and kept only for backward compatibility
   */
  execute(args: ExecuteArgs, headers?: object, signal?: AbortSignal): Promise<ExecuteReturn>
  /**
   * list of collectibles with best order for each collectible, by default this only returns collectibles with an order
   */
  listCollectibles(args: ListCollectiblesArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesReturn>
  getCountOfAllCollectibles(
    args: GetCountOfAllCollectiblesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfAllCollectiblesReturn>
  getCountOfFilteredCollectibles(
    args: GetCountOfFilteredCollectiblesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfFilteredCollectiblesReturn>
  getFloorOrder(args: GetFloorOrderArgs, headers?: object, signal?: AbortSignal): Promise<GetFloorOrderReturn>
  listCollectionActivities(
    args: ListCollectionActivitiesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectionActivitiesReturn>
  listCollectibleActivities(
    args: ListCollectibleActivitiesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectibleActivitiesReturn>
  listCollectiblesWithLowestListing(
    args: ListCollectiblesWithLowestListingArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectiblesWithLowestListingReturn>
  listCollectiblesWithHighestOffer(
    args: ListCollectiblesWithHighestOfferArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectiblesWithHighestOfferReturn>
  syncOrder(args: SyncOrderArgs, headers?: object, signal?: AbortSignal): Promise<SyncOrderReturn>
  syncOrders(args: SyncOrdersArgs, headers?: object, signal?: AbortSignal): Promise<SyncOrdersReturn>
  getOrders(args: GetOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetOrdersReturn>
  checkoutOptionsMarketplace(
    args: CheckoutOptionsMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsMarketplaceReturn>
  checkoutOptionsSalesContract(
    args: CheckoutOptionsSalesContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsSalesContractReturn>
  supportedMarketplaces(
    args: SupportedMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SupportedMarketplacesReturn>
  getPrimarySaleItem(args: GetPrimarySaleItemArgs, headers?: object, signal?: AbortSignal): Promise<GetPrimarySaleItemReturn>
  listPrimarySaleItems(
    args: ListPrimarySaleItemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListPrimarySaleItemsReturn>
  getCountOfPrimarySaleItems(
    args: GetCountOfPrimarySaleItemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfPrimarySaleItemsReturn>
}

export interface ListCurrenciesArgs {
  chainId: string
}

export interface ListCurrenciesReturn {
  currencies: Array<Currency>
}
export interface GetCollectionDetailArgs {
  chainId: string
  contractAddress: string
}

export interface GetCollectionDetailReturn {
  collection: Collection
}
export interface GetCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
}

export interface GetCollectibleReturn {
  metadata: TokenMetadata
}
export interface GetLowestPriceOfferForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetLowestPriceOfferForCollectibleReturn {
  order: Order
}
export interface GetHighestPriceOfferForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetHighestPriceOfferForCollectibleReturn {
  order: Order
}
export interface GetLowestPriceListingForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetLowestPriceListingForCollectibleReturn {
  order: Order
}
export interface GetHighestPriceListingForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetHighestPriceListingForCollectibleReturn {
  order: Order
}
export interface ListListingsForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
  page?: Page
}

export interface ListListingsForCollectibleReturn {
  listings: Array<Order>
  page?: Page
}
export interface ListOffersForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
  page?: Page
}

export interface ListOffersForCollectibleReturn {
  offers: Array<Order>
  page?: Page
}
export interface ListOrdersWithCollectiblesArgs {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: OrdersFilter
  page?: Page
}

export interface ListOrdersWithCollectiblesReturn {
  collectibles: Array<CollectibleOrder>
  page?: Page
}
export interface GetCountOfAllOrdersArgs {
  chainId: string
  side: OrderSide
  contractAddress: string
}

export interface GetCountOfAllOrdersReturn {
  count: number
}
export interface GetCountOfFilteredOrdersArgs {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: OrdersFilter
}

export interface GetCountOfFilteredOrdersReturn {
  count: number
}
export interface ListListingsArgs {
  chainId: string
  contractAddress: string
  filter?: OrderFilter
  page?: Page
}

export interface ListListingsReturn {
  listings: Array<Order>
  page?: Page
}
export interface ListOffersArgs {
  chainId: string
  contractAddress: string
  filter?: OrderFilter
  page?: Page
}

export interface ListOffersReturn {
  offers: Array<Order>
  page?: Page
}
export interface GetCountOfListingsForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetCountOfListingsForCollectibleReturn {
  count: number
}
export interface GetCountOfOffersForCollectibleArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetCountOfOffersForCollectibleReturn {
  count: number
}
export interface GetCollectibleLowestOfferArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetCollectibleLowestOfferReturn {
  order?: Order
}
export interface GetCollectibleHighestOfferArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetCollectibleHighestOfferReturn {
  order?: Order
}
export interface GetCollectibleLowestListingArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetCollectibleLowestListingReturn {
  order?: Order
}
export interface GetCollectibleHighestListingArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
}

export interface GetCollectibleHighestListingReturn {
  order?: Order
}
export interface ListCollectibleListingsArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
  page?: Page
}

export interface ListCollectibleListingsReturn {
  listings: Array<Order>
  page?: Page
}
export interface ListCollectibleOffersArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  filter?: OrderFilter
  page?: Page
}

export interface ListCollectibleOffersReturn {
  offers: Array<Order>
  page?: Page
}
export interface GenerateBuyTransactionArgs {
  chainId: string
  collectionAddress: string
  buyer: string
  marketplace: MarketplaceKind
  ordersData: Array<OrderData>
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
}

export interface GenerateBuyTransactionReturn {
  steps: Array<Step>
}
export interface GenerateSellTransactionArgs {
  chainId: string
  collectionAddress: string
  seller: string
  marketplace: MarketplaceKind
  ordersData: Array<OrderData>
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
}

export interface GenerateSellTransactionReturn {
  steps: Array<Step>
}
export interface GenerateListingTransactionArgs {
  chainId: string
  collectionAddress: string
  owner: string
  contractType: ContractType
  orderbook: OrderbookKind
  listing: CreateReq
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
}

export interface GenerateListingTransactionReturn {
  steps: Array<Step>
}
export interface GenerateOfferTransactionArgs {
  chainId: string
  collectionAddress: string
  maker: string
  contractType: ContractType
  orderbook: OrderbookKind
  offer: CreateReq
  additionalFees: Array<AdditionalFee>
  walletType?: WalletKind
  offerType: OfferType
}

export interface GenerateOfferTransactionReturn {
  steps: Array<Step>
}
export interface GenerateCancelTransactionArgs {
  chainId: string
  collectionAddress: string
  maker: string
  marketplace: MarketplaceKind
  orderId: string
}

export interface GenerateCancelTransactionReturn {
  steps: Array<Step>
}
export interface ExecuteArgs {
  params: ExecuteInput
  chainId: string
  signature: string
  method: string
  endpoint: string
  executeType: ExecuteType
  body: any
}

export interface ExecuteReturn {
  orderId: string
}
export interface ListCollectiblesArgs {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: CollectiblesFilter
  page?: Page
}

export interface ListCollectiblesReturn {
  collectibles: Array<CollectibleOrder>
  page?: Page
}
export interface GetCountOfAllCollectiblesArgs {
  chainId: string
  contractAddress: string
}

export interface GetCountOfAllCollectiblesReturn {
  count: number
}
export interface GetCountOfFilteredCollectiblesArgs {
  chainId: string
  side: OrderSide
  contractAddress: string
  filter?: CollectiblesFilter
}

export interface GetCountOfFilteredCollectiblesReturn {
  count: number
}
export interface GetFloorOrderArgs {
  chainId: string
  contractAddress: string
  filter?: CollectiblesFilter
}

export interface GetFloorOrderReturn {
  collectible: CollectibleOrder
}
export interface ListCollectionActivitiesArgs {
  chainId: string
  contractAddress: string
  page?: Page
}

export interface ListCollectionActivitiesReturn {
  activities: Array<Activity>
  page?: Page
}
export interface ListCollectibleActivitiesArgs {
  chainId: string
  contractAddress: string
  tokenId: string
  page?: Page
}

export interface ListCollectibleActivitiesReturn {
  activities: Array<Activity>
  page?: Page
}
export interface ListCollectiblesWithLowestListingArgs {
  chainId: string
  contractAddress: string
  filter?: CollectiblesFilter
  page?: Page
}

export interface ListCollectiblesWithLowestListingReturn {
  collectibles: Array<CollectibleOrder>
  page?: Page
}
export interface ListCollectiblesWithHighestOfferArgs {
  chainId: string
  contractAddress: string
  filter?: CollectiblesFilter
  page?: Page
}

export interface ListCollectiblesWithHighestOfferReturn {
  collectibles: Array<CollectibleOrder>
  page?: Page
}
export interface SyncOrderArgs {
  chainId: string
  order: Order
}

export interface SyncOrderReturn {}
export interface SyncOrdersArgs {
  chainId: string
  orders: Array<Order>
}

export interface SyncOrdersReturn {}
export interface GetOrdersArgs {
  chainId: string
  input: Array<GetOrdersInput>
  page?: Page
}

export interface GetOrdersReturn {
  orders: Array<Order>
  page?: Page
}
export interface CheckoutOptionsMarketplaceArgs {
  chainId: string
  wallet: string
  orders: Array<CheckoutOptionsMarketplaceOrder>
  additionalFee: number
}

export interface CheckoutOptionsMarketplaceReturn {
  options: CheckoutOptions
}
export interface CheckoutOptionsSalesContractArgs {
  chainId: string
  wallet: string
  contractAddress: string
  collectionAddress: string
  items: Array<CheckoutOptionsItem>
}

export interface CheckoutOptionsSalesContractReturn {
  options: CheckoutOptions
}
export interface SupportedMarketplacesArgs {
  chainId: string
}

export interface SupportedMarketplacesReturn {
  marketplaces: Array<MarketplaceKind>
}
export interface GetPrimarySaleItemArgs {
  chainId: string
  primarySaleContractAddress: string
  tokenId: string
}

export interface GetPrimarySaleItemReturn {
  item: CollectiblePrimarySaleItem
}
export interface ListPrimarySaleItemsArgs {
  chainId: string
  primarySaleContractAddress: string
  filter?: PrimarySaleItemsFilter
  page?: Page
}

export interface ListPrimarySaleItemsReturn {
  primarySaleItems: Array<CollectiblePrimarySaleItem>
  page?: Page
}
export interface GetCountOfPrimarySaleItemsArgs {
  chainId: string
  primarySaleContractAddress: string
  filter?: PrimarySaleItemsFilter
}

export interface GetCountOfPrimarySaleItemsReturn {
  count: number
}

//
// Client
//
export class Admin implements Admin {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Admin/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  createCollection = (args: CreateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<CreateCollectionReturn> => {
    return this.fetch(this.url('CreateCollection'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collection: <Collection>_data.collection
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCollection = (args: GetCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionReturn> => {
    return this.fetch(this.url('GetCollection'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collection: <Collection>_data.collection
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  updateCollection = (args: UpdateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionReturn> => {
    return this.fetch(this.url('UpdateCollection'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collection: <Collection>_data.collection
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollections = (args: ListCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectionsReturn> => {
    return this.fetch(this.url('ListCollections'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collections: <Array<Collection>>_data.collections,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  deleteCollection = (args: DeleteCollectionArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionReturn> => {
    return this.fetch(this.url('DeleteCollection'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collection: <Collection>_data.collection
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  syncCollection = (args: SyncCollectionArgs, headers?: object, signal?: AbortSignal): Promise<SyncCollectionReturn> => {
    return this.fetch(this.url('SyncCollection'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {}
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  createPrimarySaleContract = (
    args: CreatePrimarySaleContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CreatePrimarySaleContractReturn> => {
    return this.fetch(this.url('CreatePrimarySaleContract'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            primarySaleContract: <PrimarySaleContract>_data.primarySaleContract
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  deletePrimarySaleContract = (
    args: DeletePrimarySaleContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<DeletePrimarySaleContractReturn> => {
    return this.fetch(this.url('DeletePrimarySaleContract'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {}
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  createCurrency = (args: CreateCurrencyArgs, headers?: object, signal?: AbortSignal): Promise<CreateCurrencyReturn> => {
    return this.fetch(this.url('CreateCurrency'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            currency: <Currency>_data.currency
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  createCurrencies = (args: CreateCurrenciesArgs, headers?: object, signal?: AbortSignal): Promise<CreateCurrenciesReturn> => {
    return this.fetch(this.url('CreateCurrencies'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            currency: <{ [key: string]: Currency }>_data.currency
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  updateCurrency = (args: UpdateCurrencyArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCurrencyReturn> => {
    return this.fetch(this.url('UpdateCurrency'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            currency: <Currency>_data.currency
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCurrencies = (args: ListCurrenciesArgs, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesReturn> => {
    return this.fetch(this.url('ListCurrencies'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            currencies: <Array<Currency>>_data.currencies
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  deleteCurrency = (args: DeleteCurrencyArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCurrencyReturn> => {
    return this.fetch(this.url('DeleteCurrency'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            currency: <Currency>_data.currency
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  addCollectibles = (args: AddCollectiblesArgs, headers?: object, signal?: AbortSignal): Promise<AddCollectiblesReturn> => {
    return this.fetch(this.url('AddCollectibles'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {}
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }
}
export class Marketplace implements Marketplace {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Marketplace/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  listCurrencies = (args: ListCurrenciesArgs, headers?: object, signal?: AbortSignal): Promise<ListCurrenciesReturn> => {
    return this.fetch(this.url('ListCurrencies'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            currencies: <Array<Currency>>_data.currencies
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCollectionDetail = (
    args: GetCollectionDetailArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectionDetailReturn> => {
    return this.fetch(this.url('GetCollectionDetail'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collection: <Collection>_data.collection
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCollectible = (args: GetCollectibleArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectibleReturn> => {
    return this.fetch(this.url('GetCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            metadata: <TokenMetadata>_data.metadata
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getLowestPriceOfferForCollectible = (
    args: GetLowestPriceOfferForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLowestPriceOfferForCollectibleReturn> => {
    return this.fetch(this.url('GetLowestPriceOfferForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getHighestPriceOfferForCollectible = (
    args: GetHighestPriceOfferForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetHighestPriceOfferForCollectibleReturn> => {
    return this.fetch(this.url('GetHighestPriceOfferForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getLowestPriceListingForCollectible = (
    args: GetLowestPriceListingForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetLowestPriceListingForCollectibleReturn> => {
    return this.fetch(this.url('GetLowestPriceListingForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getHighestPriceListingForCollectible = (
    args: GetHighestPriceListingForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetHighestPriceListingForCollectibleReturn> => {
    return this.fetch(this.url('GetHighestPriceListingForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listListingsForCollectible = (
    args: ListListingsForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListListingsForCollectibleReturn> => {
    return this.fetch(this.url('ListListingsForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            listings: <Array<Order>>_data.listings,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listOffersForCollectible = (
    args: ListOffersForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOffersForCollectibleReturn> => {
    return this.fetch(this.url('ListOffersForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            offers: <Array<Order>>_data.offers,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listOrdersWithCollectibles = (
    args: ListOrdersWithCollectiblesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListOrdersWithCollectiblesReturn> => {
    return this.fetch(this.url('ListOrdersWithCollectibles'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collectibles: <Array<CollectibleOrder>>_data.collectibles,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCountOfAllOrders = (
    args: GetCountOfAllOrdersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfAllOrdersReturn> => {
    return this.fetch(this.url('GetCountOfAllOrders'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            count: <number>_data.count
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCountOfFilteredOrders = (
    args: GetCountOfFilteredOrdersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfFilteredOrdersReturn> => {
    return this.fetch(this.url('GetCountOfFilteredOrders'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            count: <number>_data.count
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listListings = (args: ListListingsArgs, headers?: object, signal?: AbortSignal): Promise<ListListingsReturn> => {
    return this.fetch(this.url('ListListings'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            listings: <Array<Order>>_data.listings,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listOffers = (args: ListOffersArgs, headers?: object, signal?: AbortSignal): Promise<ListOffersReturn> => {
    return this.fetch(this.url('ListOffers'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            offers: <Array<Order>>_data.offers,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCountOfListingsForCollectible = (
    args: GetCountOfListingsForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfListingsForCollectibleReturn> => {
    return this.fetch(this.url('GetCountOfListingsForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            count: <number>_data.count
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCountOfOffersForCollectible = (
    args: GetCountOfOffersForCollectibleArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfOffersForCollectibleReturn> => {
    return this.fetch(this.url('GetCountOfOffersForCollectible'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            count: <number>_data.count
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCollectibleLowestOffer = (
    args: GetCollectibleLowestOfferArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleLowestOfferReturn> => {
    return this.fetch(this.url('GetCollectibleLowestOffer'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCollectibleHighestOffer = (
    args: GetCollectibleHighestOfferArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleHighestOfferReturn> => {
    return this.fetch(this.url('GetCollectibleHighestOffer'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCollectibleLowestListing = (
    args: GetCollectibleLowestListingArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleLowestListingReturn> => {
    return this.fetch(this.url('GetCollectibleLowestListing'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCollectibleHighestListing = (
    args: GetCollectibleHighestListingArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCollectibleHighestListingReturn> => {
    return this.fetch(this.url('GetCollectibleHighestListing'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            order: <Order>_data.order
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollectibleListings = (
    args: ListCollectibleListingsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectibleListingsReturn> => {
    return this.fetch(this.url('ListCollectibleListings'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            listings: <Array<Order>>_data.listings,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollectibleOffers = (
    args: ListCollectibleOffersArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectibleOffersReturn> => {
    return this.fetch(this.url('ListCollectibleOffers'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            offers: <Array<Order>>_data.offers,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  generateBuyTransaction = (
    args: GenerateBuyTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateBuyTransactionReturn> => {
    return this.fetch(this.url('GenerateBuyTransaction'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            steps: <Array<Step>>_data.steps
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  generateSellTransaction = (
    args: GenerateSellTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateSellTransactionReturn> => {
    return this.fetch(this.url('GenerateSellTransaction'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            steps: <Array<Step>>_data.steps
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  generateListingTransaction = (
    args: GenerateListingTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateListingTransactionReturn> => {
    return this.fetch(this.url('GenerateListingTransaction'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            steps: <Array<Step>>_data.steps
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  generateOfferTransaction = (
    args: GenerateOfferTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateOfferTransactionReturn> => {
    return this.fetch(this.url('GenerateOfferTransaction'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            steps: <Array<Step>>_data.steps
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  generateCancelTransaction = (
    args: GenerateCancelTransactionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GenerateCancelTransactionReturn> => {
    return this.fetch(this.url('GenerateCancelTransaction'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            steps: <Array<Step>>_data.steps
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  execute = (args: ExecuteArgs, headers?: object, signal?: AbortSignal): Promise<ExecuteReturn> => {
    return this.fetch(this.url('Execute'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            orderId: <string>_data.orderId
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollectibles = (args: ListCollectiblesArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectiblesReturn> => {
    return this.fetch(this.url('ListCollectibles'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collectibles: <Array<CollectibleOrder>>_data.collectibles,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCountOfAllCollectibles = (
    args: GetCountOfAllCollectiblesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfAllCollectiblesReturn> => {
    return this.fetch(this.url('GetCountOfAllCollectibles'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            count: <number>_data.count
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCountOfFilteredCollectibles = (
    args: GetCountOfFilteredCollectiblesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfFilteredCollectiblesReturn> => {
    return this.fetch(this.url('GetCountOfFilteredCollectibles'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            count: <number>_data.count
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getFloorOrder = (args: GetFloorOrderArgs, headers?: object, signal?: AbortSignal): Promise<GetFloorOrderReturn> => {
    return this.fetch(this.url('GetFloorOrder'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collectible: <CollectibleOrder>_data.collectible
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollectionActivities = (
    args: ListCollectionActivitiesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectionActivitiesReturn> => {
    return this.fetch(this.url('ListCollectionActivities'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            activities: <Array<Activity>>_data.activities,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollectibleActivities = (
    args: ListCollectibleActivitiesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectibleActivitiesReturn> => {
    return this.fetch(this.url('ListCollectibleActivities'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            activities: <Array<Activity>>_data.activities,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollectiblesWithLowestListing = (
    args: ListCollectiblesWithLowestListingArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectiblesWithLowestListingReturn> => {
    return this.fetch(this.url('ListCollectiblesWithLowestListing'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collectibles: <Array<CollectibleOrder>>_data.collectibles,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listCollectiblesWithHighestOffer = (
    args: ListCollectiblesWithHighestOfferArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListCollectiblesWithHighestOfferReturn> => {
    return this.fetch(this.url('ListCollectiblesWithHighestOffer'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            collectibles: <Array<CollectibleOrder>>_data.collectibles,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  syncOrder = (args: SyncOrderArgs, headers?: object, signal?: AbortSignal): Promise<SyncOrderReturn> => {
    return this.fetch(this.url('SyncOrder'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {}
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  syncOrders = (args: SyncOrdersArgs, headers?: object, signal?: AbortSignal): Promise<SyncOrdersReturn> => {
    return this.fetch(this.url('SyncOrders'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {}
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getOrders = (args: GetOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetOrdersReturn> => {
    return this.fetch(this.url('GetOrders'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            orders: <Array<Order>>_data.orders,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  checkoutOptionsMarketplace = (
    args: CheckoutOptionsMarketplaceArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsMarketplaceReturn> => {
    return this.fetch(this.url('CheckoutOptionsMarketplace'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            options: <CheckoutOptions>_data.options
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  checkoutOptionsSalesContract = (
    args: CheckoutOptionsSalesContractArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CheckoutOptionsSalesContractReturn> => {
    return this.fetch(this.url('CheckoutOptionsSalesContract'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            options: <CheckoutOptions>_data.options
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  supportedMarketplaces = (
    args: SupportedMarketplacesArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<SupportedMarketplacesReturn> => {
    return this.fetch(this.url('SupportedMarketplaces'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            marketplaces: <Array<MarketplaceKind>>_data.marketplaces
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getPrimarySaleItem = (
    args: GetPrimarySaleItemArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetPrimarySaleItemReturn> => {
    return this.fetch(this.url('GetPrimarySaleItem'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            item: <CollectiblePrimarySaleItem>_data.item
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  listPrimarySaleItems = (
    args: ListPrimarySaleItemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<ListPrimarySaleItemsReturn> => {
    return this.fetch(this.url('ListPrimarySaleItems'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            primarySaleItems: <Array<CollectiblePrimarySaleItem>>_data.primarySaleItems,
            page: <Page>_data.page
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }

  getCountOfPrimarySaleItems = (
    args: GetCountOfPrimarySaleItemsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetCountOfPrimarySaleItemsReturn> => {
    return this.fetch(this.url('GetCountOfPrimarySaleItems'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            count: <number>_data.count
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })
      }
    )
  }
}

const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  reqHeaders[WebrpcHeader] = WebrpcHeaderValue

  return {
    method: 'POST',
    headers: reqHeaders,
    body: JSON.stringify(body || {}),
    signal
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      let message = ''
      if (error instanceof Error) {
        message = error.message
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

//
// Errors
//

export class WebrpcError extends Error {
  name: string
  code: number
  message: string
  status: number
  cause?: string

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string

  constructor(name: string, code: number, message: string, status: number, cause?: string) {
    super(message)
    this.name = name || 'WebrpcError'
    this.code = typeof code === 'number' ? code : 0
    this.message = message || `endpoint error ${this.code}`
    this.msg = this.message
    this.status = typeof status === 'number' ? status : 0
    this.cause = cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = 'WebrpcEndpoint',
    code: number = 0,
    message: string = `endpoint error`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcRequestFailed',
    code: number = -1,
    message: string = `request failed`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRoute',
    code: number = -2,
    message: string = `bad route`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadMethod',
    code: number = -3,
    message: string = `bad method`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRequest',
    code: number = -4,
    message: string = `bad request`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadResponse',
    code: number = -5,
    message: string = `bad response`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(
    name: string = 'WebrpcServerPanic',
    code: number = -6,
    message: string = `server panic`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(
    name: string = 'WebrpcInternalError',
    code: number = -7,
    message: string = `internal error`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcClientDisconnected',
    code: number = -8,
    message: string = `client disconnected`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(
    name: string = 'WebrpcStreamLost',
    code: number = -9,
    message: string = `stream lost`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcStreamFinished',
    code: number = -10,
    message: string = `stream finished`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

// Schema errors

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = 'Unauthorized',
    code: number = 1000,
    message: string = `Unauthorized access`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(
    name: string = 'PermissionDenied',
    code: number = 1001,
    message: string = `Permission denied`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(
    name: string = 'SessionExpired',
    code: number = 1002,
    message: string = `Session expired`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(
    name: string = 'MethodNotFound',
    code: number = 1003,
    message: string = `Method not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(
    name: string = 'Timeout',
    code: number = 2000,
    message: string = `Request timed out`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(
    name: string = 'InvalidArgument',
    code: number = 2001,
    message: string = `Invalid argument`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(
    name: string = 'NotFound',
    code: number = 3000,
    message: string = `Resource not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class UserNotFoundError extends WebrpcError {
  constructor(
    name: string = 'UserNotFound',
    code: number = 3001,
    message: string = `User not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UserNotFoundError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(
    name: string = 'ProjectNotFound',
    code: number = 3002,
    message: string = `Project not found`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class InvalidTierError extends WebrpcError {
  constructor(
    name: string = 'InvalidTier',
    code: number = 3003,
    message: string = `Invalid subscription tier`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidTierError.prototype)
  }
}

export class ProjectLimitReachedError extends WebrpcError {
  constructor(
    name: string = 'ProjectLimitReached',
    code: number = 3005,
    message: string = `Project limit reached`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, ProjectLimitReachedError.prototype)
  }
}

export class NotImplementedError extends WebrpcError {
  constructor(
    name: string = 'NotImplemented',
    code: number = 9999,
    message: string = `Not Implemented`,
    status: number = 0,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, NotImplementedError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientDisconnected = 'WebrpcClientDisconnected',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  Timeout = 'Timeout',
  InvalidArgument = 'InvalidArgument',
  NotFound = 'NotFound',
  UserNotFound = 'UserNotFound',
  ProjectNotFound = 'ProjectNotFound',
  InvalidTier = 'InvalidTier',
  ProjectLimitReached = 'ProjectLimitReached',
  NotImplemented = 'NotImplemented'
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientDisconnected = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  Timeout = 2000,
  InvalidArgument = 2001,
  NotFound = 3000,
  UserNotFound = 3001,
  ProjectNotFound = 3002,
  InvalidTier = 3003,
  ProjectLimitReached = 3005,
  NotImplemented = 9999
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [2000]: TimeoutError,
  [2001]: InvalidArgumentError,
  [3000]: NotFoundError,
  [3001]: UserNotFoundError,
  [3002]: ProjectNotFoundError,
  [3003]: InvalidTierError,
  [3005]: ProjectLimitReachedError,
  [9999]: NotImplementedError
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
