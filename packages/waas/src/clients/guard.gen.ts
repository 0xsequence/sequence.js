/* eslint-disable */
// sequence-guard v0.4.0 7ee16164e41ef607a3edecef5bb7b94ca808bc23
// --
// Code generated by webrpc-gen@v0.12.x-dev with typescript@v0.10.0 generator. DO NOT EDIT.
//
// webrpc-gen -schema=guard.ridl -target=typescript@v0.10.0 -client -out=./clients/guard.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v0.4.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "7ee16164e41ef607a3edecef5bb7b94ca808bc23"

//
// Types
//

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
}

export interface WalletSigner {
  address: string
  weight: number
}

export interface WaasSession {
  id: string
  partnerId: number
  sessionAddress: string
  walletAddress: string
  idTokenClaims: {[key: string]: any}
  email: string
  phone: string
  validated: boolean
  updatedAt?: string
  createdAt?: string
}

export interface TransactionPolicyWhitelistRule {
  addresses: Array<string>
}

export interface TransactionPolicyBlacklistRule {
  addresses: Array<string>
}

export interface TransactionPolicy {
  name: string
  rule: any
}

export interface TransactionPolicyList {
  id: number
  partnerId: number
  policies: {[key: string]: TransactionPolicy}
  disabled: boolean
  updatedAt?: string
  createdAt?: string
}

export interface SessionUserMapRules {
  id: number
  partnerId: number
  allowIdTokens: boolean
  allowEmails: boolean
  allowPhones: boolean
  idTokenTemplate: string
}

export interface SessionValidation {
  id: number
  sessionAddress: string
  salt: string
  challengeHash: string
  consumed: boolean
  createdAt?: string
}

export interface Page {
  pageSize?: number
  page?: number
  totalRecords?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface ChildContext {
  address: string
  child?: ChildContext
}

export interface Transaction {
  to: string
  value: string
  gasLimit: string
  data: string
  delegateCall: boolean
  revertOnError: boolean
}

export interface TransactionBundle {
  chainID: string
  nonce: string
  transactions: Array<Transaction>
}

export interface SignContext {
  child?: ChildContext
  payload?: string
  partnerID?: number
}

export interface SignMessage {
  chainID: string
  message: string
}

export interface SignatureResult {
  signer: string
  wallet: string
  subdigest: string
  digest: string
  signature: string
}

export interface Guard {
  ping(headers?: object): Promise<PingReturn>
  version(headers?: object): Promise<VersionReturn>
  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>
  signTransactions(args: SignTransactionsArgs, headers?: object): Promise<SignTransactionsReturn>
  signMessage(args: SignMessageArgs, headers?: object): Promise<SignMessageReturn>
  getGuardSignerAddress(args: GetGuardSignerAddressArgs, headers?: object): Promise<GetGuardSignerAddressReturn>
  getWalletTransactionPolicyList(args: GetWalletTransactionPolicyListArgs, headers?: object): Promise<GetWalletTransactionPolicyListReturn>
  setWalletTransactionPolicyList(args: SetWalletTransactionPolicyListArgs, headers?: object): Promise<SetWalletTransactionPolicyListReturn>
  getSessionUserMapRules(args: GetSessionUserMapRulesArgs, headers?: object): Promise<GetSessionUserMapRulesReturn>
  setSessionUserMapRules(args: SetSessionUserMapRulesArgs, headers?: object): Promise<SetSessionUserMapRulesReturn>
  getSession(args: GetSessionArgs, headers?: object): Promise<GetSessionReturn>
  registerSession(args: RegisterSessionArgs, headers?: object): Promise<RegisterSessionReturn>
  startSessionValidation(args: StartSessionValidationArgs, headers?: object): Promise<StartSessionValidationReturn>
  validateSession(args: ValidateSessionArgs, headers?: object): Promise<ValidateSessionReturn>
  invalidateSession(args: InvalidateSessionArgs, headers?: object): Promise<InvalidateSessionReturn>
}

export interface PingArgs {
}

export interface PingReturn {
  status: boolean  
}
export interface VersionArgs {
}

export interface VersionReturn {
  version: Version  
}
export interface RuntimeStatusArgs {
}

export interface RuntimeStatusReturn {
  status: RuntimeStatus  
}
export interface SignTransactionsArgs {
  salt: string
  tx: TransactionBundle
  context: SignContext
}

export interface SignTransactionsReturn {
  sig: SignatureResult  
}
export interface SignMessageArgs {
  salt: string
  message: SignMessage
  context: SignContext
}

export interface SignMessageReturn {
  sig: SignatureResult  
}
export interface GetGuardSignerAddressArgs {
  salt: string
}

export interface GetGuardSignerAddressReturn {
  address: string  
}
export interface GetWalletTransactionPolicyListArgs {
  partnerId: number
}

export interface GetWalletTransactionPolicyListReturn {
  policyList: TransactionPolicyList  
}
export interface SetWalletTransactionPolicyListArgs {
  policyList: TransactionPolicyList
}

export interface SetWalletTransactionPolicyListReturn {  
}
export interface GetSessionUserMapRulesArgs {
  partnerId: number
}

export interface GetSessionUserMapRulesReturn {
  rules: SessionUserMapRules  
}
export interface SetSessionUserMapRulesArgs {
  rules: SessionUserMapRules
}

export interface SetSessionUserMapRulesReturn {  
}
export interface GetSessionArgs {
  partnerID: number
  sessionAddress: string
}

export interface GetSessionReturn {
  validated: boolean  
}
export interface RegisterSessionArgs {
  partnerID: number
  userID: string
  walletAddress: string
  payload: string
}

export interface RegisterSessionReturn {
  sessionId: string  
}
export interface StartSessionValidationArgs {
  partnerID: number
  sessionAddress: string
}

export interface StartSessionValidationReturn {
  salt: string  
}
export interface ValidateSessionArgs {
  sessionAddress: string
  salt: string
  challenge: string
}

export interface ValidateSessionReturn {
  status: boolean  
}
export interface InvalidateSessionArgs {
  sessionAddress: string
}

export interface InvalidateSessionReturn {
  status: boolean  
}


  
//
// Client
//
export class Guard implements Guard {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Guard/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(
      this.url('Ping'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>(_data.status)
        }
      })
    })
  }
  
  version = (headers?: object): Promise<VersionReturn> => {
    return this.fetch(
      this.url('Version'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          version: <Version>(_data.version)
        }
      })
    })
  }
  
  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {
    return this.fetch(
      this.url('RuntimeStatus'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          status: <RuntimeStatus>(_data.status)
        }
      })
    })
  }
  
  signTransactions = (args: SignTransactionsArgs, headers?: object): Promise<SignTransactionsReturn> => {
    return this.fetch(
      this.url('SignTransactions'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          sig: <SignatureResult>(_data.sig)
        }
      })
    })
  }
  
  signMessage = (args: SignMessageArgs, headers?: object): Promise<SignMessageReturn> => {
    return this.fetch(
      this.url('SignMessage'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          sig: <SignatureResult>(_data.sig)
        }
      })
    })
  }
  
  getGuardSignerAddress = (args: GetGuardSignerAddressArgs, headers?: object): Promise<GetGuardSignerAddressReturn> => {
    return this.fetch(
      this.url('GetGuardSignerAddress'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          address: <string>(_data.address)
        }
      })
    })
  }
  
  getWalletTransactionPolicyList = (args: GetWalletTransactionPolicyListArgs, headers?: object): Promise<GetWalletTransactionPolicyListReturn> => {
    return this.fetch(
      this.url('GetWalletTransactionPolicyList'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          policyList: <TransactionPolicyList>(_data.policyList)
        }
      })
    })
  }
  
  setWalletTransactionPolicyList = (args: SetWalletTransactionPolicyListArgs, headers?: object): Promise<SetWalletTransactionPolicyListReturn> => {
    return this.fetch(
      this.url('SetWalletTransactionPolicyList'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
        }
      })
    })
  }
  
  getSessionUserMapRules = (args: GetSessionUserMapRulesArgs, headers?: object): Promise<GetSessionUserMapRulesReturn> => {
    return this.fetch(
      this.url('GetSessionUserMapRules'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          rules: <SessionUserMapRules>(_data.rules)
        }
      })
    })
  }
  
  setSessionUserMapRules = (args: SetSessionUserMapRulesArgs, headers?: object): Promise<SetSessionUserMapRulesReturn> => {
    return this.fetch(
      this.url('SetSessionUserMapRules'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
        }
      })
    })
  }
  
  getSession = (args: GetSessionArgs, headers?: object): Promise<GetSessionReturn> => {
    return this.fetch(
      this.url('GetSession'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          validated: <boolean>(_data.validated)
        }
      })
    })
  }
  
  registerSession = (args: RegisterSessionArgs, headers?: object): Promise<RegisterSessionReturn> => {
    return this.fetch(
      this.url('RegisterSession'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          sessionId: <string>(_data.sessionId)
        }
      })
    })
  }
  
  startSessionValidation = (args: StartSessionValidationArgs, headers?: object): Promise<StartSessionValidationReturn> => {
    return this.fetch(
      this.url('StartSessionValidation'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          salt: <string>(_data.salt)
        }
      })
    })
  }
  
  validateSession = (args: ValidateSessionArgs, headers?: object): Promise<ValidateSessionReturn> => {
    return this.fetch(
      this.url('ValidateSession'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>(_data.status)
        }
      })
    })
  }
  
  invalidateSession = (args: InvalidateSessionArgs, headers?: object): Promise<InvalidateSessionReturn> => {
    return this.fetch(
      this.url('InvalidateSession'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>(_data.status)
        }
      })
    })
  }
  
}

  
export interface WebRPCError extends Error {
  code: string
  msg: string
	status: number
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError
    }
    if (!res.ok) {
      throw data // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
