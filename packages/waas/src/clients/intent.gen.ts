/* eslint-disable */
// sequence-waas-intents v0.1.0 7d401e1a69093dd5519b7a02f14de0c1380595e0
// --
// Code generated by webrpc-gen@v0.24.0 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=intent.ridl -target=typescript -out=./intent.gen.ts

export const WebrpcHeader = "Webrpc"

export const WebrpcHeaderValue = "webrpc@v0.24.0;gen-typescript@v0.16.3;sequence-waas-intents@v0.1.0"

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v0.1.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "7d401e1a69093dd5519b7a02f14de0c1380595e0"

type WebrpcGenVersions = {
  webrpcGenVersion: string;
  codeGenName: string;
  codeGenVersion: string;
  schemaName: string;
  schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader);
  if (!headerValue) {
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  return parseWebrpcGenVersions(headerValue);
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(";");
  if (versions.length < 3) {
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  const [_, webrpcGenVersion] = versions[0]!.split("@");
  const [codeGenName, codeGenVersion] = versions[1]!.split("@");
  const [schemaName, schemaVersion] = versions[2]!.split("@");

  return {
    webrpcGenVersion: webrpcGenVersion ?? "",
    codeGenName: codeGenName ?? "",
    codeGenVersion: codeGenVersion ?? "",
    schemaName: schemaName ?? "",
    schemaVersion: schemaVersion ?? "",
  };
}

//
// Types
//


export enum IntentName {
  initiateAuth = 'initiateAuth',
  openSession = 'openSession',
  closeSession = 'closeSession',
  validateSession = 'validateSession',
  finishValidateSession = 'finishValidateSession',
  listSessions = 'listSessions',
  getSession = 'getSession',
  sessionAuthProof = 'sessionAuthProof',
  feeOptions = 'feeOptions',
  signMessage = 'signMessage',
  signTypedData = 'signTypedData',
  sendTransaction = 'sendTransaction',
  getTransactionReceipt = 'getTransactionReceipt',
  federateAccount = 'federateAccount',
  removeAccount = 'removeAccount',
  listAccounts = 'listAccounts',
  getIdToken = 'getIdToken',
  adoptChildWallet = 'adoptChildWallet',
  getAdopter = 'getAdopter',
  confirmIntent = 'confirmIntent',
  getConfirmationStatus = 'getConfirmationStatus'
}

export enum TransactionType {
  transaction = 'transaction',
  erc20send = 'erc20send',
  erc721send = 'erc721send',
  erc1155send = 'erc1155send',
  delayedEncode = 'delayedEncode',
  contractCall = 'contractCall'
}

export enum IntentResponseCode {
  authInitiated = 'authInitiated',
  sessionOpened = 'sessionOpened',
  sessionClosed = 'sessionClosed',
  sessionList = 'sessionList',
  validationRequired = 'validationRequired',
  validationStarted = 'validationStarted',
  validationFinished = 'validationFinished',
  sessionAuthProof = 'sessionAuthProof',
  signedMessage = 'signedMessage',
  signedTypedData = 'signedTypedData',
  feeOptions = 'feeOptions',
  transactionReceipt = 'transactionReceipt',
  transactionFailed = 'transactionFailed',
  getSessionResponse = 'getSessionResponse',
  accountList = 'accountList',
  accountFederated = 'accountFederated',
  accountRemoved = 'accountRemoved',
  idToken = 'idToken',
  adopter = 'adopter',
  childWalletAdopted = 'childWalletAdopted',
  confirmationRequired = 'confirmationRequired'
}

export enum FeeTokenType {
  unknown = 'unknown',
  erc20Token = 'erc20Token',
  erc1155Token = 'erc1155Token'
}

export enum IdentityType {
  None = 'None',
  Guest = 'Guest',
  OIDC = 'OIDC',
  Email = 'Email',
  PlayFab = 'PlayFab',
  Stytch = 'Stytch',
  Twitter = 'Twitter'
}

export enum ChallengeType {
  EmailOTP = 'EmailOTP'
}

export interface Intent {
  version: string
  name: IntentName
  expiresAt: number
  issuedAt: number
  data: any
  signatures: Array<Signature>
}

export interface Signature {
  sessionId: string
  signature: string
}

export interface IntentDataInitiateAuth {
  sessionId: string
  identityType: IdentityType
  verifier: string
  metadata?: string
}

export interface IntentDataOpenSession {
  sessionId: string
  identityType: IdentityType
  verifier?: string
  answer?: string
  forceCreateAccount?: boolean
  email?: string
  idToken?: string
}

export interface IntentDataCloseSession {
  sessionId: string
}

export interface IntentDataValidateSession {
  sessionId: string
  wallet: string
  deviceMetadata: string
}

export interface IntentDataFinishValidateSession {
  sessionId: string
  wallet: string
  salt: string
  challenge: string
}

export interface IntentDataListSessions {
  wallet: string
}

export interface IntentDataGetSession {
  sessionId: string
  wallet: string
}

export interface IntentDataSessionAuthProof {
  network: string
  wallet: string
  nonce?: string
}

export interface IntentDataSignMessage {
  network: string
  wallet: string
  message: string
}

export interface IntentDataSignTypedData {
  network: string
  wallet: string
  typedData: any
}

export interface IntentDataFeeOptions {
  network: string
  wallet: string
  identifier: string
  transactions: Array<any>
}

export interface IntentDataSendTransaction {
  network: string
  wallet: string
  identifier: string
  transactions: Array<any>
  transactionsFeeQuote?: string
}

export interface IntentDataGetTransactionReceipt {
  network: string
  wallet: string
  metaTxHash: string
}

export interface IntentDataFederateAccount {
  sessionId: string
  wallet: string
  identityType: IdentityType
  verifier?: string
  answer?: string
}

export interface IntentDataListAccounts {
  wallet: string
}

export interface IntentDataRemoveAccount {
  wallet: string
  accountId: string
}

export interface IntentDataAdoptChildWallet {
  network: string
  wallet: string
  adopter: string
  adopterProof: AdopterProof
}

export interface AdopterProof {
  message: string
  signature: string
}

export interface IntentDataGetIdToken {
  sessionId: string
  wallet: string
  nonce?: string
}

export interface IntentDataGetAdopter {
  wallet: string
}

export interface IntentDataConfirmIntent {
  wallet: string
  confirmationID: string
  challengeAnswer: string
}

export interface IntentDataGetConfirmationStatus {
  wallet: string
  confirmationID: string
}

export interface TransactionRaw {
  type: string
  to: string
  value?: string
  data: string
}

export interface AbiData {
  abi: string
  func?: string
  args: Array<any>
}

export interface TransactionERC20 {
  type: string
  tokenAddress: string
  to: string
  value: string
}

export interface TransactionERC721 {
  type: string
  tokenAddress: string
  to: string
  id: string
  safe?: boolean
  data?: string
}

export interface TransactionERC1155Value {
  id: string
  amount: string
}

export interface TransactionDelayedEncode {
  type: string
  to: string
  value: string
  data: any
}

export interface TransactionContractCall {
  type: string
  to: string
  value?: string
  data: AbiData
}

export interface TransactionERC1155 {
  type: string
  tokenAddress: string
  to: string
  vals: Array<TransactionERC1155Value>
  data?: string
}

export interface IntentResponse {
  code: IntentResponseCode
  data: any
}

export interface IntentResponseAuthInitiated {
  sessionId: string
  identityType: IdentityType
  expiresIn: number
  challenge?: string
}

export interface IntentResponseSessionOpened {
  sessionId: string
  wallet: string
}

export interface IntentResponseSessionClosed {
}

export interface IntentResponseValidateSession {
}

export interface IntentResponseValidationRequired {
  sessionId: string
}

export interface IntentResponseValidationStarted {
  salt: string
}

export interface IntentResponseValidationFinished {
  isValid: boolean
}

export interface IntentResponseListSessions {
  sessions: Array<string>
}

export interface IntentResponseGetSession {
  sessionId: string
  wallet: string
  validated: boolean
}

export interface IntentResponseSessionAuthProof {
  sessionId: string
  network: string
  wallet: string
  message: string
  signature: string
}

export interface IntentResponseSignedMessage {
  signature: string
  message: string
}

export interface IntentResponseSignedTypedData {
  signature: string
  encodedTypedData: string
}

export interface FeeOption {
  token: FeeToken
  to: string
  value: string
  gasLimit: number
}

export interface FeeToken {
  chainId: number
  name: string
  symbol: string
  type: FeeTokenType
  decimals?: number
  logoURL: string
  contractAddress?: string
  tokenID?: string
}

export interface IntentResponseFeeOptions {
  feeOptions: Array<FeeOption>
  feeQuote?: string
}

export interface IntentResponseTransactionReceipt {
  request: any
  txHash: string
  metaTxHash: string
  receipt: any
  nativeReceipt: any
  simulations: any
}

export interface IntentResponseTransactionFailed {
  error: string
  request: any
  simulations: any
}

export interface IntentResponseAccountList {
  accounts: Array<Account>
  currentAccountId: string
}

export interface IntentResponseAccountFederated {
  account: Account
}

export interface IntentResponseAccountRemoved {
}

export interface IntentResponseIdToken {
  idToken: string
  expiresIn: number
}

export interface IntentResponseChildWalletAdopted {
  adopterAddress: string
}

export interface IntentResponseAdopter {
  adopterAddress: string
}

export interface IntentResponseConfirmationRequired {
  confirmationId: string
  salt: string
  challengeType: ChallengeType
  challengeDestination?: string
  expiresIn: number
}

export interface Account {
  id: string
  type: IdentityType
  issuer?: string
  email?: string
}
