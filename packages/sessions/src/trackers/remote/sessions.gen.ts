/* eslint-disable */
// sessions v0.0.1 b96502864e03f0bea75f41cafaf2178946a9e3b7
// --
// Code generated by webrpc-gen@v0.10.x-dev with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=sessions.ridl -target=typescript -client -out=./sessions.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = 'v1'

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = 'v0.0.1'

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = 'b96502864e03f0bea75f41cafaf2178946a9e3b7'

//
// Types
//

export enum SignatureType {
  EIP712 = 'EIP712',
  EthSign = 'EthSign',
  EIP1271 = 'EIP1271'
}

export interface Context {
  version: number
  factory: string
  mainModule: string
  mainModuleUpgradable: string
  guestModule: string
  walletCreationCode: string
}

export interface Signature {
  digest: string
  toImageHash?: string
  chainID: string
  type: SignatureType
  signature: string
}

export interface ConfigUpdate {
  toImageHash: string
  signature: string
}

export interface Transaction {
  to: string
  value?: string
  data?: string
  gasLimit?: string
  delegateCall?: boolean
  revertOnError?: boolean
}

export interface TransactionBundle {
  executor: string
  transactions: Array<Transaction>
  nonce: string
  signature: string
}

export interface Sessions {
  ping(headers?: object): Promise<PingReturn>
  config(args: ConfigArgs, headers?: object): Promise<ConfigReturn>
  wallets(args: WalletsArgs, headers?: object): Promise<WalletsReturn>
  deployHash(args: DeployHashArgs, headers?: object): Promise<DeployHashReturn>
  configUpdates(args: ConfigUpdatesArgs, headers?: object): Promise<ConfigUpdatesReturn>
  migrations(args: MigrationsArgs, headers?: object): Promise<MigrationsReturn>
  saveConfig(args: SaveConfigArgs, headers?: object): Promise<SaveConfigReturn>
  saveWallet(args: SaveWalletArgs, headers?: object): Promise<SaveWalletReturn>
  saveSignature(args: SaveSignatureArgs, headers?: object): Promise<SaveSignatureReturn>
  saveSignerSignatures(args: SaveSignerSignaturesArgs, headers?: object): Promise<SaveSignerSignaturesReturn>
  saveMigration(args: SaveMigrationArgs, headers?: object): Promise<SaveMigrationReturn>
}

export interface PingArgs {}

export interface PingReturn {}
export interface ConfigArgs {
  imageHash: string
}

export interface ConfigReturn {
  version: number
  config: any
}
export interface WalletsArgs {
  signer: string
}

export interface WalletsReturn {
  wallets: { [key: string]: Signature }
}
export interface DeployHashArgs {
  wallet: string
}

export interface DeployHashReturn {
  deployHash: string
  context: Context
}
export interface ConfigUpdatesArgs {
  wallet: string
  fromImageHash: string
  allUpdates?: boolean
}

export interface ConfigUpdatesReturn {
  updates: Array<ConfigUpdate>
}
export interface MigrationsArgs {
  wallet: string
  fromVersion: number
  fromImageHash: string
  chainID?: string
}

export interface MigrationsReturn {
  migrations: { [key: string]: { [key: number]: { [key: string]: TransactionBundle } } }
}
export interface SaveConfigArgs {
  version: number
  config: any
}

export interface SaveConfigReturn {}
export interface SaveWalletArgs {
  version: number
  deployConfig: any
}

export interface SaveWalletReturn {}
export interface SaveSignatureArgs {
  wallet: string
  digest: string
  chainID: string
  signature: string
  toConfig?: any
}

export interface SaveSignatureReturn {}
export interface SaveSignerSignaturesArgs {
  wallet: string
  digest: string
  chainID: string
  signatures: Array<string>
  toConfig?: any
}

export interface SaveSignerSignaturesReturn {}
export interface SaveMigrationArgs {
  wallet: string
  fromVersion: number
  toVersion: number
  toConfig: any
  executor: string
  transactions: Array<Transaction>
  nonce: string
  signature: string
  chainID?: string
}

export interface SaveMigrationReturn {}

//
// Client
//
export class Sessions implements Sessions {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Sessions/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {}
      })
    })
  }

  config = (args: ConfigArgs, headers?: object): Promise<ConfigReturn> => {
    return this.fetch(this.url('Config'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          version: <number>_data.version,
          config: <any>_data.config
        }
      })
    })
  }

  wallets = (args: WalletsArgs, headers?: object): Promise<WalletsReturn> => {
    return this.fetch(this.url('Wallets'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          wallets: <{ [key: string]: Signature }>_data.wallets
        }
      })
    })
  }

  deployHash = (args: DeployHashArgs, headers?: object): Promise<DeployHashReturn> => {
    return this.fetch(this.url('DeployHash'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          deployHash: <string>_data.deployHash,
          context: <Context>_data.context
        }
      })
    })
  }

  configUpdates = (args: ConfigUpdatesArgs, headers?: object): Promise<ConfigUpdatesReturn> => {
    return this.fetch(this.url('ConfigUpdates'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          updates: <Array<ConfigUpdate>>_data.updates
        }
      })
    })
  }

  migrations = (args: MigrationsArgs, headers?: object): Promise<MigrationsReturn> => {
    return this.fetch(this.url('Migrations'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          migrations: <{ [key: string]: { [key: number]: { [key: string]: TransactionBundle } } }>_data.migrations
        }
      })
    })
  }

  saveConfig = (args: SaveConfigArgs, headers?: object): Promise<SaveConfigReturn> => {
    return this.fetch(this.url('SaveConfig'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {}
      })
    })
  }

  saveWallet = (args: SaveWalletArgs, headers?: object): Promise<SaveWalletReturn> => {
    return this.fetch(this.url('SaveWallet'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {}
      })
    })
  }

  saveSignature = (args: SaveSignatureArgs, headers?: object): Promise<SaveSignatureReturn> => {
    return this.fetch(this.url('SaveSignature'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {}
      })
    })
  }

  saveSignerSignatures = (args: SaveSignerSignaturesArgs, headers?: object): Promise<SaveSignerSignaturesReturn> => {
    return this.fetch(this.url('SaveSignerSignatures'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {}
      })
    })
  }

  saveMigration = (args: SaveMigrationArgs, headers?: object): Promise<SaveMigrationReturn> => {
    return this.fetch(this.url('SaveMigration'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {}
      })
    })
  }
}

export interface WebRPCError extends Error {
  code: string
  msg: string
  status: number
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (err) {
      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError
    }
    if (!res.ok) {
      throw data // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
