/* eslint-disable */
// trails-api v1.0.0 54cbe231c8762643c1a1b625b01d8a1ba6487cdd
// --
// Code generated by Webrpc-gen@v0.30.2 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=trails-api.ridl -target=typescript -client -out=./clients/trails-api.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = 'v1'

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = 'v1.0.0'

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = '54cbe231c8762643c1a1b625b01d8a1ba6487cdd'

//
// Client interface
//

export interface TrailsClient {
  ping(headers?: object, signal?: AbortSignal): Promise<PingResponse>

  version(headers?: object, signal?: AbortSignal): Promise<VersionResponse>

  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse>

  clock(headers?: object, signal?: AbortSignal): Promise<ClockResponse>

  quoteIntent(req: QuoteIntentRequest, headers?: object, signal?: AbortSignal): Promise<QuoteIntentResponse>

  commitIntent(req: CommitIntentRequest, headers?: object, signal?: AbortSignal): Promise<CommitIntentResponse>

  executeIntent(req: ExecuteIntentRequest, headers?: object, signal?: AbortSignal): Promise<ExecuteIntentResponse>

  waitIntentReceipt(req: WaitIntentReceiptRequest, headers?: object, signal?: AbortSignal): Promise<WaitIntentReceiptResponse>

  getIntentReceipt(req: GetIntentReceiptRequest, headers?: object, signal?: AbortSignal): Promise<GetIntentReceiptResponse>

  getIntent(req: GetIntentRequest, headers?: object, signal?: AbortSignal): Promise<GetIntentResponse>

  searchIntents(req: SearchIntentsRequest, headers?: object, signal?: AbortSignal): Promise<SearchIntentsResponse>

  getIntentTransactionHistory(
    req: GetIntentTransactionHistoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentTransactionHistoryResponse>

  getIntentGasFeeOptions(
    req: GetIntentGasFeeOptionsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentGasFeeOptionsResponse>

  getIntentEntryTransaction(
    req: GetIntentEntryTransactionRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentEntryTransactionResponse>
}

//
// Schema types
//

export enum TradeType {
  EXACT_INPUT = 'EXACT_INPUT',
  EXACT_OUTPUT = 'EXACT_OUTPUT'
}

export enum QuoteProviderType {
  RELAY = 'RELAY',
  CCTPV2 = 'CCTPV2',
  LIFI = 'LIFI'
}

export enum TransactionStatus {
  UNKNOWN = 'UNKNOWN',
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  FAILED = 'FAILED',
  SUCCEEDED = 'SUCCEEDED'
}

export enum IntentStatus {
  QUOTED = 'QUOTED',
  COMMITTED = 'COMMITTED',
  EXECUTING = 'EXECUTING',
  FAILED = 'FAILED',
  SUCCEEDED = 'SUCCEEDED'
}

export enum ChainGasUsageStatus {
  NORMAL = 'NORMAL',
  BUSY = 'BUSY',
  VERY_BUSY = 'VERY_BUSY'
}

export interface QuoteIntentRequest {
  ownerAddress: string
  originChainId: number
  originTokenAddress: string
  originTokenAmount?: bigint
  destinationChainId: number
  destinationTokenAddress: string
  destinationTokenAmount: bigint
  destinationToAddress: string
  destinationCallData?: string
  destinationCallValue?: string
  tradeType?: TradeType
  options?: QuoteIntentRequestOptions
}

export interface QuoteIntentRequestOptions {
  quoteProvider?: QuoteProviderType
  slippageTolerance?: number
  trailsAddressOverrides?: TrailsAddressOverrides
}

export interface Intent {
  intentId: string
  status: IntentStatus
  quoteRequest: QuoteIntentRequest
  ownerAddress: string
  originIntentAddress: string
  destinationIntentAddress: string
  destinationSalt: bigint
  depositTransaction: DepositTransaction
  calls: Array<IntentCalls>
  preconditions: Array<IntentPrecondition>
  metaTxns: Array<MetaTxn>
  quote: IntentProviderQuote
  fees: IntentFees
  trailsVersion: string
  expiresAt: string
  updatedAt?: string
  createdAt?: string
}

export interface DepositTransaction {
  toAddress: string
  tokenAddress: string
  decimals?: number
  amount: bigint
}

export interface IntentCalls {
  chainId: number
  space?: bigint
  nonce?: bigint
  calls: Array<TransactionCall>
}

export interface TransactionCall {
  to: string
  value?: bigint
  data?: string
  gasLimit?: bigint
  delegateCall?: boolean
  onlyFallback?: boolean
  behaviorOnError?: number
}

export interface IntentPrecondition {
  type: string
  chainId: number
  data: IntentPreconditionData
}

export interface IntentPreconditionData {
  address: string
  token: string
  min: number
}

export interface MetaTxn {
  id: string
  chainId: number
  walletAddress: string
  contract: string
  input: string
}

export interface IntentReceipt {
  intentId: string
  status: IntentStatus
  ownerAddress: string
  originChainId: number
  destinationChainId: number
  depositTransactionHash: string
  depositTransactionStatus: TransactionStatus
  originTransaction: IntentTransaction
  destinationTransaction: IntentTransaction
  processedAt?: string
  retryCount?: number
  updatedAt?: string
  createdAt?: string
}

export interface IntentTransaction {
  intentId: string
  chainId: number
  metaTxnId: string
  txnHash?: string
  toAddress: string
  tokenAddress: string
  tokenAmount: bigint
  txnStatus: TransactionStatus
  updatedAt?: string
  createdAt?: string
}

export interface IntentProviderQuote {
  quoteProvider: string
  quoteProviderRequestId: string
  quoteProviderFeeUsd: number
  fromAmount: bigint
  fromAmountMin: bigint
  toAmount: bigint
  toAmountMin: bigint
  maxSlippage: number
  priceImpact: number
  priceImpactUsd: number
}

export interface IntentFees {
  originGas: IntentTransactionGasFee
  destinationGas: IntentTransactionGasFee
  provider: IntentProviderFees
  feeTokenAddress: string
  feeTokenTotal: bigint
  totalFeeAmount: bigint
  totalFeeUsd: number
}

export interface IntentProviderFees {
  quoteProvider: string
  quoteProviderFee: bigint
  quoteProviderFeeUsd: number
  trailsFee: bigint
  trailsFeeUsd: number
  totalFeeAmount: bigint
  totalFeeUsd: number
}

export interface IntentTransactionGasFee {
  chainId: number
  totalGasLimit: bigint
  gasPrice: bigint
  nativeTokenSymbol: string
  nativeTokenPriceUsd?: number
  chainGasUsageStatus: ChainGasUsageStatus
  totalFeeAmount: bigint
  totalFeeUsd: string
  metaTxnFeeDetails: MetaTxnFeeDetails
  metaTxnGasQuote: string
}

export interface MetaTxnFeeDetails {
  metaTxnId: string
  estimatedGasLimit: bigint
  feeNative: bigint
}

export interface TokenPrice {
  token: Token
  price?: Price
  price24hChange?: Price
  price24hVol?: Price
  floorPrice: Price
  buyPrice: Price
  sellPrice: Price
  updatedAt: string
}

export interface Token {
  chainId: number
  tokenAddress: string
  tokenId?: string
}

export interface Price {
  value: number
  currency: string
}

export interface CCTPTransfer {
  id: string
  sourceTxHash: string
  sourceChainId: number
  destinationChainId: number
  message: string
  attestation: string
  status: string
  updatedAt?: string
  createdAt?: string
}

export interface GetIntentEntrypointDepositParams {
  userAddress: string
  tokenAddress: string
  amount: bigint
  intentAddress: string
  chainID: number
  deadline: number
  intentSignature: string
  usePermit?: boolean
  permitAmount?: bigint
  permitDeadline?: number
  permitSignature?: string
  feeAmount?: bigint
}

export interface GetIntentEntrypointDepositResult {
  depositWalletAddress: string
  metaTxn: MetaTxn
  feeQuote: string
  entrypointAddress: string
}

export interface GetIntentEntrypointDepositFeeOptionsParams {
  userAddress: string
  tokenAddress: string
  intentAddress: string
  amount: bigint
  chainID: number
}

export interface GetIntentEntrypointDepositFeeOptionsResult {
  gasEstimate: GasEstimate
  feeOptions: Array<FeeOption>
  expiresAt: number
  feeCollector: string
}

export interface GasEstimate {
  totalGas: number
  gasPrice: string
  nativeCost: string
  nativeCostUsd: number
}

export interface FeeOption {
  tokenAddress: string
  tokenSymbol: string
  tokenDecimals: number
  amount: string
  amountUsd: number
  feeCollector: string
}

export interface TrailsAddressOverrides {
  sequenceWalletFactoryAddress?: string
  sequenceWalletMainModuleAddress?: string
  sequenceWalletMainModuleUpgradableAddress?: string
  sequenceWalletGuestModuleAddress?: string
  sequenceWalletUtilsAddress?: string
}

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  runnables: any
}

export interface QuoteIntentResponse {
  intent: Intent
}

export interface CommitIntentRequest {
  intent: Intent
}

export interface CommitIntentResponse {
  intentId: string
}

export interface ExecuteIntentRequest {
  intentId: string
  depositTransactionHash: string
  transferTransactionHash: string
}

export interface ExecuteIntentResponse {
  intentId: string
  intentStatus: IntentStatus
}

export interface GetIntentReceiptRequest {
  intentId: string
}

export interface GetIntentReceiptResponse {
  intentReceipt: IntentReceipt
}

export interface WaitIntentReceiptRequest {
  intentId: string
}

export interface WaitIntentReceiptResponse {
  intentReceipt: IntentReceipt
  done: boolean
}

export interface GetIntentRequest {
  intentId: string
}

export interface GetIntentResponse {
  intent: Intent
}

export interface SearchIntentsRequest {
  byOriginIntentAddress?: string
  byDepositTransactionHash?: string
  byOwnerAddress?: string
}

export interface SearchIntentsResponse {
  intents: Array<Intent>
}

export interface GetIntentTransactionHistoryRequest {
  page?: Page
}

export interface GetIntentTransactionHistoryResponse {
  transactions: Array<IntentTransaction>
  nextPage?: Page
}

export interface GetIntentGasFeeOptionsRequest {
  params: GetIntentEntrypointDepositFeeOptionsParams
}

export interface GetIntentGasFeeOptionsResponse {
  result: GetIntentEntrypointDepositFeeOptionsResult
}

export interface GetIntentEntryTransactionRequest {
  params: GetIntentEntrypointDepositParams
}

export interface GetIntentEntryTransactionResponse {
  result: GetIntentEntrypointDepositResult
}

export interface Page {
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
  pageSize?: number
  more?: boolean
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface PingRequest {}

export interface PingResponse {
  status: boolean
}

export interface VersionRequest {}

export interface VersionResponse {
  version: Version
}

export interface RuntimeStatusRequest {}

export interface RuntimeStatusResponse {
  status: RuntimeStatus
}

export interface ClockRequest {}

export interface ClockResponse {
  serverTime: string
}

//
// Client
//

export class Trails implements TrailsClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Trails/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  queryKey = {
    ping: () => ['Trails', 'ping'] as const,
    version: () => ['Trails', 'version'] as const,
    runtimeStatus: () => ['Trails', 'runtimeStatus'] as const,
    clock: () => ['Trails', 'clock'] as const,
    quoteIntent: (req: QuoteIntentRequest) => ['Trails', 'quoteIntent', req] as const,
    commitIntent: (req: CommitIntentRequest) => ['Trails', 'commitIntent', req] as const,
    executeIntent: (req: ExecuteIntentRequest) => ['Trails', 'executeIntent', req] as const,
    waitIntentReceipt: (req: WaitIntentReceiptRequest) => ['Trails', 'waitIntentReceipt', req] as const,
    getIntentReceipt: (req: GetIntentReceiptRequest) => ['Trails', 'getIntentReceipt', req] as const,
    getIntent: (req: GetIntentRequest) => ['Trails', 'getIntent', req] as const,
    searchIntents: (req: SearchIntentsRequest) => ['Trails', 'searchIntents', req] as const,
    getIntentTransactionHistory: (req: GetIntentTransactionHistoryRequest) =>
      ['Trails', 'getIntentTransactionHistory', req] as const,
    getIntentGasFeeOptions: (req: GetIntentGasFeeOptionsRequest) => ['Trails', 'getIntentGasFeeOptions', req] as const,
    getIntentEntryTransaction: (req: GetIntentEntryTransactionRequest) => ['Trails', 'getIntentEntryTransaction', req] as const
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingResponse> => {
    return this.fetch(this.url('Ping'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<PingResponse>(_data, 'PingResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  version = (headers?: object, signal?: AbortSignal): Promise<VersionResponse> => {
    return this.fetch(this.url('Version'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<VersionResponse>(_data, 'VersionResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusResponse> => {
    return this.fetch(this.url('RuntimeStatus'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<RuntimeStatusResponse>(_data, 'RuntimeStatusResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  clock = (headers?: object, signal?: AbortSignal): Promise<ClockResponse> => {
    return this.fetch(this.url('Clock'), createHttpRequest('{}', headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ClockResponse>(_data, 'ClockResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  quoteIntent = (req: QuoteIntentRequest, headers?: object, signal?: AbortSignal): Promise<QuoteIntentResponse> => {
    return this.fetch(this.url('QuoteIntent'), createHttpRequest(JsonEncode(req, 'QuoteIntentRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<QuoteIntentResponse>(_data, 'QuoteIntentResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  commitIntent = (req: CommitIntentRequest, headers?: object, signal?: AbortSignal): Promise<CommitIntentResponse> => {
    return this.fetch(this.url('CommitIntent'), createHttpRequest(JsonEncode(req, 'CommitIntentRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<CommitIntentResponse>(_data, 'CommitIntentResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  executeIntent = (req: ExecuteIntentRequest, headers?: object, signal?: AbortSignal): Promise<ExecuteIntentResponse> => {
    return this.fetch(
      this.url('ExecuteIntent'),
      createHttpRequest(JsonEncode(req, 'ExecuteIntentRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<ExecuteIntentResponse>(_data, 'ExecuteIntentResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  waitIntentReceipt = (
    req: WaitIntentReceiptRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<WaitIntentReceiptResponse> => {
    return this.fetch(
      this.url('WaitIntentReceipt'),
      createHttpRequest(JsonEncode(req, 'WaitIntentReceiptRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<WaitIntentReceiptResponse>(_data, 'WaitIntentReceiptResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentReceipt = (
    req: GetIntentReceiptRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentReceiptResponse> => {
    return this.fetch(
      this.url('GetIntentReceipt'),
      createHttpRequest(JsonEncode(req, 'GetIntentReceiptRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetIntentReceiptResponse>(_data, 'GetIntentReceiptResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntent = (req: GetIntentRequest, headers?: object, signal?: AbortSignal): Promise<GetIntentResponse> => {
    return this.fetch(this.url('GetIntent'), createHttpRequest(JsonEncode(req, 'GetIntentRequest'), headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetIntentResponse>(_data, 'GetIntentResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  searchIntents = (req: SearchIntentsRequest, headers?: object, signal?: AbortSignal): Promise<SearchIntentsResponse> => {
    return this.fetch(
      this.url('SearchIntents'),
      createHttpRequest(JsonEncode(req, 'SearchIntentsRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<SearchIntentsResponse>(_data, 'SearchIntentsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentTransactionHistory = (
    req: GetIntentTransactionHistoryRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentTransactionHistoryResponse> => {
    return this.fetch(
      this.url('GetIntentTransactionHistory'),
      createHttpRequest(JsonEncode(req, 'GetIntentTransactionHistoryRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetIntentTransactionHistoryResponse>(_data, 'GetIntentTransactionHistoryResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentGasFeeOptions = (
    req: GetIntentGasFeeOptionsRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentGasFeeOptionsResponse> => {
    return this.fetch(
      this.url('GetIntentGasFeeOptions'),
      createHttpRequest(JsonEncode(req, 'GetIntentGasFeeOptionsRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetIntentGasFeeOptionsResponse>(_data, 'GetIntentGasFeeOptionsResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentEntryTransaction = (
    req: GetIntentEntryTransactionRequest,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentEntryTransactionResponse> => {
    return this.fetch(
      this.url('GetIntentEntryTransaction'),
      createHttpRequest(JsonEncode(req, 'GetIntentEntryTransactionRequest'), headers, signal)
    ).then(
      res => {
        return buildResponse(res).then(_data => {
          return JsonDecode<GetIntentEntryTransactionResponse>(_data, 'GetIntentEntryTransactionResponse')
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }
}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>

//
// BigInt helpers
//

const BIG_INT_FIELDS: { [typ: string]: (string | [string, string])[] } = {
  CommitIntentRequest: [['intent', 'Intent']],
  DepositTransaction: ['amount'],
  GetIntentEntryTransactionRequest: [['params', 'GetIntentEntrypointDepositParams']],
  GetIntentEntrypointDepositFeeOptionsParams: ['amount'],
  GetIntentEntrypointDepositParams: ['amount', 'permitAmount', 'feeAmount'],
  GetIntentGasFeeOptionsRequest: [['params', 'GetIntentEntrypointDepositFeeOptionsParams']],
  GetIntentReceiptResponse: [['intentReceipt', 'IntentReceipt']],
  GetIntentResponse: [['intent', 'Intent']],
  GetIntentTransactionHistoryResponse: [['transactions', 'IntentTransaction[]']],
  Intent: [
    ['quoteRequest', 'QuoteIntentRequest'],
    'destinationSalt',
    ['depositTransaction', 'DepositTransaction'],
    ['calls', 'IntentCalls[]'],
    ['quote', 'IntentProviderQuote'],
    ['fees', 'IntentFees']
  ],
  IntentCalls: ['space', 'nonce', ['calls', 'TransactionCall[]']],
  IntentFees: [
    ['originGas', 'IntentTransactionGasFee'],
    ['destinationGas', 'IntentTransactionGasFee'],
    ['provider', 'IntentProviderFees'],
    'feeTokenTotal',
    'totalFeeAmount'
  ],
  IntentProviderFees: ['quoteProviderFee', 'trailsFee', 'totalFeeAmount'],
  IntentProviderQuote: ['fromAmount', 'fromAmountMin', 'toAmount', 'toAmountMin'],
  IntentReceipt: [
    ['originTransaction', 'IntentTransaction'],
    ['destinationTransaction', 'IntentTransaction']
  ],
  IntentTransaction: ['tokenAmount'],
  IntentTransactionGasFee: ['totalGasLimit', 'gasPrice', 'totalFeeAmount', ['metaTxnFeeDetails', 'MetaTxnFeeDetails']],
  MetaTxnFeeDetails: ['estimatedGasLimit', 'feeNative'],
  QuoteIntentRequest: ['originTokenAmount', 'destinationTokenAmount'],
  QuoteIntentResponse: [['intent', 'Intent']],
  SearchIntentsResponse: [['intents', 'Intent[]']],
  TransactionCall: ['value', 'gasLimit'],
  WaitIntentReceiptResponse: [['intentReceipt', 'IntentReceipt']]
}

// Encode in-place: mutate provided object graph to serialize bigints to strings.
function encodeType(typ: string, obj: any): any {
  if (obj == null || typeof obj !== 'object') return obj
  const descs = BIG_INT_FIELDS[typ] || []
  if (!descs.length) return obj
  for (const d of descs) {
    if (Array.isArray(d)) {
      const [fieldName, nestedType] = d
      if (fieldName.endsWith('[]')) {
        const base = fieldName.slice(0, -2)
        const arr = obj[base]
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] = encodeType(nestedType, arr[i])
        }
      } else if (obj[fieldName]) {
        obj[fieldName] = encodeType(nestedType, obj[fieldName])
      }
      continue
    }
    if (d.endsWith('[]')) {
      const base = d.slice(0, -2)
      const arr = obj[base]
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) {
          if (typeof arr[i] === 'bigint') arr[i] = arr[i].toString()
        }
      }
      continue
    }
    if (typeof obj[d] === 'bigint') obj[d] = obj[d].toString()
  }
  return obj
}

// Decode in-place: mutate object graph; throw if expected numeric string is invalid.
function decodeType(typ: string, obj: any): any {
  if (obj == null || typeof obj !== 'object') return obj
  const descs = BIG_INT_FIELDS[typ] || []
  if (!descs.length) return obj
  for (const d of descs) {
    if (Array.isArray(d)) {
      const [fieldName, nestedType] = d
      if (fieldName.endsWith('[]')) {
        const base = fieldName.slice(0, -2)
        const arr = obj[base]
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] = decodeType(nestedType, arr[i])
        }
      } else if (obj[fieldName]) {
        obj[fieldName] = decodeType(nestedType, obj[fieldName])
      }
      continue
    }
    if (d.endsWith('[]')) {
      const base = d.slice(0, -2)
      const arr = obj[base]
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i]
          if (typeof v === 'string') {
            try {
              arr[i] = BigInt(v)
            } catch (e) {
              throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${base}[${i}]: ${v}` })
            }
          }
        }
      }
      continue
    }
    const v = obj[d]
    if (typeof v === 'string') {
      try {
        obj[d] = BigInt(v)
      } catch (e) {
        throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${d}: ${v}` })
      }
    }
  }
  return obj
}

// Encode object of given root type to JSON with BigInts converted to decimal strings.
export const JsonEncode = <T = any>(obj: T, typ: string = ''): string => {
  return JSON.stringify(encodeType(typ, obj))
}

// Decode data (JSON string or already-parsed object) and convert declared BigInt string fields back to BigInt.
export const JsonDecode = <T = any>(data: string | any, typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try {
      parsed = JSON.parse(data)
    } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return decodeType(typ, parsed) as T
}

//
// Errors
//

type WebrpcErrorParams = { name?: string; code?: number; message?: string; status?: number; cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}

export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class AbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Aborted'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request aborted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Rate-limited. Please slow down.`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1008
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1101
    this.message = error.message || `Access key not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyMismatch'
    this.code = typeof error.code === 'number' ? error.code : 1102
    this.message = error.message || `Access key mismatch`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidOrigin'
    this.code = typeof error.code === 'number' ? error.code : 1103
    this.message = error.message || `Invalid origin for Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidService'
    this.code = typeof error.code === 'number' ? error.code : 1104
    this.message = error.message || `Service not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnauthorizedUser'
    this.code = typeof error.code === 'number' ? error.code : 1105
    this.message = error.message || `Unauthorized user`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaExceeded'
    this.code = typeof error.code === 'number' ? error.code : 1200
    this.message = error.message || `Quota request exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class QuotaRateLimitError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaRateLimit'
    this.code = typeof error.code === 'number' ? error.code : 1201
    this.message = error.message || `Quota rate limit exceeded`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaRateLimitError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NoDefaultKey'
    this.code = typeof error.code === 'number' ? error.code : 1300
    this.message = error.message || `No default access key found`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MaxAccessKeys'
    this.code = typeof error.code === 'number' ? error.code : 1301
    this.message = error.message || `Access keys limit reached`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AtLeastOneKey'
    this.code = typeof error.code === 'number' ? error.code : 1302
    this.message = error.message || `You need at least one Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 1900
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidArgument'
    this.code = typeof error.code === 'number' ? error.code : 2000
    this.message = error.message || `Invalid argument`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class UnexpectedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unexpected'
    this.code = typeof error.code === 'number' ? error.code : 2001
    this.message = error.message || `Unexpected server error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnexpectedError.prototype)
  }
}

export class UnavailableError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unavailable'
    this.code = typeof error.code === 'number' ? error.code : 2002
    this.message = error.message || `Unavailable resource`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnavailableError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QueryFailed'
    this.code = typeof error.code === 'number' ? error.code : 2003
    this.message = error.message || `Query failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class IntentStatusError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'IntentStatus'
    this.code = typeof error.code === 'number' ? error.code : 2004
    this.message = error.message || `Invalid intent status`
    this.status = typeof error.status === 'number' ? error.status : 422
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, IntentStatusError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NotFound'
    this.code = typeof error.code === 'number' ? error.code : 8000
    this.message = error.message || `Resource not found`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class UnsupportedNetworkError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnsupportedNetwork'
    this.code = typeof error.code === 'number' ? error.code : 8008
    this.message = error.message || `Unsupported network`
    this.status = typeof error.status === 'number' ? error.status : 422
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnsupportedNetworkError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Aborted = 'Aborted',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  ProjectNotFound = 'ProjectNotFound',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AccessKeyMismatch = 'AccessKeyMismatch',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  UnauthorizedUser = 'UnauthorizedUser',
  QuotaExceeded = 'QuotaExceeded',
  QuotaRateLimit = 'QuotaRateLimit',
  NoDefaultKey = 'NoDefaultKey',
  MaxAccessKeys = 'MaxAccessKeys',
  AtLeastOneKey = 'AtLeastOneKey',
  Timeout = 'Timeout',
  InvalidArgument = 'InvalidArgument',
  Unexpected = 'Unexpected',
  Unavailable = 'Unavailable',
  QueryFailed = 'QueryFailed',
  IntentStatus = 'IntentStatus',
  NotFound = 'NotFound',
  UnsupportedNetwork = 'UnsupportedNetwork'
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Aborted = 1005,
  Geoblocked = 1006,
  RateLimited = 1007,
  ProjectNotFound = 1008,
  AccessKeyNotFound = 1101,
  AccessKeyMismatch = 1102,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  UnauthorizedUser = 1105,
  QuotaExceeded = 1200,
  QuotaRateLimit = 1201,
  NoDefaultKey = 1300,
  MaxAccessKeys = 1301,
  AtLeastOneKey = 1302,
  Timeout = 1900,
  InvalidArgument = 2000,
  Unexpected = 2001,
  Unavailable = 2002,
  QueryFailed = 2003,
  IntentStatus = 2004,
  NotFound = 8000,
  UnsupportedNetwork = 8008
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [1006]: GeoblockedError,
  [1007]: RateLimitedError,
  [1008]: ProjectNotFoundError,
  [1101]: AccessKeyNotFoundError,
  [1102]: AccessKeyMismatchError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1105]: UnauthorizedUserError,
  [1200]: QuotaExceededError,
  [1201]: QuotaRateLimitError,
  [1300]: NoDefaultKeyError,
  [1301]: MaxAccessKeysError,
  [1302]: AtLeastOneKeyError,
  [1900]: TimeoutError,
  [2000]: InvalidArgumentError,
  [2001]: UnexpectedError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [2004]: IntentStatusError,
  [8000]: NotFoundError,
  [8008]: UnsupportedNetworkError
}

//
// Webrpc
//

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.30.2;gen-typescript@v0.22.2;trails-api@v1.0.0'

type WebrpcGenVersions = {
  WebrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  const [_, WebrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? ''
  }
}
