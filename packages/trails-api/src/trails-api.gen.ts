/* eslint-disable */
// trails-api v0.4.0 382b29dc1d49e1b98fb4b074aec76beb06a1cd3d
// --
// Code generated by webrpc-gen@v0.28.1 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=typescript -client -out=./clients/trails-api.gen.ts

export const WebrpcHeader = 'Webrpc'

export const WebrpcHeaderValue = 'webrpc@v0.28.1;gen-typescript@v0.19.0;trails-api@v0.4.0'

// WebRPC description and code-gen version
export const WebRPCVersion = 'v1'

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = '382b29dc1d49e1b98fb4b074aec76beb06a1cd3d'

type WebrpcGenVersions = {
  webrpcGenVersion: string
  codeGenName: string
  codeGenVersion: string
  schemaName: string
  schemaVersion: string
}

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(';')
  if (versions.length < 3) {
    return {
      webrpcGenVersion: '',
      codeGenName: '',
      codeGenVersion: '',
      schemaName: '',
      schemaVersion: ''
    }
  }

  const [_, webrpcGenVersion] = versions[0]!.split('@')
  const [codeGenName, codeGenVersion] = versions[1]!.split('@')
  const [schemaName, schemaVersion] = versions[2]!.split('@')

  return {
    webrpcGenVersion: webrpcGenVersion ?? '',
    codeGenName: codeGenName ?? '',
    codeGenVersion: codeGenVersion ?? '',
    schemaName: schemaName ?? '',
    schemaVersion: schemaVersion ?? ''
  }
}

//
// Types
//

export enum SortOrder {
  DESC = 'DESC',
  ASC = 'ASC'
}

export enum TradeType {
  EXACT_INPUT = 'EXACT_INPUT',
  EXACT_OUTPUT = 'EXACT_OUTPUT'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  checks: RuntimeChecks
  numTxnsRelayed: { [key: string]: NumTxnsRelayed }
}

export interface NumTxnsRelayed {
  chainID: number
  prev: number
  current: number
  period: number
}

export interface RuntimeChecks {}

export interface MetaTxn {
  id: string
  chainId: string
  walletAddress: string
  contract: string
  input: string
}

export interface Call {
  to: string
  value?: string
  data?: string
  gasLimit?: string
  delegateCall?: boolean
  onlyFallback?: boolean
  behaviorOnError?: number
}

export interface IntentCallsPayload {
  chainId: string
  space?: string
  nonce?: string
  calls: Array<Call>
}

export interface IntentConfig {
  id: number
  configHash: string
  originIntentAddress: string
  destinationIntentAddress: string
  mainSigner: string
  calls: Array<IntentCallsPayload>
  preconditions: Array<IntentPrecondition>
  executionStatus?: string
  metaTxnId?: string
  txnHash?: string
  updatedAt?: string
  createdAt?: string
}

export interface IntentTransaction {
  originIntentAddress: string
  destinationIntentAddress: string
  mainSigner: string
  metaTxnId?: string
  txnHash?: string
  executionStatus?: string
  originChainId?: number
  destinationChainId?: number
  originTokenAddress?: string
  originTokenAmount?: string
  destinationTokenAddress?: string
  destinationTokenAmount?: string
  destinationToAddress?: string
  createdAt?: string
}

export interface MetaTxnReceipt {
  metaTxID: string
  status: string
  txnReceipt?: string
  revertReason?: string
}

export interface AddressOverrides {
  trailsLiFiSapientSignerAddress?: string
  trailsRelaySapientSignerAddress?: string
  trailsCCTPV2SapientSignerAddress?: string
}

export interface TakerFee {
  address: string
  bps: number
}

export interface OriginCall {
  chainId: number
  to: string
  transactionData: string
  transactionValue: string
}

export interface IntentPrecondition {
  type: string
  chainId: string
  data: any
}

export interface Token {
  chainId: number
  contractAddress: string
  tokenId?: string
}

export interface Price {
  value: number
  currency: string
}

export interface TokenPrice {
  token: Token
  price?: Price
  price24hChange?: Price
  price24hVol?: Price
  floorPrice: Price
  buyPrice: Price
  sellPrice: Price
  updatedAt: string
}

export interface ExchangeRate {
  name: string
  symbol: string
  value: number
  vsCurrency: string
  currencyType: string
}

export interface Page {
  pageSize?: number
  page?: number
  totalRecords?: number
  column?: string
  before?: any
  after?: any
  sort?: Array<SortBy>
  more?: boolean
}

export interface SortBy {
  column: string
  order: SortOrder
}

export interface CCTPTransfer {
  id: string
  sourceTxHash: string
  sourceChainId: number
  destinationChainId: number
  message: string
  attestation: string
  status: string
  createdAt: string
  updatedAt: string
}

export interface GetIntentCallsPayloadParams {
  userAddress: string
  destinationChainId: number
  destinationTokenAddress: string
  destinationTokenAmount: string
  destinationToAddress: string
  originChainId: number
  originTokenAddress: string
  originTokenAmount: string
  destinationCallData?: string
  destinationCallValue?: string
  provider?: string
  addressOverrides?: AddressOverrides
  destinationSalt?: string
  takerFee?: TakerFee
  slippageTolerance?: number
  tradeType?: TradeType
}

export interface GetIntentsQuoteParams {
  userAddress: string
  destinationChainId: number
  destinationTokenAddress: string
  destinationTokenAmount: string
  destinationToAddress: string
  originChainId: number
  originTokenAddress: string
  originTokenAmount: string
  destinationCallData?: string
  destinationCallValue?: string
  provider?: string
  addressOverrides?: AddressOverrides
  destinationSalt?: string
  takerFee?: TakerFee
  slippageTolerance?: number
  tradeType?: TradeType
  exactInputOriginalTokenAmount?: string
}

export interface CommitIntentConfigParams {
  originIntentAddress: string
  destinationIntentAddress: string
  mainSigner: string
  calls: Array<IntentCallsPayload>
  preconditions: Array<IntentPrecondition>
  addressOverrides?: AddressOverrides
  requestParams?: IntentRequestParams
}

export interface IntentRequestParams {
  version: string
  userAddress: string
  destinationChainId: number
  destinationTokenAddress: string
  destinationTokenAmount: string
  destinationToAddress: string
  originChainId: number
  originTokenAddress: string
  originTokenAmount: string
  destinationCallData?: string
  destinationCallValue?: string
  createdAt: string
}

export interface IntentCallsPayloads {
  calls: Array<IntentCallsPayload>
  preconditions: Array<IntentPrecondition>
  metaTxns: Array<MetaTxn>
  trailsFee: TrailsFee
  quote: IntentQuote
  feeQuotes: { [key: string]: string }
  originIntentAddress: string
  destinationIntentAddress: string
}

export interface CrossChainFee {
  providerFee: string
  trailsSwapFee: string
  providerFeeUSD: number
  trailsSwapFeeUSD: number
  totalFeeAmount: string
  totalFeeUSD: number
}

export interface MetaTxnFeeDetail {
  metaTxnID: string
  estimatedGasLimit: string
  feeNative: string
}

export interface ChainExecuteQuote {
  chainId: string
  totalGasLimit: string
  gasPrice: string
  totalFeeAmount: string
  nativeTokenSymbol: string
  nativeTokenPrice?: string
  metaTxnFeeDetails: Array<MetaTxnFeeDetail>
  totalFeeUSD?: string
}

export interface ExecuteQuote {
  chainQuotes: Array<ChainExecuteQuote>
}

export interface TrailsFee {
  executeQuote: ExecuteQuote
  crossChainFee?: CrossChainFee
  takerFeeAmount?: string
  takerFeeUSD?: number
  trailsFixedFeeUSD: number
  feeToken?: string
  originTokenTotalAmount?: string
  totalFeeAmount?: string
  totalFeeUSD?: string
  quoteProvider?: string
}

export interface IntentQuote {
  fromAmount: string
  fromAmountMin: string
  toAmount: string
  toAmountMin: string
  priceImpact: number
  priceImpactUsd: string
  maxSlippage: number
  quoteProvider: string
  quoteProviderRequestId: string
  quoteProviderFeeUsd: string
  feeQuotes: { [key: string]: string }
}

export interface API {
  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>
  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>
  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>
  clock(headers?: object, signal?: AbortSignal): Promise<ClockReturn>
  /**
   * Generates complete intent execution payloads including calls, preconditions, meta transactions, and quotes for cross-chain swaps/transfers.
   */
  getIntentCallsPayloads(
    args: GetIntentCallsPayloadsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentCallsPayloadsReturn>
  getIntentsQuote(args: GetIntentsQuoteArgs, headers?: object, signal?: AbortSignal): Promise<GetIntentsQuoteReturn>
  /**
   * Persists intent configuration details to database for later execution, creating a new intent config record.
   */
  commitIntentConfig(args: CommitIntentConfigArgs, headers?: object, signal?: AbortSignal): Promise<CommitIntentConfigReturn>
  /**
   * Retrieves stored intent configuration by wallet address for inspection or execution.
   */
  getIntentConfig(args: GetIntentConfigArgs, headers?: object, signal?: AbortSignal): Promise<GetIntentConfigReturn>
  /**
   * Intent transaction history endpoint
   */
  getIntentTransactionHistory(
    args: GetIntentTransactionHistoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentTransactionHistoryReturn>
  getCCTPTransfer(args: GetCCTPTransferArgs, headers?: object, signal?: AbortSignal): Promise<GetCCTPTransferReturn>
  queueCCTPTransfer(args: QueueCCTPTransferArgs, headers?: object, signal?: AbortSignal): Promise<QueueCCTPTransferReturn>
  /**
   * Marks an intent config as ready for processing by the execution worker.
   */
  queueIntentConfigExecution(
    args: QueueIntentConfigExecutionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<QueueIntentConfigExecutionReturn>
  /**
   * Returns current execution status (pending/processing/executed/failed) for a given intent config.
   */
  getIntentConfigExecutionStatus(
    args: GetIntentConfigExecutionStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentConfigExecutionStatusReturn>
  /**
   * Paginated listing of intent configs with optional execution status filtering.
   */
  listIntentConfigs(args: ListIntentConfigsArgs, headers?: object, signal?: AbortSignal): Promise<ListIntentConfigsReturn>
  /**
   * Processes relay transaction receipts to update intent execution status and trigger refund logic.
   */
  queueMetaTxnReceipt(args: QueueMetaTxnReceiptArgs, headers?: object, signal?: AbortSignal): Promise<QueueMetaTxnReceiptReturn>
}

export interface PingArgs {}

export interface PingReturn {
  status: boolean
}
export interface VersionArgs {}

export interface VersionReturn {
  version: Version
}
export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: RuntimeStatus
}
export interface ClockArgs {}

export interface ClockReturn {
  serverTime: string
}
export interface GetIntentCallsPayloadsArgs {
  params: GetIntentCallsPayloadParams
}

export interface GetIntentCallsPayloadsReturn {
  payloads: IntentCallsPayloads
}
export interface GetIntentsQuoteArgs {
  params: GetIntentsQuoteParams
}

export interface GetIntentsQuoteReturn {
  quote: IntentQuote
}
export interface CommitIntentConfigArgs {
  params: CommitIntentConfigParams
}

export interface CommitIntentConfigReturn {
  config: IntentConfig
}
export interface GetIntentConfigArgs {
  intentAddress: string
}

export interface GetIntentConfigReturn {
  config: IntentConfig
}
export interface GetIntentTransactionHistoryArgs {
  accountAddress: string
  page?: Page
}

export interface GetIntentTransactionHistoryReturn {
  page: Page
  transactions: Array<IntentTransaction>
}
export interface GetCCTPTransferArgs {
  id: string
}

export interface GetCCTPTransferReturn {
  transfer: CCTPTransfer
}
export interface QueueCCTPTransferArgs {
  sourceTxHash?: string
  metaTxHash?: string
  sourceChainId: number
  destinationChainId: number
}

export interface QueueCCTPTransferReturn {
  transfer: CCTPTransfer
}
export interface QueueIntentConfigExecutionArgs {
  intentConfigId: number
}

export interface QueueIntentConfigExecutionReturn {
  status: boolean
}
export interface GetIntentConfigExecutionStatusArgs {
  intentConfigId: number
}

export interface GetIntentConfigExecutionStatusReturn {
  executionStatus: string
}
export interface ListIntentConfigsArgs {
  page?: Page
  executionStatus?: string
}

export interface ListIntentConfigsReturn {
  page: Page
  intentConfigs: Array<IntentConfig>
}
export interface QueueMetaTxnReceiptArgs {
  metaTxID: string
}

export interface QueueMetaTxnReceiptReturn {
  status: boolean
}

//
// Client
//
export class API implements API {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/API/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            status: <boolean>_data.status
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {
    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            version: <Version>_data.version
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {
    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            status: <RuntimeStatus>_data.status
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  clock = (headers?: object, signal?: AbortSignal): Promise<ClockReturn> => {
    return this.fetch(this.url('Clock'), createHTTPRequest({}, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            serverTime: <string>_data.serverTime
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentCallsPayloads = (
    args: GetIntentCallsPayloadsArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentCallsPayloadsReturn> => {
    return this.fetch(this.url('GetIntentCallsPayloads'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            payloads: <IntentCallsPayloads>_data.payloads
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentsQuote = (args: GetIntentsQuoteArgs, headers?: object, signal?: AbortSignal): Promise<GetIntentsQuoteReturn> => {
    return this.fetch(this.url('GetIntentsQuote'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            quote: <IntentQuote>_data.quote
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  commitIntentConfig = (
    args: CommitIntentConfigArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<CommitIntentConfigReturn> => {
    return this.fetch(this.url('CommitIntentConfig'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            config: <IntentConfig>_data.config
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentConfig = (args: GetIntentConfigArgs, headers?: object, signal?: AbortSignal): Promise<GetIntentConfigReturn> => {
    return this.fetch(this.url('GetIntentConfig'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            config: <IntentConfig>_data.config
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentTransactionHistory = (
    args: GetIntentTransactionHistoryArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentTransactionHistoryReturn> => {
    return this.fetch(this.url('GetIntentTransactionHistory'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            transactions: <Array<IntentTransaction>>_data.transactions
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getCCTPTransfer = (args: GetCCTPTransferArgs, headers?: object, signal?: AbortSignal): Promise<GetCCTPTransferReturn> => {
    return this.fetch(this.url('GetCCTPTransfer'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            transfer: <CCTPTransfer>_data.transfer
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  queueCCTPTransfer = (args: QueueCCTPTransferArgs, headers?: object, signal?: AbortSignal): Promise<QueueCCTPTransferReturn> => {
    return this.fetch(this.url('QueueCCTPTransfer'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            transfer: <CCTPTransfer>_data.transfer
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  queueIntentConfigExecution = (
    args: QueueIntentConfigExecutionArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<QueueIntentConfigExecutionReturn> => {
    return this.fetch(this.url('QueueIntentConfigExecution'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            status: <boolean>_data.status
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  getIntentConfigExecutionStatus = (
    args: GetIntentConfigExecutionStatusArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<GetIntentConfigExecutionStatusReturn> => {
    return this.fetch(this.url('GetIntentConfigExecutionStatus'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            executionStatus: <string>_data.executionStatus
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  listIntentConfigs = (args: ListIntentConfigsArgs, headers?: object, signal?: AbortSignal): Promise<ListIntentConfigsReturn> => {
    return this.fetch(this.url('ListIntentConfigs'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            page: <Page>_data.page,
            intentConfigs: <Array<IntentConfig>>_data.intentConfigs
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }

  queueMetaTxnReceipt = (
    args: QueueMetaTxnReceiptArgs,
    headers?: object,
    signal?: AbortSignal
  ): Promise<QueueMetaTxnReceiptReturn> => {
    return this.fetch(this.url('QueueMetaTxnReceipt'), createHTTPRequest(args, headers, signal)).then(
      res => {
        return buildResponse(res).then(_data => {
          return {
            status: <boolean>_data.status
          }
        })
      },
      error => {
        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
      }
    )
  }
}

const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  reqHeaders[WebrpcHeader] = WebrpcHeaderValue

  return {
    method: 'POST',
    headers: reqHeaders,
    body: JSON.stringify(body || {}),
    signal
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`
      })
    }
    if (!res.ok) {
      const code: number = typeof data.code === 'number' ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

//
// Errors
//

export class WebrpcError extends Error {
  name: string
  code: number
  message: string
  status: number
  cause?: string

  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg: string

  constructor(name: string, code: number, message: string, status: number, cause?: string) {
    super(message)
    this.name = name || 'WebrpcError'
    this.code = typeof code === 'number' ? code : 0
    this.message = message || `endpoint error ${this.code}`
    this.msg = this.message
    this.status = typeof status === 'number' ? status : 0
    this.cause = cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)
  }
}

// Webrpc errors

export class WebrpcEndpointError extends WebrpcError {
  constructor(
    name: string = 'WebrpcEndpoint',
    code: number = 0,
    message: string = `endpoint error`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcRequestFailed',
    code: number = -1,
    message: string = `request failed`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRoute',
    code: number = -2,
    message: string = `bad route`,
    status: number = 404,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadMethod',
    code: number = -3,
    message: string = `bad method`,
    status: number = 405,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadRequest',
    code: number = -4,
    message: string = `bad request`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(
    name: string = 'WebrpcBadResponse',
    code: number = -5,
    message: string = `bad response`,
    status: number = 500,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(
    name: string = 'WebrpcServerPanic',
    code: number = -6,
    message: string = `server panic`,
    status: number = 500,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(
    name: string = 'WebrpcInternalError',
    code: number = -7,
    message: string = `internal error`,
    status: number = 500,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcClientAborted',
    code: number = -8,
    message: string = `request aborted by client`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(
    name: string = 'WebrpcStreamLost',
    code: number = -9,
    message: string = `stream lost`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(
    name: string = 'WebrpcStreamFinished',
    code: number = -10,
    message: string = `stream finished`,
    status: number = 200,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}

// Schema errors

export class UnauthorizedError extends WebrpcError {
  constructor(
    name: string = 'Unauthorized',
    code: number = 1000,
    message: string = `Unauthorized access`,
    status: number = 401,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(
    name: string = 'PermissionDenied',
    code: number = 1001,
    message: string = `Permission denied`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(
    name: string = 'SessionExpired',
    code: number = 1002,
    message: string = `Session expired`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(
    name: string = 'MethodNotFound',
    code: number = 1003,
    message: string = `Method not found`,
    status: number = 404,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(
    name: string = 'RequestConflict',
    code: number = 1004,
    message: string = `Conflict with target resource`,
    status: number = 409,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class AbortedError extends WebrpcError {
  constructor(
    name: string = 'Aborted',
    code: number = 1005,
    message: string = `Request aborted`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(
    name: string = 'Geoblocked',
    code: number = 1006,
    message: string = `Geoblocked region`,
    status: number = 451,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(
    name: string = 'RateLimited',
    code: number = 1007,
    message: string = `Rate-limited. Please slow down.`,
    status: number = 429,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(
    name: string = 'ProjectNotFound',
    code: number = 1008,
    message: string = `Project not found`,
    status: number = 401,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(
    name: string = 'AccessKeyNotFound',
    code: number = 1101,
    message: string = `Access key not found`,
    status: number = 401,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(
    name: string = 'AccessKeyMismatch',
    code: number = 1102,
    message: string = `Access key mismatch`,
    status: number = 409,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(
    name: string = 'InvalidOrigin',
    code: number = 1103,
    message: string = `Invalid origin for Access Key`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(
    name: string = 'InvalidService',
    code: number = 1104,
    message: string = `Service not enabled for Access key`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(
    name: string = 'UnauthorizedUser',
    code: number = 1105,
    message: string = `Unauthorized user`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(
    name: string = 'QuotaExceeded',
    code: number = 1200,
    message: string = `Quota request exceeded`,
    status: number = 429,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class QuotaRateLimitError extends WebrpcError {
  constructor(
    name: string = 'QuotaRateLimit',
    code: number = 1201,
    message: string = `Quota rate limit exceeded`,
    status: number = 429,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, QuotaRateLimitError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(
    name: string = 'NoDefaultKey',
    code: number = 1300,
    message: string = `No default access key found`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(
    name: string = 'MaxAccessKeys',
    code: number = 1301,
    message: string = `Access keys limit reached`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(
    name: string = 'AtLeastOneKey',
    code: number = 1302,
    message: string = `You need at least one Access Key`,
    status: number = 403,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(
    name: string = 'Timeout',
    code: number = 1900,
    message: string = `Request timed out`,
    status: number = 408,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}

export class InvalidArgumentError extends WebrpcError {
  constructor(
    name: string = 'InvalidArgument',
    code: number = 2000,
    message: string = `Invalid argument`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, InvalidArgumentError.prototype)
  }
}

export class UnavailableError extends WebrpcError {
  constructor(
    name: string = 'Unavailable',
    code: number = 2002,
    message: string = `Unavailable resource`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnavailableError.prototype)
  }
}

export class QueryFailedError extends WebrpcError {
  constructor(
    name: string = 'QueryFailed',
    code: number = 2003,
    message: string = `Query failed`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, QueryFailedError.prototype)
  }
}

export class NotFoundError extends WebrpcError {
  constructor(
    name: string = 'NotFound',
    code: number = 8000,
    message: string = `Resource not found`,
    status: number = 400,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, NotFoundError.prototype)
  }
}

export class UnsupportedNetworkError extends WebrpcError {
  constructor(
    name: string = 'UnsupportedNetwork',
    code: number = 8008,
    message: string = `Unsupported network`,
    status: number = 422,
    cause?: string
  ) {
    super(name, code, message, status, cause)
    Object.setPrototypeOf(this, UnsupportedNetworkError.prototype)
  }
}

export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Aborted = 'Aborted',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  ProjectNotFound = 'ProjectNotFound',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AccessKeyMismatch = 'AccessKeyMismatch',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  UnauthorizedUser = 'UnauthorizedUser',
  QuotaExceeded = 'QuotaExceeded',
  QuotaRateLimit = 'QuotaRateLimit',
  NoDefaultKey = 'NoDefaultKey',
  MaxAccessKeys = 'MaxAccessKeys',
  AtLeastOneKey = 'AtLeastOneKey',
  Timeout = 'Timeout',
  InvalidArgument = 'InvalidArgument',
  Unavailable = 'Unavailable',
  QueryFailed = 'QueryFailed',
  NotFound = 'NotFound',
  UnsupportedNetwork = 'UnsupportedNetwork'
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Aborted = 1005,
  Geoblocked = 1006,
  RateLimited = 1007,
  ProjectNotFound = 1008,
  AccessKeyNotFound = 1101,
  AccessKeyMismatch = 1102,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  UnauthorizedUser = 1105,
  QuotaExceeded = 1200,
  QuotaRateLimit = 1201,
  NoDefaultKey = 1300,
  MaxAccessKeys = 1301,
  AtLeastOneKey = 1302,
  Timeout = 1900,
  InvalidArgument = 2000,
  Unavailable = 2002,
  QueryFailed = 2003,
  NotFound = 8000,
  UnsupportedNetwork = 8008
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [1006]: GeoblockedError,
  [1007]: RateLimitedError,
  [1008]: ProjectNotFoundError,
  [1101]: AccessKeyNotFoundError,
  [1102]: AccessKeyMismatchError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1105]: UnauthorizedUserError,
  [1200]: QuotaExceededError,
  [1201]: QuotaRateLimitError,
  [1300]: NoDefaultKeyError,
  [1301]: MaxAccessKeysError,
  [1302]: AtLeastOneKeyError,
  [1900]: TimeoutError,
  [2000]: InvalidArgumentError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [8000]: NotFoundError,
  [8008]: UnsupportedNetworkError
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
