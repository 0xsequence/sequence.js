/* eslint-disable */
// sequence-metadata v0.4.0 45fc83f7a323a06571e8834caf6fd768e324fb3f
// --
// Code generated by webrpc-gen@v0.14.0-dev with typescript@v0.10.0 generator. DO NOT EDIT.
//
// webrpc-gen -schema=metadata.ridl -target=typescript@v0.10.0 -client -out=./clients/metadata.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = 'v1'

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = 'v0.4.0'

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = '45fc83f7a323a06571e8834caf6fd768e324fb3f'

//
// Types
//

export enum ContractType {
  UNKNOWN = 'UNKNOWN',
  ERC20 = 'ERC20',
  ERC721 = 'ERC721',
  ERC1155 = 'ERC1155'
}
export enum PropertyType {
  INT = 'INT',
  STRING = 'STRING',
  ARRAY = 'ARRAY',
  GENERIC = 'GENERIC'
}
export enum SwapType {
  UNKNOWN = 'UNKNOWN',
  BUY = 'BUY',
  SELL = 'SELL'
}
export enum TaskStatus {
  PENDING = 'PENDING',
  PAUSED = 'PAUSED',
  FAILED = 'FAILED',
  COMPLETED = 'COMPLETED',
  DISABLED = 'DISABLED'
}

export interface Version {
  webrpcVersion: string
  schemaVersion: string
  schemaHash: string
  appVersion: string
}

export interface RuntimeStatus {
  healthOK: boolean
  startTime: string
  uptime: number
  ver: string
  branch: string
  commitHash: string
  checks: RuntimeChecks
}

export interface RuntimeChecks {}

export interface ContractIndex {
  collectionId?: number
  chainId: number
  address: string
  type: ContractType
  metadata: { [key: string]: any }
  contentHash: number
  deployed: boolean
  bytecodeHash: string
  notFound: boolean

  updatedAt: string
}

export interface TokenIndex {
  key: string
  chainId: number
  contractAddress: string
  tokenId: string
  metadata: { [key: string]: any }

  notFound?: boolean
  lastFetched?: string
  fetchCount?: number
  updatedAt: string
}

export interface ContractInfo {
  chainId: number
  address: string
  name: string
  type: string
  symbol: string
  decimals?: number
  logoURI: string
  deployed: boolean
  bytecodeHash: string
  extensions: ContractInfoExtensions

  updatedAt: string
}

export interface ContractInfoExtensions {
  link: string
  description: string
  ogImage: string
  originChainId: number
  originAddress: string
  blacklist: boolean
  verified: boolean
  verifiedBy: string
}

export interface TokenMetadata {
  tokenId: string
  name: string
  description?: string
  image?: string
  video?: string
  audio?: string
  properties?: { [key: string]: any }
  attributes: Array<{ [key: string]: any }>
  image_data?: string
  external_url?: string
  background_color?: string
  animation_url?: string
  decimals?: number
  updatedAt?: string
  assets?: Array<Asset>
}

export interface PropertyFilter {
  name: string
  type: PropertyType
  min?: number
  max?: number
  values?: Array<any>
}

export interface Filter {
  text?: string
  properties?: Array<PropertyFilter>
}

export interface Collection {
  id: number
  projectId: number
  metadata: CollectionMetadata
  private: boolean
  revealKey?: string
  createdAt?: string
  updatedAt?: string
  deletedAt?: string
  baseURIs?: CollectionBaseURIs
}

export interface CollectionMetadata {
  name: string
  description?: string
  image?: string
  external_link?: string
  properties?: { [key: string]: any }
  attributes?: Array<{ [key: string]: any }>
}

export interface CollectionBaseURIs {
  contractMetadataURI: string
  tokenMetadataURI: string
}

export interface Asset {
  id: number
  collectionId: number
  tokenId: string
  url?: string
  metadataField: string
  name?: string
  filesize?: number
  mimeType?: string
  width?: number
  height?: number
  updatedAt?: string
}

export interface Token {
  collectionId: number
  tokenId: string
  metadata: TokenMetadata
  private: boolean

  updatedAt?: string
}

export interface GetNiftyswapUnitPricesRequest {
  swapType: SwapType
  ids: Array<string>
  amounts: Array<string>
}

export interface GetNiftyswapUnitPricesResponse {
  unitPrice: string
  unitAmount: string
  availableAmount: string
}

export interface Page {
  page?: number
  column?: string
  before?: any
  after?: any
  pageSize?: number
  more?: boolean
}

export interface TaskRunner {
  id: number
  workGroup: string
  runAt: string
}

export interface Task {
  id: number
  queue: string
  status: TaskStatus
  try: number
  runAt?: string
  lastRanAt?: string
  createdAt?: string
  payload: Array<string>
  hash?: string
}

export interface Metadata {
  ping(headers?: object): Promise<PingReturn>
  version(headers?: object): Promise<VersionReturn>
  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>
  getTokenMetadata(args: GetTokenMetadataArgs, headers?: object): Promise<GetTokenMetadataReturn>
  refreshTokenMetadata(args: RefreshTokenMetadataArgs, headers?: object): Promise<RefreshTokenMetadataReturn>
  enqueueTokensForRefresh(args: EnqueueTokensForRefreshArgs, headers?: object): Promise<EnqueueTokensForRefreshReturn>
  getTokenRefreshStatus(args: GetTokenRefreshStatusArgs, headers?: object): Promise<GetTokenRefreshStatusReturn>
  getTokenRefreshResult(args: GetTokenRefreshResultArgs, headers?: object): Promise<GetTokenRefreshResultReturn>
  cancelRefreshJob(args: CancelRefreshJobArgs, headers?: object): Promise<CancelRefreshJobReturn>
  getTokenMetadataBatch(args: GetTokenMetadataBatchArgs, headers?: object): Promise<GetTokenMetadataBatchReturn>
  searchTokenMetadata(args: SearchTokenMetadataArgs, headers?: object): Promise<SearchTokenMetadataReturn>
  searchTokenIDs(args: SearchTokenIDsArgs, headers?: object): Promise<SearchTokenIDsReturn>
  tokenCollectionFilters(args: TokenCollectionFiltersArgs, headers?: object): Promise<TokenCollectionFiltersReturn>
  getContractInfo(args: GetContractInfoArgs, headers?: object): Promise<GetContractInfoReturn>
  getContractInfoBatch(args: GetContractInfoBatchArgs, headers?: object): Promise<GetContractInfoBatchReturn>
  searchContractInfo(args: SearchContractInfoArgs, headers?: object): Promise<SearchContractInfoReturn>
  searchContractInfoBatch(args: SearchContractInfoBatchArgs, headers?: object): Promise<SearchContractInfoBatchReturn>
  searchMetadata(args: SearchMetadataArgs, headers?: object): Promise<SearchMetadataReturn>
  getNiftyswapTokenQuantity(args: GetNiftyswapTokenQuantityArgs, headers?: object): Promise<GetNiftyswapTokenQuantityReturn>
  getNiftyswapUnitPrices(args: GetNiftyswapUnitPricesArgs, headers?: object): Promise<GetNiftyswapUnitPricesReturn>
  getNiftyswapUnitPricesWithQuantities(
    args: GetNiftyswapUnitPricesWithQuantitiesArgs,
    headers?: object
  ): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn>
  addContractToMintMonitor(args: AddContractToMintMonitorArgs, headers?: object): Promise<AddContractToMintMonitorReturn>
  removeContractFromMintMonitor(
    args: RemoveContractFromMintMonitorArgs,
    headers?: object
  ): Promise<RemoveContractFromMintMonitorReturn>
  mintMonitorJobStatus(args: MintMonitorJobStatusArgs, headers?: object): Promise<MintMonitorJobStatusReturn>
  mintMonitorTriggerJob(args: MintMonitorTriggerJobArgs, headers?: object): Promise<MintMonitorTriggerJobReturn>
}

export interface PingArgs {}

export interface PingReturn {
  status: boolean
}
export interface VersionArgs {}

export interface VersionReturn {
  version: Version
}
export interface RuntimeStatusArgs {}

export interface RuntimeStatusReturn {
  status: RuntimeStatus
}
export interface GetTokenMetadataArgs {
  chainID: string
  contractAddress: string
  tokenIDs: Array<string>
}

export interface GetTokenMetadataReturn {
  tokenMetadata: Array<TokenMetadata>
}
export interface RefreshTokenMetadataArgs {
  chainID: string
  contractAddress: string
  tokenIDs?: Array<string>
  refreshAll?: boolean
}

export interface RefreshTokenMetadataReturn {
  taskId: number
}
export interface EnqueueTokensForRefreshArgs {
  chainID: string
  contractAddress: string
  tokenIDs?: Array<string>
  refreshAll?: boolean
}

export interface EnqueueTokensForRefreshReturn {
  taskId: number
}
export interface GetTokenRefreshStatusArgs {
  taskId: number
}

export interface GetTokenRefreshStatusReturn {
  status: TaskStatus
}
export interface GetTokenRefreshResultArgs {
  taskId: number
}

export interface GetTokenRefreshResultReturn {
  status: TaskStatus
  tokens: { [key: string]: boolean }
  failureReasons: { [key: string]: string }
}
export interface CancelRefreshJobArgs {
  taskId: number
}

export interface CancelRefreshJobReturn {
  ok: boolean
}
export interface GetTokenMetadataBatchArgs {
  chainID: string
  contractTokenMap: { [key: string]: Array<string> }
}

export interface GetTokenMetadataBatchReturn {
  contractTokenMetadata: { [key: string]: Array<TokenMetadata> }
}
export interface SearchTokenMetadataArgs {
  chainID: string
  contractAddress: string
  filter: Filter
  page?: Page
}

export interface SearchTokenMetadataReturn {
  page: Page
  tokenMetadata: Array<TokenMetadata>
}
export interface SearchTokenIDsArgs {
  chainID: string
  contractAddress: string
  filter: Filter
  page?: Page
}

export interface SearchTokenIDsReturn {
  page: Page
  tokenIds: Array<string>
}
export interface TokenCollectionFiltersArgs {
  chainID: string
  contractAddress: string
}

export interface TokenCollectionFiltersReturn {
  filters: Array<PropertyFilter>
}
export interface GetContractInfoArgs {
  chainID: string
  contractAddress: string
}

export interface GetContractInfoReturn {
  contractInfo: ContractInfo
}
export interface GetContractInfoBatchArgs {
  chainID: string
  contractAddresses: Array<string>
}

export interface GetContractInfoBatchReturn {
  contractInfoMap: { [key: string]: ContractInfo }
}
export interface SearchContractInfoArgs {
  contractAddress: string
}

export interface SearchContractInfoReturn {
  contractInfoList: Array<ContractInfo>
}
export interface SearchContractInfoBatchArgs {
  contractAddresses: Array<string>
}

export interface SearchContractInfoBatchReturn {
  contractInfoByChain: { [key: string]: Array<ContractInfo> }
}
export interface SearchMetadataArgs {
  filter: string
  chainID?: string
  types?: Array<ContractType>
  excludeTokenMetadata?: boolean
}

export interface SearchMetadataReturn {
  tokenMetadata: Array<TokenMetadata>
  contractInfo: Array<ContractInfo>
}
export interface GetNiftyswapTokenQuantityArgs {
  chainID: string
  contractAddress: string
  tokenIDs: Array<string>
}

export interface GetNiftyswapTokenQuantityReturn {
  quantity: { [key: string]: string }
}
export interface GetNiftyswapUnitPricesArgs {
  chainID: string
  contractAddress: string
  req: GetNiftyswapUnitPricesRequest
  fresh: boolean
}

export interface GetNiftyswapUnitPricesReturn {
  prices: { [key: string]: string }
}
export interface GetNiftyswapUnitPricesWithQuantitiesArgs {
  chainID: string
  contractAddress: string
  req: GetNiftyswapUnitPricesRequest
  fresh: boolean
}

export interface GetNiftyswapUnitPricesWithQuantitiesReturn {
  prices: { [key: string]: GetNiftyswapUnitPricesResponse }
}
export interface AddContractToMintMonitorArgs {
  chainID: string
  contractAddress: string
}

export interface AddContractToMintMonitorReturn {
  ok: boolean
}
export interface RemoveContractFromMintMonitorArgs {
  chainID: string
  contractAddress: string
}

export interface RemoveContractFromMintMonitorReturn {
  ok: boolean
}
export interface MintMonitorJobStatusArgs {
  chainID: string
  contractAddress: string
}

export interface MintMonitorJobStatusReturn {
  task: Task
}
export interface MintMonitorTriggerJobArgs {
  chainID: string
  contractAddress: string
}

export interface MintMonitorTriggerJobReturn {
  ok: boolean
}

export interface Collections {
  createCollection(args: CreateCollectionArgs, headers?: object): Promise<CreateCollectionReturn>
  getCollection(args: GetCollectionArgs, headers?: object): Promise<GetCollectionReturn>
  listCollections(args: ListCollectionsArgs, headers?: object): Promise<ListCollectionsReturn>
  updateCollection(args: UpdateCollectionArgs, headers?: object): Promise<UpdateCollectionReturn>
  deleteCollection(args: DeleteCollectionArgs, headers?: object): Promise<DeleteCollectionReturn>
  publishCollection(args: PublishCollectionArgs, headers?: object): Promise<PublishCollectionReturn>
  unpublishCollection(args: UnpublishCollectionArgs, headers?: object): Promise<UnpublishCollectionReturn>
  createToken(args: CreateTokenArgs, headers?: object): Promise<CreateTokenReturn>
  getToken(args: GetTokenArgs, headers?: object): Promise<GetTokenReturn>
  listTokens(args: ListTokensArgs, headers?: object): Promise<ListTokensReturn>
  updateToken(args: UpdateTokenArgs, headers?: object): Promise<UpdateTokenReturn>
  deleteToken(args: DeleteTokenArgs, headers?: object): Promise<DeleteTokenReturn>
  createAsset(args: CreateAssetArgs, headers?: object): Promise<CreateAssetReturn>
  getAsset(args: GetAssetArgs, headers?: object): Promise<GetAssetReturn>
  updateAsset(args: UpdateAssetArgs, headers?: object): Promise<UpdateAssetReturn>
  deleteAsset(args: DeleteAssetArgs, headers?: object): Promise<DeleteAssetReturn>
}

export interface CreateCollectionArgs {
  projectId?: number
  collection: Collection
}

export interface CreateCollectionReturn {
  collection: Collection
}
export interface GetCollectionArgs {
  projectId?: number
  collectionId: number
}

export interface GetCollectionReturn {
  collection: Collection
}
export interface ListCollectionsArgs {
  projectId?: number
  page?: Page
}

export interface ListCollectionsReturn {
  page: Page
  collections: Array<Collection>
}
export interface UpdateCollectionArgs {
  projectId?: number
  collection: Collection
}

export interface UpdateCollectionReturn {
  collection: Collection
}
export interface DeleteCollectionArgs {
  projectId?: number
  collectionId: number
}

export interface DeleteCollectionReturn {
  status: boolean
}
export interface PublishCollectionArgs {
  projectId?: number
  collectionId: number
}

export interface PublishCollectionReturn {
  collection: Collection
}
export interface UnpublishCollectionArgs {
  projectId?: number
  collectionId: number
}

export interface UnpublishCollectionReturn {
  collection: Collection
}
export interface CreateTokenArgs {
  projectId?: number
  collectionId: number
  token: TokenMetadata
  private?: boolean
}

export interface CreateTokenReturn {
  token: TokenMetadata
  assets: Array<Asset>
}
export interface GetTokenArgs {
  projectId?: number
  collectionId: number
  tokenId: string
}

export interface GetTokenReturn {
  token: TokenMetadata
  assets: Array<Asset>
}
export interface ListTokensArgs {
  projectId?: number
  collectionId: number
  page?: Page
}

export interface ListTokensReturn {
  page: Page
  tokens: Array<TokenMetadata>
}
export interface UpdateTokenArgs {
  projectId?: number
  collectionId: number
  tokenId: string
  token: TokenMetadata
  private?: boolean
}

export interface UpdateTokenReturn {
  token: TokenMetadata
}
export interface DeleteTokenArgs {
  projectId?: number
  collectionId: number
  tokenId: string
}

export interface DeleteTokenReturn {
  status: boolean
}
export interface CreateAssetArgs {
  projectId?: number
  asset: Asset
}

export interface CreateAssetReturn {
  asset: Asset
}
export interface GetAssetArgs {
  projectId?: number
  assetId: number
}

export interface GetAssetReturn {
  asset: Asset
}
export interface UpdateAssetArgs {
  projectId?: number
  asset: Asset
}

export interface UpdateAssetReturn {
  asset: Asset
}
export interface DeleteAssetArgs {
  projectId?: number
  assetId: number
}

export interface DeleteAssetReturn {
  status: boolean
}

//
// Client
//
export class Metadata implements Metadata {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Metadata/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status
        }
      })
    })
  }

  version = (headers?: object): Promise<VersionReturn> => {
    return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          version: <Version>_data.version
        }
      })
    })
  }

  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {
    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <RuntimeStatus>_data.status
        }
      })
    })
  }

  getTokenMetadata = (args: GetTokenMetadataArgs, headers?: object): Promise<GetTokenMetadataReturn> => {
    return this.fetch(this.url('GetTokenMetadata'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          tokenMetadata: <Array<TokenMetadata>>_data.tokenMetadata
        }
      })
    })
  }

  refreshTokenMetadata = (args: RefreshTokenMetadataArgs, headers?: object): Promise<RefreshTokenMetadataReturn> => {
    return this.fetch(this.url('RefreshTokenMetadata'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          taskId: <number>_data.taskId
        }
      })
    })
  }

  enqueueTokensForRefresh = (args: EnqueueTokensForRefreshArgs, headers?: object): Promise<EnqueueTokensForRefreshReturn> => {
    return this.fetch(this.url('EnqueueTokensForRefresh'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          taskId: <number>_data.taskId
        }
      })
    })
  }

  getTokenRefreshStatus = (args: GetTokenRefreshStatusArgs, headers?: object): Promise<GetTokenRefreshStatusReturn> => {
    return this.fetch(this.url('GetTokenRefreshStatus'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <TaskStatus>_data.status
        }
      })
    })
  }

  getTokenRefreshResult = (args: GetTokenRefreshResultArgs, headers?: object): Promise<GetTokenRefreshResultReturn> => {
    return this.fetch(this.url('GetTokenRefreshResult'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <TaskStatus>_data.status,
          tokens: <{ [key: string]: boolean }>_data.tokens,
          failureReasons: <{ [key: string]: string }>_data.failureReasons
        }
      })
    })
  }

  cancelRefreshJob = (args: CancelRefreshJobArgs, headers?: object): Promise<CancelRefreshJobReturn> => {
    return this.fetch(this.url('CancelRefreshJob'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>_data.ok
        }
      })
    })
  }

  getTokenMetadataBatch = (args: GetTokenMetadataBatchArgs, headers?: object): Promise<GetTokenMetadataBatchReturn> => {
    return this.fetch(this.url('GetTokenMetadataBatch'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          contractTokenMetadata: <{ [key: string]: Array<TokenMetadata> }>_data.contractTokenMetadata
        }
      })
    })
  }

  searchTokenMetadata = (args: SearchTokenMetadataArgs, headers?: object): Promise<SearchTokenMetadataReturn> => {
    return this.fetch(this.url('SearchTokenMetadata'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          tokenMetadata: <Array<TokenMetadata>>_data.tokenMetadata
        }
      })
    })
  }

  searchTokenIDs = (args: SearchTokenIDsArgs, headers?: object): Promise<SearchTokenIDsReturn> => {
    return this.fetch(this.url('SearchTokenIDs'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          tokenIds: <Array<string>>_data.tokenIds
        }
      })
    })
  }

  tokenCollectionFilters = (args: TokenCollectionFiltersArgs, headers?: object): Promise<TokenCollectionFiltersReturn> => {
    return this.fetch(this.url('TokenCollectionFilters'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          filters: <Array<PropertyFilter>>_data.filters
        }
      })
    })
  }

  getContractInfo = (args: GetContractInfoArgs, headers?: object): Promise<GetContractInfoReturn> => {
    return this.fetch(this.url('GetContractInfo'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          contractInfo: <ContractInfo>_data.contractInfo
        }
      })
    })
  }

  getContractInfoBatch = (args: GetContractInfoBatchArgs, headers?: object): Promise<GetContractInfoBatchReturn> => {
    return this.fetch(this.url('GetContractInfoBatch'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          contractInfoMap: <{ [key: string]: ContractInfo }>_data.contractInfoMap
        }
      })
    })
  }

  searchContractInfo = (args: SearchContractInfoArgs, headers?: object): Promise<SearchContractInfoReturn> => {
    return this.fetch(this.url('SearchContractInfo'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          contractInfoList: <Array<ContractInfo>>_data.contractInfoList
        }
      })
    })
  }

  searchContractInfoBatch = (args: SearchContractInfoBatchArgs, headers?: object): Promise<SearchContractInfoBatchReturn> => {
    return this.fetch(this.url('SearchContractInfoBatch'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          contractInfoByChain: <{ [key: string]: Array<ContractInfo> }>_data.contractInfoByChain
        }
      })
    })
  }

  searchMetadata = (args: SearchMetadataArgs, headers?: object): Promise<SearchMetadataReturn> => {
    return this.fetch(this.url('SearchMetadata'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          tokenMetadata: <Array<TokenMetadata>>_data.tokenMetadata,
          contractInfo: <Array<ContractInfo>>_data.contractInfo
        }
      })
    })
  }

  getNiftyswapTokenQuantity = (
    args: GetNiftyswapTokenQuantityArgs,
    headers?: object
  ): Promise<GetNiftyswapTokenQuantityReturn> => {
    return this.fetch(this.url('GetNiftyswapTokenQuantity'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          quantity: <{ [key: string]: string }>_data.quantity
        }
      })
    })
  }

  getNiftyswapUnitPrices = (args: GetNiftyswapUnitPricesArgs, headers?: object): Promise<GetNiftyswapUnitPricesReturn> => {
    return this.fetch(this.url('GetNiftyswapUnitPrices'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          prices: <{ [key: string]: string }>_data.prices
        }
      })
    })
  }

  getNiftyswapUnitPricesWithQuantities = (
    args: GetNiftyswapUnitPricesWithQuantitiesArgs,
    headers?: object
  ): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn> => {
    return this.fetch(this.url('GetNiftyswapUnitPricesWithQuantities'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          prices: <{ [key: string]: GetNiftyswapUnitPricesResponse }>_data.prices
        }
      })
    })
  }

  addContractToMintMonitor = (args: AddContractToMintMonitorArgs, headers?: object): Promise<AddContractToMintMonitorReturn> => {
    return this.fetch(this.url('AddContractToMintMonitor'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>_data.ok
        }
      })
    })
  }

  removeContractFromMintMonitor = (
    args: RemoveContractFromMintMonitorArgs,
    headers?: object
  ): Promise<RemoveContractFromMintMonitorReturn> => {
    return this.fetch(this.url('RemoveContractFromMintMonitor'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>_data.ok
        }
      })
    })
  }

  mintMonitorJobStatus = (args: MintMonitorJobStatusArgs, headers?: object): Promise<MintMonitorJobStatusReturn> => {
    return this.fetch(this.url('MintMonitorJobStatus'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          task: <Task>_data.task
        }
      })
    })
  }

  mintMonitorTriggerJob = (args: MintMonitorTriggerJobArgs, headers?: object): Promise<MintMonitorTriggerJobReturn> => {
    return this.fetch(this.url('MintMonitorTriggerJob'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          ok: <boolean>_data.ok
        }
      })
    })
  }
}

export class Collections implements Collections {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Collections/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  createCollection = (args: CreateCollectionArgs, headers?: object): Promise<CreateCollectionReturn> => {
    return this.fetch(this.url('CreateCollection'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          collection: <Collection>_data.collection
        }
      })
    })
  }

  getCollection = (args: GetCollectionArgs, headers?: object): Promise<GetCollectionReturn> => {
    return this.fetch(this.url('GetCollection'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          collection: <Collection>_data.collection
        }
      })
    })
  }

  listCollections = (args: ListCollectionsArgs, headers?: object): Promise<ListCollectionsReturn> => {
    return this.fetch(this.url('ListCollections'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          collections: <Array<Collection>>_data.collections
        }
      })
    })
  }

  updateCollection = (args: UpdateCollectionArgs, headers?: object): Promise<UpdateCollectionReturn> => {
    return this.fetch(this.url('UpdateCollection'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          collection: <Collection>_data.collection
        }
      })
    })
  }

  deleteCollection = (args: DeleteCollectionArgs, headers?: object): Promise<DeleteCollectionReturn> => {
    return this.fetch(this.url('DeleteCollection'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status
        }
      })
    })
  }

  publishCollection = (args: PublishCollectionArgs, headers?: object): Promise<PublishCollectionReturn> => {
    return this.fetch(this.url('PublishCollection'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          collection: <Collection>_data.collection
        }
      })
    })
  }

  unpublishCollection = (args: UnpublishCollectionArgs, headers?: object): Promise<UnpublishCollectionReturn> => {
    return this.fetch(this.url('UnpublishCollection'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          collection: <Collection>_data.collection
        }
      })
    })
  }

  createToken = (args: CreateTokenArgs, headers?: object): Promise<CreateTokenReturn> => {
    return this.fetch(this.url('CreateToken'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          token: <TokenMetadata>_data.token,
          assets: <Array<Asset>>_data.assets
        }
      })
    })
  }

  getToken = (args: GetTokenArgs, headers?: object): Promise<GetTokenReturn> => {
    return this.fetch(this.url('GetToken'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          token: <TokenMetadata>_data.token,
          assets: <Array<Asset>>_data.assets
        }
      })
    })
  }

  listTokens = (args: ListTokensArgs, headers?: object): Promise<ListTokensReturn> => {
    return this.fetch(this.url('ListTokens'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          page: <Page>_data.page,
          tokens: <Array<TokenMetadata>>_data.tokens
        }
      })
    })
  }

  updateToken = (args: UpdateTokenArgs, headers?: object): Promise<UpdateTokenReturn> => {
    return this.fetch(this.url('UpdateToken'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          token: <TokenMetadata>_data.token
        }
      })
    })
  }

  deleteToken = (args: DeleteTokenArgs, headers?: object): Promise<DeleteTokenReturn> => {
    return this.fetch(this.url('DeleteToken'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status
        }
      })
    })
  }

  createAsset = (args: CreateAssetArgs, headers?: object): Promise<CreateAssetReturn> => {
    return this.fetch(this.url('CreateAsset'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          asset: <Asset>_data.asset
        }
      })
    })
  }

  getAsset = (args: GetAssetArgs, headers?: object): Promise<GetAssetReturn> => {
    return this.fetch(this.url('GetAsset'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          asset: <Asset>_data.asset
        }
      })
    })
  }

  updateAsset = (args: UpdateAssetArgs, headers?: object): Promise<UpdateAssetReturn> => {
    return this.fetch(this.url('UpdateAsset'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          asset: <Asset>_data.asset
        }
      })
    })
  }

  deleteAsset = (args: DeleteAssetArgs, headers?: object): Promise<DeleteAssetReturn> => {
    return this.fetch(this.url('DeleteAsset'), createHTTPRequest(args, headers)).then(res => {
      return buildResponse(res).then(_data => {
        return {
          status: <boolean>_data.status
        }
      })
    })
  }
}

export interface WebRPCError extends Error {
  code: string
  msg: string
  status: number
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch (err) {
      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError
    }
    if (!res.ok) {
      throw data // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
